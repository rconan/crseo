/* automatically generated by rust-bindgen 0.70.1 */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CUevent_st {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct float2 {
    pub x: f32,
    pub y: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of float2"][::std::mem::size_of::<float2>() - 8usize];
    ["Alignment of float2"][::std::mem::align_of::<float2>() - 8usize];
    ["Offset of field: float2::x"][::std::mem::offset_of!(float2, x) - 0usize];
    ["Offset of field: float2::y"][::std::mem::offset_of!(float2, y) - 4usize];
};
#[doc = " The API call returned with no errors. In the case of query calls, this\n also means that the operation being queried is complete (see\n ::cudaEventQuery() and ::cudaStreamQuery())."]
pub const cudaError_cudaSuccess: cudaError = 0;
#[doc = " This indicates that one or more of the parameters passed to the API call\n is not within an acceptable range of values."]
pub const cudaError_cudaErrorInvalidValue: cudaError = 1;
#[doc = " The API call failed because it was unable to allocate enough memory to\n perform the requested operation."]
pub const cudaError_cudaErrorMemoryAllocation: cudaError = 2;
#[doc = " The API call failed because the CUDA driver and runtime could not be\n initialized."]
pub const cudaError_cudaErrorInitializationError: cudaError = 3;
#[doc = " This indicates that a CUDA Runtime API call cannot be executed because\n it is being called during process shut down, at a point in time after\n CUDA driver has been unloaded."]
pub const cudaError_cudaErrorCudartUnloading: cudaError = 4;
#[doc = " This indicates profiler is not initialized for this run. This can\n happen when the application is running with external profiling tools\n like visual profiler."]
pub const cudaError_cudaErrorProfilerDisabled: cudaError = 5;
#[doc = " \\deprecated\n This error return is deprecated as of CUDA 5.0. It is no longer an error\n to attempt to enable/disable the profiling via ::cudaProfilerStart or\n ::cudaProfilerStop without initialization."]
pub const cudaError_cudaErrorProfilerNotInitialized: cudaError = 6;
#[doc = " \\deprecated\n This error return is deprecated as of CUDA 5.0. It is no longer an error\n to call cudaProfilerStart() when profiling is already enabled."]
pub const cudaError_cudaErrorProfilerAlreadyStarted: cudaError = 7;
#[doc = " \\deprecated\n This error return is deprecated as of CUDA 5.0. It is no longer an error\n to call cudaProfilerStop() when profiling is already disabled."]
pub const cudaError_cudaErrorProfilerAlreadyStopped: cudaError = 8;
#[doc = " This indicates that a kernel launch is requesting resources that can\n never be satisfied by the current device. Requesting more shared memory\n per block than the device supports will trigger this error, as will\n requesting too many threads or blocks. See ::cudaDeviceProp for more\n device limitations."]
pub const cudaError_cudaErrorInvalidConfiguration: cudaError = 9;
#[doc = " This indicates that one or more of the pitch-related parameters passed\n to the API call is not within the acceptable range for pitch."]
pub const cudaError_cudaErrorInvalidPitchValue: cudaError = 12;
#[doc = " This indicates that the symbol name/identifier passed to the API call\n is not a valid name or identifier."]
pub const cudaError_cudaErrorInvalidSymbol: cudaError = 13;
#[doc = " This indicates that at least one host pointer passed to the API call is\n not a valid host pointer.\n \\deprecated\n This error return is deprecated as of CUDA 10.1."]
pub const cudaError_cudaErrorInvalidHostPointer: cudaError = 16;
#[doc = " This indicates that at least one device pointer passed to the API call is\n not a valid device pointer.\n \\deprecated\n This error return is deprecated as of CUDA 10.1."]
pub const cudaError_cudaErrorInvalidDevicePointer: cudaError = 17;
#[doc = " This indicates that the texture passed to the API call is not a valid\n texture."]
pub const cudaError_cudaErrorInvalidTexture: cudaError = 18;
#[doc = " This indicates that the texture binding is not valid. This occurs if you\n call ::cudaGetTextureAlignmentOffset() with an unbound texture."]
pub const cudaError_cudaErrorInvalidTextureBinding: cudaError = 19;
#[doc = " This indicates that the channel descriptor passed to the API call is not\n valid. This occurs if the format is not one of the formats specified by\n ::cudaChannelFormatKind, or if one of the dimensions is invalid."]
pub const cudaError_cudaErrorInvalidChannelDescriptor: cudaError = 20;
#[doc = " This indicates that the direction of the memcpy passed to the API call is\n not one of the types specified by ::cudaMemcpyKind."]
pub const cudaError_cudaErrorInvalidMemcpyDirection: cudaError = 21;
#[doc = " This indicated that the user has taken the address of a constant variable,\n which was forbidden up until the CUDA 3.1 release.\n \\deprecated\n This error return is deprecated as of CUDA 3.1. Variables in constant\n memory may now have their address taken by the runtime via\n ::cudaGetSymbolAddress()."]
pub const cudaError_cudaErrorAddressOfConstant: cudaError = 22;
#[doc = " This indicated that a texture fetch was not able to be performed.\n This was previously used for device emulation of texture operations.\n \\deprecated\n This error return is deprecated as of CUDA 3.1. Device emulation mode was\n removed with the CUDA 3.1 release."]
pub const cudaError_cudaErrorTextureFetchFailed: cudaError = 23;
#[doc = " This indicated that a texture was not bound for access.\n This was previously used for device emulation of texture operations.\n \\deprecated\n This error return is deprecated as of CUDA 3.1. Device emulation mode was\n removed with the CUDA 3.1 release."]
pub const cudaError_cudaErrorTextureNotBound: cudaError = 24;
#[doc = " This indicated that a synchronization operation had failed.\n This was previously used for some device emulation functions.\n \\deprecated\n This error return is deprecated as of CUDA 3.1. Device emulation mode was\n removed with the CUDA 3.1 release."]
pub const cudaError_cudaErrorSynchronizationError: cudaError = 25;
#[doc = " This indicates that a non-float texture was being accessed with linear\n filtering. This is not supported by CUDA."]
pub const cudaError_cudaErrorInvalidFilterSetting: cudaError = 26;
#[doc = " This indicates that an attempt was made to read a non-float texture as a\n normalized float. This is not supported by CUDA."]
pub const cudaError_cudaErrorInvalidNormSetting: cudaError = 27;
#[doc = " Mixing of device and device emulation code was not allowed.\n \\deprecated\n This error return is deprecated as of CUDA 3.1. Device emulation mode was\n removed with the CUDA 3.1 release."]
pub const cudaError_cudaErrorMixedDeviceExecution: cudaError = 28;
#[doc = " This indicates that the API call is not yet implemented. Production\n releases of CUDA will never return this error.\n \\deprecated\n This error return is deprecated as of CUDA 4.1."]
pub const cudaError_cudaErrorNotYetImplemented: cudaError = 31;
#[doc = " This indicated that an emulated device pointer exceeded the 32-bit address\n range.\n \\deprecated\n This error return is deprecated as of CUDA 3.1. Device emulation mode was\n removed with the CUDA 3.1 release."]
pub const cudaError_cudaErrorMemoryValueTooLarge: cudaError = 32;
#[doc = " This indicates that the CUDA driver that the application has loaded is a\n stub library. Applications that run with the stub rather than a real\n driver loaded will result in CUDA API returning this error."]
pub const cudaError_cudaErrorStubLibrary: cudaError = 34;
#[doc = " This indicates that the installed NVIDIA CUDA driver is older than the\n CUDA runtime library. This is not a supported configuration. Users should\n install an updated NVIDIA display driver to allow the application to run."]
pub const cudaError_cudaErrorInsufficientDriver: cudaError = 35;
#[doc = " This indicates that the API call requires a newer CUDA driver than the one\n currently installed. Users should install an updated NVIDIA CUDA driver\n to allow the API call to succeed."]
pub const cudaError_cudaErrorCallRequiresNewerDriver: cudaError = 36;
#[doc = " This indicates that the surface passed to the API call is not a valid\n surface."]
pub const cudaError_cudaErrorInvalidSurface: cudaError = 37;
#[doc = " This indicates that multiple global or constant variables (across separate\n CUDA source files in the application) share the same string name."]
pub const cudaError_cudaErrorDuplicateVariableName: cudaError = 43;
#[doc = " This indicates that multiple textures (across separate CUDA source\n files in the application) share the same string name."]
pub const cudaError_cudaErrorDuplicateTextureName: cudaError = 44;
#[doc = " This indicates that multiple surfaces (across separate CUDA source\n files in the application) share the same string name."]
pub const cudaError_cudaErrorDuplicateSurfaceName: cudaError = 45;
#[doc = " This indicates that all CUDA devices are busy or unavailable at the current\n time. Devices are often busy/unavailable due to use of\n ::cudaComputeModeProhibited, ::cudaComputeModeExclusiveProcess, or when long\n running CUDA kernels have filled up the GPU and are blocking new work\n from starting. They can also be unavailable due to memory constraints\n on a device that already has active CUDA work being performed."]
pub const cudaError_cudaErrorDevicesUnavailable: cudaError = 46;
#[doc = " This indicates that the current context is not compatible with this\n the CUDA Runtime. This can only occur if you are using CUDA\n Runtime/Driver interoperability and have created an existing Driver\n context using the driver API. The Driver context may be incompatible\n either because the Driver context was created using an older version\n of the API, because the Runtime API call expects a primary driver\n context and the Driver context is not primary, or because the Driver\n context has been destroyed. Please see \\ref CUDART_DRIVER \"Interactions\n with the CUDA Driver API\" for more information."]
pub const cudaError_cudaErrorIncompatibleDriverContext: cudaError = 49;
#[doc = " The device function being invoked (usually via ::cudaLaunchKernel()) was not\n previously configured via the ::cudaConfigureCall() function."]
pub const cudaError_cudaErrorMissingConfiguration: cudaError = 52;
#[doc = " This indicated that a previous kernel launch failed. This was previously\n used for device emulation of kernel launches.\n \\deprecated\n This error return is deprecated as of CUDA 3.1. Device emulation mode was\n removed with the CUDA 3.1 release."]
pub const cudaError_cudaErrorPriorLaunchFailure: cudaError = 53;
#[doc = " This error indicates that a device runtime grid launch did not occur\n because the depth of the child grid would exceed the maximum supported\n number of nested grid launches."]
pub const cudaError_cudaErrorLaunchMaxDepthExceeded: cudaError = 65;
#[doc = " This error indicates that a grid launch did not occur because the kernel\n uses file-scoped textures which are unsupported by the device runtime.\n Kernels launched via the device runtime only support textures created with\n the Texture Object API's."]
pub const cudaError_cudaErrorLaunchFileScopedTex: cudaError = 66;
#[doc = " This error indicates that a grid launch did not occur because the kernel\n uses file-scoped surfaces which are unsupported by the device runtime.\n Kernels launched via the device runtime only support surfaces created with\n the Surface Object API's."]
pub const cudaError_cudaErrorLaunchFileScopedSurf: cudaError = 67;
#[doc = " This error indicates that a call to ::cudaDeviceSynchronize made from\n the device runtime failed because the call was made at grid depth greater\n than than either the default (2 levels of grids) or user specified device\n limit ::cudaLimitDevRuntimeSyncDepth. To be able to synchronize on\n launched grids at a greater depth successfully, the maximum nested\n depth at which ::cudaDeviceSynchronize will be called must be specified\n with the ::cudaLimitDevRuntimeSyncDepth limit to the ::cudaDeviceSetLimit\n api before the host-side launch of a kernel using the device runtime.\n Keep in mind that additional levels of sync depth require the runtime\n to reserve large amounts of device memory that cannot be used for\n user allocations. Note that ::cudaDeviceSynchronize made from device\n runtime is only supported on devices of compute capability < 9.0."]
pub const cudaError_cudaErrorSyncDepthExceeded: cudaError = 68;
#[doc = " This error indicates that a device runtime grid launch failed because\n the launch would exceed the limit ::cudaLimitDevRuntimePendingLaunchCount.\n For this launch to proceed successfully, ::cudaDeviceSetLimit must be\n called to set the ::cudaLimitDevRuntimePendingLaunchCount to be higher\n than the upper bound of outstanding launches that can be issued to the\n device runtime. Keep in mind that raising the limit of pending device\n runtime launches will require the runtime to reserve device memory that\n cannot be used for user allocations."]
pub const cudaError_cudaErrorLaunchPendingCountExceeded: cudaError = 69;
#[doc = " The requested device function does not exist or is not compiled for the\n proper device architecture."]
pub const cudaError_cudaErrorInvalidDeviceFunction: cudaError = 98;
#[doc = " This indicates that no CUDA-capable devices were detected by the installed\n CUDA driver."]
pub const cudaError_cudaErrorNoDevice: cudaError = 100;
#[doc = " This indicates that the device ordinal supplied by the user does not\n correspond to a valid CUDA device or that the action requested is\n invalid for the specified device."]
pub const cudaError_cudaErrorInvalidDevice: cudaError = 101;
#[doc = " This indicates that the device doesn't have a valid Grid License."]
pub const cudaError_cudaErrorDeviceNotLicensed: cudaError = 102;
#[doc = " By default, the CUDA runtime may perform a minimal set of self-tests,\n as well as CUDA driver tests, to establish the validity of both.\n Introduced in CUDA 11.2, this error return indicates that at least one\n of these tests has failed and the validity of either the runtime\n or the driver could not be established."]
pub const cudaError_cudaErrorSoftwareValidityNotEstablished: cudaError = 103;
#[doc = " This indicates an internal startup failure in the CUDA runtime."]
pub const cudaError_cudaErrorStartupFailure: cudaError = 127;
#[doc = " This indicates that the device kernel image is invalid."]
pub const cudaError_cudaErrorInvalidKernelImage: cudaError = 200;
#[doc = " This most frequently indicates that there is no context bound to the\n current thread. This can also be returned if the context passed to an\n API call is not a valid handle (such as a context that has had\n ::cuCtxDestroy() invoked on it). This can also be returned if a user\n mixes different API versions (i.e. 3010 context with 3020 API calls).\n See ::cuCtxGetApiVersion() for more details."]
pub const cudaError_cudaErrorDeviceUninitialized: cudaError = 201;
#[doc = " This indicates that the buffer object could not be mapped."]
pub const cudaError_cudaErrorMapBufferObjectFailed: cudaError = 205;
#[doc = " This indicates that the buffer object could not be unmapped."]
pub const cudaError_cudaErrorUnmapBufferObjectFailed: cudaError = 206;
#[doc = " This indicates that the specified array is currently mapped and thus\n cannot be destroyed."]
pub const cudaError_cudaErrorArrayIsMapped: cudaError = 207;
#[doc = " This indicates that the resource is already mapped."]
pub const cudaError_cudaErrorAlreadyMapped: cudaError = 208;
#[doc = " This indicates that there is no kernel image available that is suitable\n for the device. This can occur when a user specifies code generation\n options for a particular CUDA source file that do not include the\n corresponding device configuration."]
pub const cudaError_cudaErrorNoKernelImageForDevice: cudaError = 209;
#[doc = " This indicates that a resource has already been acquired."]
pub const cudaError_cudaErrorAlreadyAcquired: cudaError = 210;
#[doc = " This indicates that a resource is not mapped."]
pub const cudaError_cudaErrorNotMapped: cudaError = 211;
#[doc = " This indicates that a mapped resource is not available for access as an\n array."]
pub const cudaError_cudaErrorNotMappedAsArray: cudaError = 212;
#[doc = " This indicates that a mapped resource is not available for access as a\n pointer."]
pub const cudaError_cudaErrorNotMappedAsPointer: cudaError = 213;
#[doc = " This indicates that an uncorrectable ECC error was detected during\n execution."]
pub const cudaError_cudaErrorECCUncorrectable: cudaError = 214;
#[doc = " This indicates that the ::cudaLimit passed to the API call is not\n supported by the active device."]
pub const cudaError_cudaErrorUnsupportedLimit: cudaError = 215;
#[doc = " This indicates that a call tried to access an exclusive-thread device that\n is already in use by a different thread."]
pub const cudaError_cudaErrorDeviceAlreadyInUse: cudaError = 216;
#[doc = " This error indicates that P2P access is not supported across the given\n devices."]
pub const cudaError_cudaErrorPeerAccessUnsupported: cudaError = 217;
#[doc = " A PTX compilation failed. The runtime may fall back to compiling PTX if\n an application does not contain a suitable binary for the current device."]
pub const cudaError_cudaErrorInvalidPtx: cudaError = 218;
#[doc = " This indicates an error with the OpenGL or DirectX context."]
pub const cudaError_cudaErrorInvalidGraphicsContext: cudaError = 219;
#[doc = " This indicates that an uncorrectable NVLink error was detected during the\n execution."]
pub const cudaError_cudaErrorNvlinkUncorrectable: cudaError = 220;
#[doc = " This indicates that the PTX JIT compiler library was not found. The JIT Compiler\n library is used for PTX compilation. The runtime may fall back to compiling PTX\n if an application does not contain a suitable binary for the current device."]
pub const cudaError_cudaErrorJitCompilerNotFound: cudaError = 221;
#[doc = " This indicates that the provided PTX was compiled with an unsupported toolchain.\n The most common reason for this, is the PTX was generated by a compiler newer\n than what is supported by the CUDA driver and PTX JIT compiler."]
pub const cudaError_cudaErrorUnsupportedPtxVersion: cudaError = 222;
#[doc = " This indicates that the JIT compilation was disabled. The JIT compilation compiles\n PTX. The runtime may fall back to compiling PTX if an application does not contain\n a suitable binary for the current device."]
pub const cudaError_cudaErrorJitCompilationDisabled: cudaError = 223;
#[doc = " This indicates that the provided execution affinity is not supported by the device."]
pub const cudaError_cudaErrorUnsupportedExecAffinity: cudaError = 224;
#[doc = " This indicates that the code to be compiled by the PTX JIT contains\n unsupported call to cudaDeviceSynchronize."]
pub const cudaError_cudaErrorUnsupportedDevSideSync: cudaError = 225;
#[doc = " This indicates that the device kernel source is invalid."]
pub const cudaError_cudaErrorInvalidSource: cudaError = 300;
#[doc = " This indicates that the file specified was not found."]
pub const cudaError_cudaErrorFileNotFound: cudaError = 301;
#[doc = " This indicates that a link to a shared object failed to resolve."]
pub const cudaError_cudaErrorSharedObjectSymbolNotFound: cudaError = 302;
#[doc = " This indicates that initialization of a shared object failed."]
pub const cudaError_cudaErrorSharedObjectInitFailed: cudaError = 303;
#[doc = " This error indicates that an OS call failed."]
pub const cudaError_cudaErrorOperatingSystem: cudaError = 304;
#[doc = " This indicates that a resource handle passed to the API call was not\n valid. Resource handles are opaque types like ::cudaStream_t and\n ::cudaEvent_t."]
pub const cudaError_cudaErrorInvalidResourceHandle: cudaError = 400;
#[doc = " This indicates that a resource required by the API call is not in a\n valid state to perform the requested operation."]
pub const cudaError_cudaErrorIllegalState: cudaError = 401;
#[doc = " This indicates that a named symbol was not found. Examples of symbols\n are global/constant variable names, driver function names, texture names,\n and surface names."]
pub const cudaError_cudaErrorSymbolNotFound: cudaError = 500;
#[doc = " This indicates that asynchronous operations issued previously have not\n completed yet. This result is not actually an error, but must be indicated\n differently than ::cudaSuccess (which indicates completion). Calls that\n may return this value include ::cudaEventQuery() and ::cudaStreamQuery()."]
pub const cudaError_cudaErrorNotReady: cudaError = 600;
#[doc = " The device encountered a load or store instruction on an invalid memory address.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_cudaErrorIllegalAddress: cudaError = 700;
#[doc = " This indicates that a launch did not occur because it did not have\n appropriate resources. Although this error is similar to\n ::cudaErrorInvalidConfiguration, this error usually indicates that the\n user has attempted to pass too many arguments to the device kernel, or the\n kernel launch specifies too many threads for the kernel's register count."]
pub const cudaError_cudaErrorLaunchOutOfResources: cudaError = 701;
#[doc = " This indicates that the device kernel took too long to execute. This can\n only occur if timeouts are enabled - see the device property\n \\ref ::cudaDeviceProp::kernelExecTimeoutEnabled \"kernelExecTimeoutEnabled\"\n for more information.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_cudaErrorLaunchTimeout: cudaError = 702;
#[doc = " This error indicates a kernel launch that uses an incompatible texturing\n mode."]
pub const cudaError_cudaErrorLaunchIncompatibleTexturing: cudaError = 703;
#[doc = " This error indicates that a call to ::cudaDeviceEnablePeerAccess() is\n trying to re-enable peer addressing on from a context which has already\n had peer addressing enabled."]
pub const cudaError_cudaErrorPeerAccessAlreadyEnabled: cudaError = 704;
#[doc = " This error indicates that ::cudaDeviceDisablePeerAccess() is trying to\n disable peer addressing which has not been enabled yet via\n ::cudaDeviceEnablePeerAccess()."]
pub const cudaError_cudaErrorPeerAccessNotEnabled: cudaError = 705;
#[doc = " This indicates that the user has called ::cudaSetValidDevices(),\n ::cudaSetDeviceFlags(), ::cudaD3D9SetDirect3DDevice(),\n ::cudaD3D10SetDirect3DDevice, ::cudaD3D11SetDirect3DDevice(), or\n ::cudaVDPAUSetVDPAUDevice() after initializing the CUDA runtime by\n calling non-device management operations (allocating memory and\n launching kernels are examples of non-device management operations).\n This error can also be returned if using runtime/driver\n interoperability and there is an existing ::CUcontext active on the\n host thread."]
pub const cudaError_cudaErrorSetOnActiveProcess: cudaError = 708;
#[doc = " This error indicates that the context current to the calling thread\n has been destroyed using ::cuCtxDestroy, or is a primary context which\n has not yet been initialized."]
pub const cudaError_cudaErrorContextIsDestroyed: cudaError = 709;
#[doc = " An assert triggered in device code during kernel execution. The device\n cannot be used again. All existing allocations are invalid. To continue\n using CUDA, the process must be terminated and relaunched."]
pub const cudaError_cudaErrorAssert: cudaError = 710;
#[doc = " This error indicates that the hardware resources required to enable\n peer access have been exhausted for one or more of the devices\n passed to ::cudaEnablePeerAccess()."]
pub const cudaError_cudaErrorTooManyPeers: cudaError = 711;
#[doc = " This error indicates that the memory range passed to ::cudaHostRegister()\n has already been registered."]
pub const cudaError_cudaErrorHostMemoryAlreadyRegistered: cudaError = 712;
#[doc = " This error indicates that the pointer passed to ::cudaHostUnregister()\n does not correspond to any currently registered memory region."]
pub const cudaError_cudaErrorHostMemoryNotRegistered: cudaError = 713;
#[doc = " Device encountered an error in the call stack during kernel execution,\n possibly due to stack corruption or exceeding the stack size limit.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_cudaErrorHardwareStackError: cudaError = 714;
#[doc = " The device encountered an illegal instruction during kernel execution\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_cudaErrorIllegalInstruction: cudaError = 715;
#[doc = " The device encountered a load or store instruction\n on a memory address which is not aligned.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_cudaErrorMisalignedAddress: cudaError = 716;
#[doc = " While executing a kernel, the device encountered an instruction\n which can only operate on memory locations in certain address spaces\n (global, shared, or local), but was supplied a memory address not\n belonging to an allowed address space.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_cudaErrorInvalidAddressSpace: cudaError = 717;
#[doc = " The device encountered an invalid program counter.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_cudaErrorInvalidPc: cudaError = 718;
#[doc = " An exception occurred on the device while executing a kernel. Common\n causes include dereferencing an invalid device pointer and accessing\n out of bounds shared memory. Less common cases can be system specific - more\n information about these cases can be found in the system specific user guide.\n This leaves the process in an inconsistent state and any further CUDA work\n will return the same error. To continue using CUDA, the process must be terminated\n and relaunched."]
pub const cudaError_cudaErrorLaunchFailure: cudaError = 719;
#[doc = " This error indicates that the number of blocks launched per grid for a kernel that was\n launched via either ::cudaLaunchCooperativeKernel or ::cudaLaunchCooperativeKernelMultiDevice\n exceeds the maximum number of blocks as allowed by ::cudaOccupancyMaxActiveBlocksPerMultiprocessor\n or ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags times the number of multiprocessors\n as specified by the device attribute ::cudaDevAttrMultiProcessorCount."]
pub const cudaError_cudaErrorCooperativeLaunchTooLarge: cudaError = 720;
#[doc = " This error indicates the attempted operation is not permitted."]
pub const cudaError_cudaErrorNotPermitted: cudaError = 800;
#[doc = " This error indicates the attempted operation is not supported\n on the current system or device."]
pub const cudaError_cudaErrorNotSupported: cudaError = 801;
#[doc = " This error indicates that the system is not yet ready to start any CUDA\n work.  To continue using CUDA, verify the system configuration is in a\n valid state and all required driver daemons are actively running.\n More information about this error can be found in the system specific\n user guide."]
pub const cudaError_cudaErrorSystemNotReady: cudaError = 802;
#[doc = " This error indicates that there is a mismatch between the versions of\n the display driver and the CUDA driver. Refer to the compatibility documentation\n for supported versions."]
pub const cudaError_cudaErrorSystemDriverMismatch: cudaError = 803;
#[doc = " This error indicates that the system was upgraded to run with forward compatibility\n but the visible hardware detected by CUDA does not support this configuration.\n Refer to the compatibility documentation for the supported hardware matrix or ensure\n that only supported hardware is visible during initialization via the CUDA_VISIBLE_DEVICES\n environment variable."]
pub const cudaError_cudaErrorCompatNotSupportedOnDevice: cudaError = 804;
#[doc = " This error indicates that the MPS client failed to connect to the MPS control daemon or the MPS server."]
pub const cudaError_cudaErrorMpsConnectionFailed: cudaError = 805;
#[doc = " This error indicates that the remote procedural call between the MPS server and the MPS client failed."]
pub const cudaError_cudaErrorMpsRpcFailure: cudaError = 806;
#[doc = " This error indicates that the MPS server is not ready to accept new MPS client requests.\n This error can be returned when the MPS server is in the process of recovering from a fatal failure."]
pub const cudaError_cudaErrorMpsServerNotReady: cudaError = 807;
#[doc = " This error indicates that the hardware resources required to create MPS client have been exhausted."]
pub const cudaError_cudaErrorMpsMaxClientsReached: cudaError = 808;
#[doc = " This error indicates the the hardware resources required to device connections have been exhausted."]
pub const cudaError_cudaErrorMpsMaxConnectionsReached: cudaError = 809;
#[doc = " This error indicates that the MPS client has been terminated by the server. To continue using CUDA, the process must be terminated and relaunched."]
pub const cudaError_cudaErrorMpsClientTerminated: cudaError = 810;
#[doc = " This error indicates, that the program is using CUDA Dynamic Parallelism, but the current configuration, like MPS, does not support it."]
pub const cudaError_cudaErrorCdpNotSupported: cudaError = 811;
#[doc = " This error indicates, that the program contains an unsupported interaction between different versions of CUDA Dynamic Parallelism."]
pub const cudaError_cudaErrorCdpVersionMismatch: cudaError = 812;
#[doc = " The operation is not permitted when the stream is capturing."]
pub const cudaError_cudaErrorStreamCaptureUnsupported: cudaError = 900;
#[doc = " The current capture sequence on the stream has been invalidated due to\n a previous error."]
pub const cudaError_cudaErrorStreamCaptureInvalidated: cudaError = 901;
#[doc = " The operation would have resulted in a merge of two independent capture\n sequences."]
pub const cudaError_cudaErrorStreamCaptureMerge: cudaError = 902;
#[doc = " The capture was not initiated in this stream."]
pub const cudaError_cudaErrorStreamCaptureUnmatched: cudaError = 903;
#[doc = " The capture sequence contains a fork that was not joined to the primary\n stream."]
pub const cudaError_cudaErrorStreamCaptureUnjoined: cudaError = 904;
#[doc = " A dependency would have been created which crosses the capture sequence\n boundary. Only implicit in-stream ordering dependencies are allowed to\n cross the boundary."]
pub const cudaError_cudaErrorStreamCaptureIsolation: cudaError = 905;
#[doc = " The operation would have resulted in a disallowed implicit dependency on\n a current capture sequence from cudaStreamLegacy."]
pub const cudaError_cudaErrorStreamCaptureImplicit: cudaError = 906;
#[doc = " The operation is not permitted on an event which was last recorded in a\n capturing stream."]
pub const cudaError_cudaErrorCapturedEvent: cudaError = 907;
#[doc = " A stream capture sequence not initiated with the ::cudaStreamCaptureModeRelaxed\n argument to ::cudaStreamBeginCapture was passed to ::cudaStreamEndCapture in a\n different thread."]
pub const cudaError_cudaErrorStreamCaptureWrongThread: cudaError = 908;
#[doc = " This indicates that the wait operation has timed out."]
pub const cudaError_cudaErrorTimeout: cudaError = 909;
#[doc = " This error indicates that the graph update was not performed because it included\n changes which violated constraints specific to instantiated graph update."]
pub const cudaError_cudaErrorGraphExecUpdateFailure: cudaError = 910;
#[doc = " This indicates that an async error has occurred in a device outside of CUDA.\n If CUDA was waiting for an external device's signal before consuming shared data,\n the external device signaled an error indicating that the data is not valid for\n consumption. This leaves the process in an inconsistent state and any further CUDA\n work will return the same error. To continue using CUDA, the process must be\n terminated and relaunched."]
pub const cudaError_cudaErrorExternalDevice: cudaError = 911;
#[doc = " This indicates that a kernel launch error has occurred due to cluster\n misconfiguration."]
pub const cudaError_cudaErrorInvalidClusterSize: cudaError = 912;
#[doc = " This indicates that an unknown internal error has occurred."]
pub const cudaError_cudaErrorUnknown: cudaError = 999;
#[doc = " Any unhandled CUDA driver error is added to this value and returned via\n the runtime. Production releases of CUDA should not return such errors.\n \\deprecated\n This error return is deprecated as of CUDA 4.1."]
pub const cudaError_cudaErrorApiFailureBase: cudaError = 10000;
#[doc = " CUDA error types"]
pub type cudaError = ::std::os::raw::c_uint;
#[doc = " CUDA Error types"]
pub use self::cudaError as cudaError_t;
#[doc = " CUDA event types"]
pub type cudaEvent_t = *mut CUevent_st;
#[doc = " CURAND XORWOW state"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct curandStateXORWOW {
    pub d: ::std::os::raw::c_uint,
    pub v: [::std::os::raw::c_uint; 5usize],
    pub boxmuller_flag: ::std::os::raw::c_int,
    pub boxmuller_flag_double: ::std::os::raw::c_int,
    pub boxmuller_extra: f32,
    pub boxmuller_extra_double: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of curandStateXORWOW"][::std::mem::size_of::<curandStateXORWOW>() - 48usize];
    ["Alignment of curandStateXORWOW"][::std::mem::align_of::<curandStateXORWOW>() - 8usize];
    ["Offset of field: curandStateXORWOW::d"]
        [::std::mem::offset_of!(curandStateXORWOW, d) - 0usize];
    ["Offset of field: curandStateXORWOW::v"]
        [::std::mem::offset_of!(curandStateXORWOW, v) - 4usize];
    ["Offset of field: curandStateXORWOW::boxmuller_flag"]
        [::std::mem::offset_of!(curandStateXORWOW, boxmuller_flag) - 24usize];
    ["Offset of field: curandStateXORWOW::boxmuller_flag_double"]
        [::std::mem::offset_of!(curandStateXORWOW, boxmuller_flag_double) - 28usize];
    ["Offset of field: curandStateXORWOW::boxmuller_extra"]
        [::std::mem::offset_of!(curandStateXORWOW, boxmuller_extra) - 32usize];
    ["Offset of field: curandStateXORWOW::boxmuller_extra_double"]
        [::std::mem::offset_of!(curandStateXORWOW, boxmuller_extra_double) - 40usize];
};
#[doc = " CURAND XORWOW state"]
pub type curandState = curandStateXORWOW;
pub type cufftHandle = ::std::os::raw::c_int;
pub const cublasStatus_t_CUBLAS_STATUS_SUCCESS: cublasStatus_t = 0;
pub const cublasStatus_t_CUBLAS_STATUS_NOT_INITIALIZED: cublasStatus_t = 1;
pub const cublasStatus_t_CUBLAS_STATUS_ALLOC_FAILED: cublasStatus_t = 3;
pub const cublasStatus_t_CUBLAS_STATUS_INVALID_VALUE: cublasStatus_t = 7;
pub const cublasStatus_t_CUBLAS_STATUS_ARCH_MISMATCH: cublasStatus_t = 8;
pub const cublasStatus_t_CUBLAS_STATUS_MAPPING_ERROR: cublasStatus_t = 11;
pub const cublasStatus_t_CUBLAS_STATUS_EXECUTION_FAILED: cublasStatus_t = 13;
pub const cublasStatus_t_CUBLAS_STATUS_INTERNAL_ERROR: cublasStatus_t = 14;
pub const cublasStatus_t_CUBLAS_STATUS_NOT_SUPPORTED: cublasStatus_t = 15;
pub const cublasStatus_t_CUBLAS_STATUS_LICENSE_ERROR: cublasStatus_t = 16;
pub type cublasStatus_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cublasContext {
    _unused: [u8; 0],
}
pub type cublasHandle_t = *mut cublasContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cusparseContext {
    _unused: [u8; 0],
}
pub type cusparseHandle_t = *mut cusparseContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cusparseMatDescr {
    _unused: [u8; 0],
}
pub type cusparseMatDescr_t = *mut cusparseMatDescr;
pub const cusparseStatus_t_CUSPARSE_STATUS_SUCCESS: cusparseStatus_t = 0;
pub const cusparseStatus_t_CUSPARSE_STATUS_NOT_INITIALIZED: cusparseStatus_t = 1;
pub const cusparseStatus_t_CUSPARSE_STATUS_ALLOC_FAILED: cusparseStatus_t = 2;
pub const cusparseStatus_t_CUSPARSE_STATUS_INVALID_VALUE: cusparseStatus_t = 3;
pub const cusparseStatus_t_CUSPARSE_STATUS_ARCH_MISMATCH: cusparseStatus_t = 4;
pub const cusparseStatus_t_CUSPARSE_STATUS_MAPPING_ERROR: cusparseStatus_t = 5;
pub const cusparseStatus_t_CUSPARSE_STATUS_EXECUTION_FAILED: cusparseStatus_t = 6;
pub const cusparseStatus_t_CUSPARSE_STATUS_INTERNAL_ERROR: cusparseStatus_t = 7;
pub const cusparseStatus_t_CUSPARSE_STATUS_MATRIX_TYPE_NOT_SUPPORTED: cusparseStatus_t = 8;
pub const cusparseStatus_t_CUSPARSE_STATUS_ZERO_PIVOT: cusparseStatus_t = 9;
pub const cusparseStatus_t_CUSPARSE_STATUS_NOT_SUPPORTED: cusparseStatus_t = 10;
pub const cusparseStatus_t_CUSPARSE_STATUS_INSUFFICIENT_RESOURCES: cusparseStatus_t = 11;
pub type cusparseStatus_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cusolverDnContext {
    _unused: [u8; 0],
}
pub type cusolverDnHandle_t = *mut cusolverDnContext;
extern "C" {
    #[link_name = "\u{1}_Z10set_devicei"]
    pub fn set_device(id: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_Z16get_device_countv"]
    pub fn get_device_count() -> ::std::os::raw::c_int;
}
pub type rtd = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vector {
    pub x: rtd,
    pub y: rtd,
    pub z: rtd,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of vector"][::std::mem::size_of::<vector>() - 24usize];
    ["Alignment of vector"][::std::mem::align_of::<vector>() - 8usize];
    ["Offset of field: vector::x"][::std::mem::offset_of!(vector, x) - 0usize];
    ["Offset of field: vector::y"][::std::mem::offset_of!(vector, y) - 8usize];
    ["Offset of field: vector::z"][::std::mem::offset_of!(vector, z) - 16usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN6vector4rho2Ev"]
    pub fn vector_rho2(this: *mut vector) -> rtd;
}
extern "C" {
    #[link_name = "\u{1}_ZN6vector10rho2_shiftEdd"]
    pub fn vector_rho2_shift(this: *mut vector, x0: rtd, y0: rtd) -> rtd;
}
extern "C" {
    #[link_name = "\u{1}_ZN6vector3magEv"]
    pub fn vector_mag(this: *mut vector) -> rtd;
}
extern "C" {
    #[link_name = "\u{1}_ZN6vector3magEd"]
    pub fn vector_mag1(this: *mut vector, R: rtd) -> rtd;
}
extern "C" {
    #[link_name = "\u{1}_ZN6vector5angleEv"]
    pub fn vector_angle(this: *mut vector) -> rtd;
}
extern "C" {
    #[link_name = "\u{1}_ZN6vector4normEv"]
    pub fn vector_norm(this: *mut vector) -> rtd;
}
extern "C" {
    #[link_name = "\u{1}_ZN6vector3dotEPS_"]
    pub fn vector_dot(this: *mut vector, u: *mut vector) -> rtd;
}
extern "C" {
    #[link_name = "\u{1}_ZN6vector4unitEv"]
    pub fn vector_unit(this: *mut vector);
}
extern "C" {
    #[link_name = "\u{1}_ZN6vector10left_crossEPS_S0_"]
    pub fn vector_left_cross(this: *mut vector, w: *mut vector, u: *mut vector);
}
extern "C" {
    #[link_name = "\u{1}_ZN6vector11right_crossEPS_S0_"]
    pub fn vector_right_cross(this: *mut vector, w: *mut vector, u: *mut vector);
}
impl vector {
    #[inline]
    pub unsafe fn rho2(&mut self) -> rtd {
        vector_rho2(self)
    }
    #[inline]
    pub unsafe fn rho2_shift(&mut self, x0: rtd, y0: rtd) -> rtd {
        vector_rho2_shift(self, x0, y0)
    }
    #[inline]
    pub unsafe fn mag(&mut self) -> rtd {
        vector_mag(self)
    }
    #[inline]
    pub unsafe fn mag1(&mut self, R: rtd) -> rtd {
        vector_mag1(self, R)
    }
    #[inline]
    pub unsafe fn angle(&mut self) -> rtd {
        vector_angle(self)
    }
    #[inline]
    pub unsafe fn norm(&mut self) -> rtd {
        vector_norm(self)
    }
    #[inline]
    pub unsafe fn dot(&mut self, u: *mut vector) -> rtd {
        vector_dot(self, u)
    }
    #[inline]
    pub unsafe fn unit(&mut self) {
        vector_unit(self)
    }
    #[inline]
    pub unsafe fn left_cross(&mut self, w: *mut vector, u: *mut vector) {
        vector_left_cross(self, w, u)
    }
    #[inline]
    pub unsafe fn right_cross(&mut self, w: *mut vector, u: *mut vector) {
        vector_right_cross(self, w, u)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stopwatch {
    pub elapsedTime: f32,
    pub start: cudaEvent_t,
    pub stop: cudaEvent_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of stopwatch"][::std::mem::size_of::<stopwatch>() - 24usize];
    ["Alignment of stopwatch"][::std::mem::align_of::<stopwatch>() - 8usize];
    ["Offset of field: stopwatch::elapsedTime"]
        [::std::mem::offset_of!(stopwatch, elapsedTime) - 0usize];
    ["Offset of field: stopwatch::start"][::std::mem::offset_of!(stopwatch, start) - 8usize];
    ["Offset of field: stopwatch::stop"][::std::mem::offset_of!(stopwatch, stop) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mask {
    pub m: *mut ::std::os::raw::c_char,
    pub f: *mut f32,
    pub idx: *mut ::std::os::raw::c_int,
    pub size_px: [::std::os::raw::c_int; 2usize],
    pub nel: ::std::os::raw::c_int,
    pub nnz: f32,
    pub size_m: [f32; 2usize],
    pub area: f32,
    pub delta: [f32; 2usize],
    pub handle: cublasHandle_t,
    pub d__piston_mask: *mut ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mask"][::std::mem::size_of::<mask>() - 80usize];
    ["Alignment of mask"][::std::mem::align_of::<mask>() - 8usize];
    ["Offset of field: mask::m"][::std::mem::offset_of!(mask, m) - 0usize];
    ["Offset of field: mask::f"][::std::mem::offset_of!(mask, f) - 8usize];
    ["Offset of field: mask::idx"][::std::mem::offset_of!(mask, idx) - 16usize];
    ["Offset of field: mask::size_px"][::std::mem::offset_of!(mask, size_px) - 24usize];
    ["Offset of field: mask::nel"][::std::mem::offset_of!(mask, nel) - 32usize];
    ["Offset of field: mask::nnz"][::std::mem::offset_of!(mask, nnz) - 36usize];
    ["Offset of field: mask::size_m"][::std::mem::offset_of!(mask, size_m) - 40usize];
    ["Offset of field: mask::area"][::std::mem::offset_of!(mask, area) - 48usize];
    ["Offset of field: mask::delta"][::std::mem::offset_of!(mask, delta) - 52usize];
    ["Offset of field: mask::handle"][::std::mem::offset_of!(mask, handle) - 64usize];
    ["Offset of field: mask::d__piston_mask"]
        [::std::mem::offset_of!(mask, d__piston_mask) - 72usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN4mask5setupEi"]
    pub fn mask_setup(this: *mut mask, n: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN4mask5setupEif"]
    pub fn mask_setup1(this: *mut mask, n: ::std::os::raw::c_int, L: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN4mask5setupEifiii"]
    pub fn mask_setup2(
        this: *mut mask,
        n: ::std::os::raw::c_int,
        L: f32,
        i_s: ::std::os::raw::c_int,
        j_s: ::std::os::raw::c_int,
        n_out: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4mask5setupEfffffffi"]
    pub fn mask_setup3(
        this: *mut mask,
        n: f32,
        L: f32,
        i_0: f32,
        j_0: f32,
        theta: f32,
        i_s: f32,
        j_s: f32,
        n_out: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4mask14setup_circularEi"]
    pub fn mask_setup_circular(this: *mut mask, n: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN4mask14setup_circularEif"]
    pub fn mask_setup_circular1(this: *mut mask, n: ::std::os::raw::c_int, D: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN4mask14setup_circularEiff"]
    pub fn mask_setup_circular2(this: *mut mask, n: ::std::os::raw::c_int, D: f32, scale: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN4mask9setup_GMTEif"]
    pub fn mask_setup_GMT(this: *mut mask, n: ::std::os::raw::c_int, S: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN4mask10set_filterEv"]
    pub fn mask_set_filter(this: *mut mask);
}
extern "C" {
    #[link_name = "\u{1}_ZN4mask16set_filter_quietEv"]
    pub fn mask_set_filter_quiet(this: *mut mask);
}
extern "C" {
    #[link_name = "\u{1}_ZN4mask9set_indexEv"]
    pub fn mask_set_index(this: *mut mask);
}
extern "C" {
    #[link_name = "\u{1}_ZN4mask14set_gmt_pistonEPfS0_"]
    pub fn mask_set_gmt_piston(this: *mut mask, phase: *mut f32, d__p: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN4mask5alterEPf"]
    pub fn mask_alter(this: *mut mask, filter: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN4mask3addEPS_"]
    pub fn mask_add(this: *mut mask, other: *mut mask);
}
extern "C" {
    #[link_name = "\u{1}_ZN4mask3addEPci"]
    pub fn mask_add1(
        this: *mut mask,
        other: *mut ::std::os::raw::c_char,
        other_nel: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4mask3addEPS_i"]
    pub fn mask_add2(this: *mut mask, other: *mut mask, offset: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN4mask3addEPcii"]
    pub fn mask_add3(
        this: *mut mask,
        other: *mut ::std::os::raw::c_char,
        other_nel: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4mask5resetEv"]
    pub fn mask_reset(this: *mut mask);
}
extern "C" {
    #[link_name = "\u{1}_ZN4mask7cleanupEv"]
    pub fn mask_cleanup(this: *mut mask);
}
impl mask {
    #[inline]
    pub unsafe fn setup(&mut self, n: ::std::os::raw::c_int) {
        mask_setup(self, n)
    }
    #[inline]
    pub unsafe fn setup1(&mut self, n: ::std::os::raw::c_int, L: f32) {
        mask_setup1(self, n, L)
    }
    #[inline]
    pub unsafe fn setup2(
        &mut self,
        n: ::std::os::raw::c_int,
        L: f32,
        i_s: ::std::os::raw::c_int,
        j_s: ::std::os::raw::c_int,
        n_out: ::std::os::raw::c_int,
    ) {
        mask_setup2(self, n, L, i_s, j_s, n_out)
    }
    #[inline]
    pub unsafe fn setup3(
        &mut self,
        n: f32,
        L: f32,
        i_0: f32,
        j_0: f32,
        theta: f32,
        i_s: f32,
        j_s: f32,
        n_out: ::std::os::raw::c_int,
    ) {
        mask_setup3(self, n, L, i_0, j_0, theta, i_s, j_s, n_out)
    }
    #[inline]
    pub unsafe fn setup_circular(&mut self, n: ::std::os::raw::c_int) {
        mask_setup_circular(self, n)
    }
    #[inline]
    pub unsafe fn setup_circular1(&mut self, n: ::std::os::raw::c_int, D: f32) {
        mask_setup_circular1(self, n, D)
    }
    #[inline]
    pub unsafe fn setup_circular2(&mut self, n: ::std::os::raw::c_int, D: f32, scale: f32) {
        mask_setup_circular2(self, n, D, scale)
    }
    #[inline]
    pub unsafe fn setup_GMT(&mut self, n: ::std::os::raw::c_int, S: f32) {
        mask_setup_GMT(self, n, S)
    }
    #[inline]
    pub unsafe fn set_filter(&mut self) {
        mask_set_filter(self)
    }
    #[inline]
    pub unsafe fn set_filter_quiet(&mut self) {
        mask_set_filter_quiet(self)
    }
    #[inline]
    pub unsafe fn set_index(&mut self) {
        mask_set_index(self)
    }
    #[inline]
    pub unsafe fn set_gmt_piston(&mut self, phase: *mut f32, d__p: *mut f32) {
        mask_set_gmt_piston(self, phase, d__p)
    }
    #[inline]
    pub unsafe fn alter(&mut self, filter: *mut f32) {
        mask_alter(self, filter)
    }
    #[inline]
    pub unsafe fn add(&mut self, other: *mut mask) {
        mask_add(self, other)
    }
    #[inline]
    pub unsafe fn add1(
        &mut self,
        other: *mut ::std::os::raw::c_char,
        other_nel: ::std::os::raw::c_int,
    ) {
        mask_add1(self, other, other_nel)
    }
    #[inline]
    pub unsafe fn add2(&mut self, other: *mut mask, offset: ::std::os::raw::c_int) {
        mask_add2(self, other, offset)
    }
    #[inline]
    pub unsafe fn add3(
        &mut self,
        other: *mut ::std::os::raw::c_char,
        other_nel: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    ) {
        mask_add3(self, other, other_nel, offset)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        mask_reset(self)
    }
    #[inline]
    pub unsafe fn cleanup(&mut self) {
        mask_cleanup(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stats {
    pub handle: cublasHandle_t,
    pub status: cublasStatus_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of stats"][::std::mem::size_of::<stats>() - 16usize];
    ["Alignment of stats"][::std::mem::align_of::<stats>() - 8usize];
    ["Offset of field: stats::handle"][::std::mem::offset_of!(stats, handle) - 0usize];
    ["Offset of field: stats::status"][::std::mem::offset_of!(stats, status) - 8usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN5stats5setupEv"]
    pub fn stats_setup(this: *mut stats);
}
extern "C" {
    #[link_name = "\u{1}_ZN5stats7cleanupEv"]
    pub fn stats_cleanup(this: *mut stats);
}
extern "C" {
    #[link_name = "\u{1}_ZN5stats4meanEPKfi"]
    pub fn stats_mean(this: *mut stats, data: *const f32, n_data: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN5stats4meanEPKfP4maski"]
    pub fn stats_mean1(
        this: *mut stats,
        data: *const f32,
        M: *mut mask,
        n_data: ::std::os::raw::c_int,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN5stats3varEPKfi"]
    pub fn stats_var(this: *mut stats, data: *const f32, n_data: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN5stats3stdEPKfi"]
    pub fn stats_std(this: *mut stats, data: *const f32, n_data: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN5stats8diff_varEPKfS1_i"]
    pub fn stats_diff_var(
        this: *mut stats,
        data_1: *const f32,
        data_2: *const f32,
        n_data: ::std::os::raw::c_int,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN5stats8diff_stdEPKfS1_i"]
    pub fn stats_diff_std(
        this: *mut stats,
        data_1: *const f32,
        data_2: *const f32,
        n_data: ::std::os::raw::c_int,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN5stats3varEPKfP4maski"]
    pub fn stats_var1(
        this: *mut stats,
        data1: *const f32,
        M: *mut mask,
        n_data: ::std::os::raw::c_int,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN5stats3stdEPKfP4maski"]
    pub fn stats_std1(
        this: *mut stats,
        data1: *const f32,
        M: *mut mask,
        n_data: ::std::os::raw::c_int,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN5stats8diff_varEPKfS1_P4maski"]
    pub fn stats_diff_var1(
        this: *mut stats,
        data1: *const f32,
        data2: *const f32,
        M: *mut mask,
        n_data: ::std::os::raw::c_int,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN5stats8diff_stdEPKfS1_P4maski"]
    pub fn stats_diff_std1(
        this: *mut stats,
        data1: *const f32,
        data2: *const f32,
        M: *mut mask,
        n_data: ::std::os::raw::c_int,
    ) -> f32;
}
impl stats {
    #[inline]
    pub unsafe fn setup(&mut self) {
        stats_setup(self)
    }
    #[inline]
    pub unsafe fn cleanup(&mut self) {
        stats_cleanup(self)
    }
    #[inline]
    pub unsafe fn mean(&mut self, data: *const f32, n_data: ::std::os::raw::c_int) -> f32 {
        stats_mean(self, data, n_data)
    }
    #[inline]
    pub unsafe fn mean1(
        &mut self,
        data: *const f32,
        M: *mut mask,
        n_data: ::std::os::raw::c_int,
    ) -> f32 {
        stats_mean1(self, data, M, n_data)
    }
    #[inline]
    pub unsafe fn var(&mut self, data: *const f32, n_data: ::std::os::raw::c_int) -> f32 {
        stats_var(self, data, n_data)
    }
    #[inline]
    pub unsafe fn std(&mut self, data: *const f32, n_data: ::std::os::raw::c_int) -> f32 {
        stats_std(self, data, n_data)
    }
    #[inline]
    pub unsafe fn diff_var(
        &mut self,
        data_1: *const f32,
        data_2: *const f32,
        n_data: ::std::os::raw::c_int,
    ) -> f32 {
        stats_diff_var(self, data_1, data_2, n_data)
    }
    #[inline]
    pub unsafe fn diff_std(
        &mut self,
        data_1: *const f32,
        data_2: *const f32,
        n_data: ::std::os::raw::c_int,
    ) -> f32 {
        stats_diff_std(self, data_1, data_2, n_data)
    }
    #[inline]
    pub unsafe fn var1(
        &mut self,
        data1: *const f32,
        M: *mut mask,
        n_data: ::std::os::raw::c_int,
    ) -> f32 {
        stats_var1(self, data1, M, n_data)
    }
    #[inline]
    pub unsafe fn std1(
        &mut self,
        data1: *const f32,
        M: *mut mask,
        n_data: ::std::os::raw::c_int,
    ) -> f32 {
        stats_std1(self, data1, M, n_data)
    }
    #[inline]
    pub unsafe fn diff_var1(
        &mut self,
        data1: *const f32,
        data2: *const f32,
        M: *mut mask,
        n_data: ::std::os::raw::c_int,
    ) -> f32 {
        stats_diff_var1(self, data1, data2, M, n_data)
    }
    #[inline]
    pub unsafe fn diff_std1(
        &mut self,
        data1: *const f32,
        data2: *const f32,
        M: *mut mask,
        n_data: ::std::os::raw::c_int,
    ) -> f32 {
        stats_diff_std1(self, data1, data2, M, n_data)
    }
}
extern "C" {
    #[link_name = "\u{1}_Z8dev2hostPfS_i"]
    pub fn dev2host(host_data: *mut f32, dev_data: *mut f32, N: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_Z12dev2host_intPiS_i"]
    pub fn dev2host_int(
        host_data: *mut ::std::os::raw::c_int,
        dev_data: *mut ::std::os::raw::c_int,
        N: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z8host2devPfS_i"]
    pub fn host2dev(dev_data: *mut f32, host_data: *mut f32, N: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_Z13host2dev_charPcS_i"]
    pub fn host2dev_char(
        dev_data: *mut ::std::os::raw::c_char,
        host_data: *mut ::std::os::raw::c_char,
        N: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpu_float {
    pub dev_data: *mut f32,
    pub host_data: *mut f32,
    pub d_tau: *mut f32,
    pub N: ::std::os::raw::c_int,
    pub nb: ::std::os::raw::c_int,
    pub S: stats,
    pub stat: cublasStatus_t,
    pub handle: cublasHandle_t,
    pub cusolverH: cusolverDnHandle_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of gpu_float"][::std::mem::size_of::<gpu_float>() - 72usize];
    ["Alignment of gpu_float"][::std::mem::align_of::<gpu_float>() - 8usize];
    ["Offset of field: gpu_float::dev_data"][::std::mem::offset_of!(gpu_float, dev_data) - 0usize];
    ["Offset of field: gpu_float::host_data"]
        [::std::mem::offset_of!(gpu_float, host_data) - 8usize];
    ["Offset of field: gpu_float::d_tau"][::std::mem::offset_of!(gpu_float, d_tau) - 16usize];
    ["Offset of field: gpu_float::N"][::std::mem::offset_of!(gpu_float, N) - 24usize];
    ["Offset of field: gpu_float::nb"][::std::mem::offset_of!(gpu_float, nb) - 28usize];
    ["Offset of field: gpu_float::S"][::std::mem::offset_of!(gpu_float, S) - 32usize];
    ["Offset of field: gpu_float::stat"][::std::mem::offset_of!(gpu_float, stat) - 48usize];
    ["Offset of field: gpu_float::handle"][::std::mem::offset_of!(gpu_float, handle) - 56usize];
    ["Offset of field: gpu_float::cusolverH"]
        [::std::mem::offset_of!(gpu_float, cusolverH) - 64usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN9gpu_float5setupEv"]
    pub fn gpu_float_setup(this: *mut gpu_float);
}
extern "C" {
    #[link_name = "\u{1}_ZN9gpu_float5setupEi"]
    pub fn gpu_float_setup1(this: *mut gpu_float, N_T: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN9gpu_float10dev_mallocEv"]
    pub fn gpu_float_dev_malloc(this: *mut gpu_float);
}
extern "C" {
    #[link_name = "\u{1}_ZN9gpu_float8free_devEv"]
    pub fn gpu_float_free_dev(this: *mut gpu_float);
}
extern "C" {
    #[link_name = "\u{1}_ZN9gpu_float8dev2hostEv"]
    pub fn gpu_float_dev2host(this: *mut gpu_float);
}
extern "C" {
    #[link_name = "\u{1}_ZN9gpu_float8host2devEv"]
    pub fn gpu_float_host2dev(this: *mut gpu_float);
}
extern "C" {
    #[link_name = "\u{1}_ZN9gpu_float5resetEv"]
    pub fn gpu_float_reset(this: *mut gpu_float);
}
extern "C" {
    #[link_name = "\u{1}_ZN9gpu_float2qrEi"]
    pub fn gpu_float_qr(this: *mut gpu_float, m: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN9gpu_float7dev2devEPS_"]
    pub fn gpu_float_dev2dev(this: *mut gpu_float, other: *mut gpu_float);
}
extern "C" {
    #[link_name = "\u{1}_ZN9gpu_float4axpyEPKS_f"]
    pub fn gpu_float_axpy(this: *mut gpu_float, x: *const gpu_float, alpha: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN9gpu_float5scaleEf"]
    pub fn gpu_float_scale(this: *mut gpu_float, alpha: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN9gpu_float2mvEPS_PKS_"]
    pub fn gpu_float_mv(this: *mut gpu_float, y: *mut gpu_float, x: *const gpu_float);
}
extern "C" {
    #[link_name = "\u{1}_ZN9gpu_float8qr_solveEPS_S0_"]
    pub fn gpu_float_qr_solve(this: *mut gpu_float, x: *mut gpu_float, b: *mut gpu_float);
}
impl gpu_float {
    #[inline]
    pub unsafe fn setup(&mut self) {
        gpu_float_setup(self)
    }
    #[inline]
    pub unsafe fn setup1(&mut self, N_T: ::std::os::raw::c_int) {
        gpu_float_setup1(self, N_T)
    }
    #[inline]
    pub unsafe fn dev_malloc(&mut self) {
        gpu_float_dev_malloc(self)
    }
    #[inline]
    pub unsafe fn free_dev(&mut self) {
        gpu_float_free_dev(self)
    }
    #[inline]
    pub unsafe fn dev2host(&mut self) {
        gpu_float_dev2host(self)
    }
    #[inline]
    pub unsafe fn host2dev(&mut self) {
        gpu_float_host2dev(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        gpu_float_reset(self)
    }
    #[inline]
    pub unsafe fn qr(&mut self, m: ::std::os::raw::c_int) {
        gpu_float_qr(self, m)
    }
    #[inline]
    pub unsafe fn dev2dev(&mut self, other: *mut gpu_float) {
        gpu_float_dev2dev(self, other)
    }
    #[inline]
    pub unsafe fn axpy(&mut self, x: *const gpu_float, alpha: f32) {
        gpu_float_axpy(self, x, alpha)
    }
    #[inline]
    pub unsafe fn scale(&mut self, alpha: f32) {
        gpu_float_scale(self, alpha)
    }
    #[inline]
    pub unsafe fn mv(&mut self, y: *mut gpu_float, x: *const gpu_float) {
        gpu_float_mv(self, y, x)
    }
    #[inline]
    pub unsafe fn qr_solve(&mut self, x: *mut gpu_float, b: *mut gpu_float) {
        gpu_float_qr_solve(self, x, b)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpu_double {
    pub dev_data: *mut f64,
    pub host_data: *mut f64,
    pub N: ::std::os::raw::c_int,
    pub nb: ::std::os::raw::c_int,
    pub S: stats,
    pub stat: cublasStatus_t,
    pub handle: cublasHandle_t,
    pub cusolverH: cusolverDnHandle_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of gpu_double"][::std::mem::size_of::<gpu_double>() - 64usize];
    ["Alignment of gpu_double"][::std::mem::align_of::<gpu_double>() - 8usize];
    ["Offset of field: gpu_double::dev_data"]
        [::std::mem::offset_of!(gpu_double, dev_data) - 0usize];
    ["Offset of field: gpu_double::host_data"]
        [::std::mem::offset_of!(gpu_double, host_data) - 8usize];
    ["Offset of field: gpu_double::N"][::std::mem::offset_of!(gpu_double, N) - 16usize];
    ["Offset of field: gpu_double::nb"][::std::mem::offset_of!(gpu_double, nb) - 20usize];
    ["Offset of field: gpu_double::S"][::std::mem::offset_of!(gpu_double, S) - 24usize];
    ["Offset of field: gpu_double::stat"][::std::mem::offset_of!(gpu_double, stat) - 40usize];
    ["Offset of field: gpu_double::handle"][::std::mem::offset_of!(gpu_double, handle) - 48usize];
    ["Offset of field: gpu_double::cusolverH"]
        [::std::mem::offset_of!(gpu_double, cusolverH) - 56usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN10gpu_double5setupEv"]
    pub fn gpu_double_setup(this: *mut gpu_double);
}
extern "C" {
    #[link_name = "\u{1}_ZN10gpu_double5setupEi"]
    pub fn gpu_double_setup1(this: *mut gpu_double, N_T: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN10gpu_double10dev_mallocEv"]
    pub fn gpu_double_dev_malloc(this: *mut gpu_double);
}
extern "C" {
    #[link_name = "\u{1}_ZN10gpu_double8free_devEv"]
    pub fn gpu_double_free_dev(this: *mut gpu_double);
}
extern "C" {
    #[link_name = "\u{1}_ZN10gpu_double8dev2hostEv"]
    pub fn gpu_double_dev2host(this: *mut gpu_double);
}
extern "C" {
    #[link_name = "\u{1}_ZN10gpu_double8host2devEv"]
    pub fn gpu_double_host2dev(this: *mut gpu_double);
}
extern "C" {
    #[link_name = "\u{1}_ZN10gpu_double5resetEv"]
    pub fn gpu_double_reset(this: *mut gpu_double);
}
extern "C" {
    #[link_name = "\u{1}_ZN10gpu_double2qrEi"]
    pub fn gpu_double_qr(this: *mut gpu_double, m: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN10gpu_double2mvEP9gpu_floatPKS0_"]
    pub fn gpu_double_mv(this: *mut gpu_double, y: *mut gpu_float, x: *const gpu_float);
}
impl gpu_double {
    #[inline]
    pub unsafe fn setup(&mut self) {
        gpu_double_setup(self)
    }
    #[inline]
    pub unsafe fn setup1(&mut self, N_T: ::std::os::raw::c_int) {
        gpu_double_setup1(self, N_T)
    }
    #[inline]
    pub unsafe fn dev_malloc(&mut self) {
        gpu_double_dev_malloc(self)
    }
    #[inline]
    pub unsafe fn free_dev(&mut self) {
        gpu_double_free_dev(self)
    }
    #[inline]
    pub unsafe fn dev2host(&mut self) {
        gpu_double_dev2host(self)
    }
    #[inline]
    pub unsafe fn host2dev(&mut self) {
        gpu_double_host2dev(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        gpu_double_reset(self)
    }
    #[inline]
    pub unsafe fn qr(&mut self, m: ::std::os::raw::c_int) {
        gpu_double_qr(self, m)
    }
    #[inline]
    pub unsafe fn mv(&mut self, y: *mut gpu_float, x: *const gpu_float) {
        gpu_double_mv(self, y, x)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpu_int {
    pub dev_data: *mut ::std::os::raw::c_int,
    pub host_data: *mut ::std::os::raw::c_int,
    pub N: ::std::os::raw::c_int,
    pub nb: ::std::os::raw::c_int,
    pub S: stats,
    pub stat: cublasStatus_t,
    pub handle: cublasHandle_t,
    pub cusolverH: cusolverDnHandle_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of gpu_int"][::std::mem::size_of::<gpu_int>() - 64usize];
    ["Alignment of gpu_int"][::std::mem::align_of::<gpu_int>() - 8usize];
    ["Offset of field: gpu_int::dev_data"][::std::mem::offset_of!(gpu_int, dev_data) - 0usize];
    ["Offset of field: gpu_int::host_data"][::std::mem::offset_of!(gpu_int, host_data) - 8usize];
    ["Offset of field: gpu_int::N"][::std::mem::offset_of!(gpu_int, N) - 16usize];
    ["Offset of field: gpu_int::nb"][::std::mem::offset_of!(gpu_int, nb) - 20usize];
    ["Offset of field: gpu_int::S"][::std::mem::offset_of!(gpu_int, S) - 24usize];
    ["Offset of field: gpu_int::stat"][::std::mem::offset_of!(gpu_int, stat) - 40usize];
    ["Offset of field: gpu_int::handle"][::std::mem::offset_of!(gpu_int, handle) - 48usize];
    ["Offset of field: gpu_int::cusolverH"][::std::mem::offset_of!(gpu_int, cusolverH) - 56usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN7gpu_int5setupEv"]
    pub fn gpu_int_setup(this: *mut gpu_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN7gpu_int5setupEi"]
    pub fn gpu_int_setup1(this: *mut gpu_int, N_T: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN7gpu_int10dev_mallocEv"]
    pub fn gpu_int_dev_malloc(this: *mut gpu_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN7gpu_int8free_devEv"]
    pub fn gpu_int_free_dev(this: *mut gpu_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN7gpu_int8dev2hostEv"]
    pub fn gpu_int_dev2host(this: *mut gpu_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN7gpu_int8host2devEv"]
    pub fn gpu_int_host2dev(this: *mut gpu_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN7gpu_int5resetEv"]
    pub fn gpu_int_reset(this: *mut gpu_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN7gpu_int2qrEi"]
    pub fn gpu_int_qr(this: *mut gpu_int, m: ::std::os::raw::c_int);
}
impl gpu_int {
    #[inline]
    pub unsafe fn setup(&mut self) {
        gpu_int_setup(self)
    }
    #[inline]
    pub unsafe fn setup1(&mut self, N_T: ::std::os::raw::c_int) {
        gpu_int_setup1(self, N_T)
    }
    #[inline]
    pub unsafe fn dev_malloc(&mut self) {
        gpu_int_dev_malloc(self)
    }
    #[inline]
    pub unsafe fn free_dev(&mut self) {
        gpu_int_free_dev(self)
    }
    #[inline]
    pub unsafe fn dev2host(&mut self) {
        gpu_int_dev2host(self)
    }
    #[inline]
    pub unsafe fn host2dev(&mut self) {
        gpu_int_host2dev(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        gpu_int_reset(self)
    }
    #[inline]
    pub unsafe fn qr(&mut self, m: ::std::os::raw::c_int) {
        gpu_int_qr(self, m)
    }
}
extern "C" {
    #[link_name = "\u{1}_Z5geqrfPfS_ii"]
    pub fn geqrf(d_tau: *mut f32, a: *mut f32, m: ::std::os::raw::c_int, n: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_Z5ormqrPfiS_S_i"]
    pub fn ormqr(
        b: *mut f32,
        m: ::std::os::raw::c_int,
        q: *mut f32,
        tau: *mut f32,
        n: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ray {
    pub coordinates: vector,
    pub directions: vector,
    pub surface_normal: vector,
    pub optical_path_length: rtd,
    pub optical_path_difference: rtd,
    pub v: ::std::os::raw::c_char,
    pub n_iteration: ::std::os::raw::c_int,
    pub throughput: rtd,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ray"][::std::mem::size_of::<ray>() - 104usize];
    ["Alignment of ray"][::std::mem::align_of::<ray>() - 8usize];
    ["Offset of field: ray::coordinates"][::std::mem::offset_of!(ray, coordinates) - 0usize];
    ["Offset of field: ray::directions"][::std::mem::offset_of!(ray, directions) - 24usize];
    ["Offset of field: ray::surface_normal"][::std::mem::offset_of!(ray, surface_normal) - 48usize];
    ["Offset of field: ray::optical_path_length"]
        [::std::mem::offset_of!(ray, optical_path_length) - 72usize];
    ["Offset of field: ray::optical_path_difference"]
        [::std::mem::offset_of!(ray, optical_path_difference) - 80usize];
    ["Offset of field: ray::v"][::std::mem::offset_of!(ray, v) - 88usize];
    ["Offset of field: ray::n_iteration"][::std::mem::offset_of!(ray, n_iteration) - 92usize];
    ["Offset of field: ray::throughput"][::std::mem::offset_of!(ray, throughput) - 96usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bundle {
    pub N_RAY: ::std::os::raw::c_int,
    pub d__ray: *mut ray,
    pub N_BUNDLE: ::std::os::raw::c_int,
    pub N_RAY_TOTAL: ::std::os::raw::c_int,
    pub d__origin: *mut vector,
    pub rot_angle: f64,
    pub d__chief_ray: *mut ray,
    pub d__chief_origin: *mut vector,
    pub V: mask,
    pub geom: [::std::os::raw::c_char; 8usize],
    pub N_RADIUS: ::std::os::raw::c_int,
    pub N_THETA: ::std::os::raw::c_int,
    pub N_L: ::std::os::raw::c_int,
    pub L: rtd,
    pub d__sphere_distance: *mut rtd,
    pub d__sphere_radius: *mut rtd,
    pub d__sphere_origin: *mut vector,
    pub d__piston_mask: *mut ::std::os::raw::c_int,
    pub refractive_index: rtd,
    pub d__Vx: *mut f64,
    pub d__Vy: *mut f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of bundle"][::std::mem::size_of::<bundle>() - 224usize];
    ["Alignment of bundle"][::std::mem::align_of::<bundle>() - 8usize];
    ["Offset of field: bundle::N_RAY"][::std::mem::offset_of!(bundle, N_RAY) - 0usize];
    ["Offset of field: bundle::d__ray"][::std::mem::offset_of!(bundle, d__ray) - 8usize];
    ["Offset of field: bundle::N_BUNDLE"][::std::mem::offset_of!(bundle, N_BUNDLE) - 16usize];
    ["Offset of field: bundle::N_RAY_TOTAL"][::std::mem::offset_of!(bundle, N_RAY_TOTAL) - 20usize];
    ["Offset of field: bundle::d__origin"][::std::mem::offset_of!(bundle, d__origin) - 24usize];
    ["Offset of field: bundle::rot_angle"][::std::mem::offset_of!(bundle, rot_angle) - 32usize];
    ["Offset of field: bundle::d__chief_ray"]
        [::std::mem::offset_of!(bundle, d__chief_ray) - 40usize];
    ["Offset of field: bundle::d__chief_origin"]
        [::std::mem::offset_of!(bundle, d__chief_origin) - 48usize];
    ["Offset of field: bundle::V"][::std::mem::offset_of!(bundle, V) - 56usize];
    ["Offset of field: bundle::geom"][::std::mem::offset_of!(bundle, geom) - 136usize];
    ["Offset of field: bundle::N_RADIUS"][::std::mem::offset_of!(bundle, N_RADIUS) - 144usize];
    ["Offset of field: bundle::N_THETA"][::std::mem::offset_of!(bundle, N_THETA) - 148usize];
    ["Offset of field: bundle::N_L"][::std::mem::offset_of!(bundle, N_L) - 152usize];
    ["Offset of field: bundle::L"][::std::mem::offset_of!(bundle, L) - 160usize];
    ["Offset of field: bundle::d__sphere_distance"]
        [::std::mem::offset_of!(bundle, d__sphere_distance) - 168usize];
    ["Offset of field: bundle::d__sphere_radius"]
        [::std::mem::offset_of!(bundle, d__sphere_radius) - 176usize];
    ["Offset of field: bundle::d__sphere_origin"]
        [::std::mem::offset_of!(bundle, d__sphere_origin) - 184usize];
    ["Offset of field: bundle::d__piston_mask"]
        [::std::mem::offset_of!(bundle, d__piston_mask) - 192usize];
    ["Offset of field: bundle::refractive_index"]
        [::std::mem::offset_of!(bundle, refractive_index) - 200usize];
    ["Offset of field: bundle::d__Vx"][::std::mem::offset_of!(bundle, d__Vx) - 208usize];
    ["Offset of field: bundle::d__Vy"][::std::mem::offset_of!(bundle, d__Vy) - 216usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN6bundle5setupEdii6vectori"]
    pub fn bundle_setup(
        this: *mut bundle,
        RADIUS: rtd,
        N_RADIUS: ::std::os::raw::c_int,
        N_THETA: ::std::os::raw::c_int,
        origin: vector,
        N_SRC: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6bundle5setupEdi6vectori"]
    pub fn bundle_setup1(
        this: *mut bundle,
        L: rtd,
        N_L: ::std::os::raw::c_int,
        origin: vector,
        N_SRC: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6bundle5setupEdi6vectorS0_i"]
    pub fn bundle_setup2(
        this: *mut bundle,
        L: rtd,
        N_L: ::std::os::raw::c_int,
        origin: vector,
        chief_origin: vector,
        N_SRC: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6bundle10setup_freeEiPdS0_6vector"]
    pub fn bundle_setup_free(
        this: *mut bundle,
        _N_RAY_: ::std::os::raw::c_int,
        x: *mut f64,
        y: *mut f64,
        origin: vector,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6bundle10setup_freeEddiPdS0_6vector"]
    pub fn bundle_setup_free1(
        this: *mut bundle,
        zenith: f64,
        azimuth: f64,
        _N_RAY_: ::std::os::raw::c_int,
        x: *mut f64,
        y: *mut f64,
        origin: vector,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6bundle7cleanupEv"]
    pub fn bundle_cleanup(this: *mut bundle);
}
extern "C" {
    #[link_name = "\u{1}_ZN6bundle10to_z_planeEd"]
    pub fn bundle_to_z_plane(this: *mut bundle, z_in: rtd);
}
extern "C" {
    #[link_name = "\u{1}_ZN6bundle14to_focal_planeEdd"]
    pub fn bundle_to_focal_plane(this: *mut bundle, z_chief_on_axis: rtd, rho_focal_plane: rtd);
}
extern "C" {
    #[link_name = "\u{1}_ZN6bundle9to_sphereE6vector"]
    pub fn bundle_to_sphere(this: *mut bundle, sphere_origin: vector);
}
extern "C" {
    #[link_name = "\u{1}_ZN6bundle9to_sphereEdd"]
    pub fn bundle_to_sphere1(this: *mut bundle, z_chief_on_axis: rtd, rho_focal_plane: rtd);
}
extern "C" {
    #[link_name = "\u{1}_ZN6bundle15get_coordinatesEPd"]
    pub fn bundle_get_coordinates(this: *mut bundle, d__coord: *mut f64);
}
extern "C" {
    #[link_name = "\u{1}_ZN6bundle21get_chief_coordinatesEPd"]
    pub fn bundle_get_chief_coordinates(this: *mut bundle, d__coord: *mut f64);
}
extern "C" {
    #[link_name = "\u{1}_ZN6bundle18get_sphere_originsEPd"]
    pub fn bundle_get_sphere_origins(this: *mut bundle, d__coord: *mut f64);
}
extern "C" {
    #[link_name = "\u{1}_ZN6bundle14get_directionsEPd"]
    pub fn bundle_get_directions(this: *mut bundle, d__dir: *mut f64);
}
extern "C" {
    #[link_name = "\u{1}_ZN6bundle20get_chief_directionsEPd"]
    pub fn bundle_get_chief_directions(this: *mut bundle, d__dir: *mut f64);
}
extern "C" {
    #[link_name = "\u{1}_ZN6bundle29get_chief_optical_path_lengthEPd"]
    pub fn bundle_get_chief_optical_path_length(this: *mut bundle, d__opl: *mut f64);
}
extern "C" {
    #[link_name = "\u{1}_ZN6bundle23get_optical_path_lengthEPd"]
    pub fn bundle_get_optical_path_length(this: *mut bundle, d__opl: *mut f64);
}
extern "C" {
    #[link_name = "\u{1}_ZN6bundle27get_optical_path_differenceEPd"]
    pub fn bundle_get_optical_path_difference(this: *mut bundle, d__opd: *mut f64);
}
extern "C" {
    #[link_name = "\u{1}_ZN6bundle27get_optical_path_differenceEPdfifi"]
    pub fn bundle_get_optical_path_difference1(
        this: *mut bundle,
        d__opd: *mut f64,
        delta_x: f32,
        N_x: ::std::os::raw::c_int,
        delta_y: f32,
        N_y: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6bundle14get_vignettingEPd"]
    pub fn bundle_get_vignetting(this: *mut bundle, d__v: *mut f64);
}
extern "C" {
    #[link_name = "\u{1}_ZN6bundle15get_n_iterationEPi"]
    pub fn bundle_get_n_iteration(this: *mut bundle, n_iteration: *mut ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN6bundle16gmt_truss_onaxisEv"]
    pub fn bundle_gmt_truss_onaxis(this: *mut bundle);
}
extern "C" {
    #[link_name = "\u{1}_ZN6bundle18gmt_truss_onaxis_1Ed"]
    pub fn bundle_gmt_truss_onaxis_1(this: *mut bundle, scale: f64);
}
extern "C" {
    #[link_name = "\u{1}_ZN6bundle18gmt_truss_onaxis_2Ed"]
    pub fn bundle_gmt_truss_onaxis_2(this: *mut bundle, scale: f64);
}
extern "C" {
    #[link_name = "\u{1}_ZN6bundle18gmt_truss_onaxis_3Ed"]
    pub fn bundle_gmt_truss_onaxis_3(this: *mut bundle, scale: f64);
}
extern "C" {
    #[link_name = "\u{1}_ZN6bundle14gmt_pma_onaxisEv"]
    pub fn bundle_gmt_pma_onaxis(this: *mut bundle);
}
extern "C" {
    #[link_name = "\u{1}_ZN6bundle20gmt_pma_plate_onaxisEv"]
    pub fn bundle_gmt_pma_plate_onaxis(this: *mut bundle);
}
extern "C" {
    #[link_name = "\u{1}_ZN6bundle13gmt_m2_baffleEv"]
    pub fn bundle_gmt_m2_baffle(this: *mut bundle);
}
impl bundle {
    #[inline]
    pub unsafe fn setup(
        &mut self,
        RADIUS: rtd,
        N_RADIUS: ::std::os::raw::c_int,
        N_THETA: ::std::os::raw::c_int,
        origin: vector,
        N_SRC: ::std::os::raw::c_int,
    ) {
        bundle_setup(self, RADIUS, N_RADIUS, N_THETA, origin, N_SRC)
    }
    #[inline]
    pub unsafe fn setup1(
        &mut self,
        L: rtd,
        N_L: ::std::os::raw::c_int,
        origin: vector,
        N_SRC: ::std::os::raw::c_int,
    ) {
        bundle_setup1(self, L, N_L, origin, N_SRC)
    }
    #[inline]
    pub unsafe fn setup2(
        &mut self,
        L: rtd,
        N_L: ::std::os::raw::c_int,
        origin: vector,
        chief_origin: vector,
        N_SRC: ::std::os::raw::c_int,
    ) {
        bundle_setup2(self, L, N_L, origin, chief_origin, N_SRC)
    }
    #[inline]
    pub unsafe fn setup_free(
        &mut self,
        _N_RAY_: ::std::os::raw::c_int,
        x: *mut f64,
        y: *mut f64,
        origin: vector,
    ) {
        bundle_setup_free(self, _N_RAY_, x, y, origin)
    }
    #[inline]
    pub unsafe fn setup_free1(
        &mut self,
        zenith: f64,
        azimuth: f64,
        _N_RAY_: ::std::os::raw::c_int,
        x: *mut f64,
        y: *mut f64,
        origin: vector,
    ) {
        bundle_setup_free1(self, zenith, azimuth, _N_RAY_, x, y, origin)
    }
    #[inline]
    pub unsafe fn cleanup(&mut self) {
        bundle_cleanup(self)
    }
    #[inline]
    pub unsafe fn to_z_plane(&mut self, z_in: rtd) {
        bundle_to_z_plane(self, z_in)
    }
    #[inline]
    pub unsafe fn to_focal_plane(&mut self, z_chief_on_axis: rtd, rho_focal_plane: rtd) {
        bundle_to_focal_plane(self, z_chief_on_axis, rho_focal_plane)
    }
    #[inline]
    pub unsafe fn to_sphere(&mut self, sphere_origin: vector) {
        bundle_to_sphere(self, sphere_origin)
    }
    #[inline]
    pub unsafe fn to_sphere1(&mut self, z_chief_on_axis: rtd, rho_focal_plane: rtd) {
        bundle_to_sphere1(self, z_chief_on_axis, rho_focal_plane)
    }
    #[inline]
    pub unsafe fn get_coordinates(&mut self, d__coord: *mut f64) {
        bundle_get_coordinates(self, d__coord)
    }
    #[inline]
    pub unsafe fn get_chief_coordinates(&mut self, d__coord: *mut f64) {
        bundle_get_chief_coordinates(self, d__coord)
    }
    #[inline]
    pub unsafe fn get_sphere_origins(&mut self, d__coord: *mut f64) {
        bundle_get_sphere_origins(self, d__coord)
    }
    #[inline]
    pub unsafe fn get_directions(&mut self, d__dir: *mut f64) {
        bundle_get_directions(self, d__dir)
    }
    #[inline]
    pub unsafe fn get_chief_directions(&mut self, d__dir: *mut f64) {
        bundle_get_chief_directions(self, d__dir)
    }
    #[inline]
    pub unsafe fn get_chief_optical_path_length(&mut self, d__opl: *mut f64) {
        bundle_get_chief_optical_path_length(self, d__opl)
    }
    #[inline]
    pub unsafe fn get_optical_path_length(&mut self, d__opl: *mut f64) {
        bundle_get_optical_path_length(self, d__opl)
    }
    #[inline]
    pub unsafe fn get_optical_path_difference(&mut self, d__opd: *mut f64) {
        bundle_get_optical_path_difference(self, d__opd)
    }
    #[inline]
    pub unsafe fn get_optical_path_difference1(
        &mut self,
        d__opd: *mut f64,
        delta_x: f32,
        N_x: ::std::os::raw::c_int,
        delta_y: f32,
        N_y: ::std::os::raw::c_int,
    ) {
        bundle_get_optical_path_difference1(self, d__opd, delta_x, N_x, delta_y, N_y)
    }
    #[inline]
    pub unsafe fn get_vignetting(&mut self, d__v: *mut f64) {
        bundle_get_vignetting(self, d__v)
    }
    #[inline]
    pub unsafe fn get_n_iteration(&mut self, n_iteration: *mut ::std::os::raw::c_int) {
        bundle_get_n_iteration(self, n_iteration)
    }
    #[inline]
    pub unsafe fn gmt_truss_onaxis(&mut self) {
        bundle_gmt_truss_onaxis(self)
    }
    #[inline]
    pub unsafe fn gmt_truss_onaxis_1(&mut self, scale: f64) {
        bundle_gmt_truss_onaxis_1(self, scale)
    }
    #[inline]
    pub unsafe fn gmt_truss_onaxis_2(&mut self, scale: f64) {
        bundle_gmt_truss_onaxis_2(self, scale)
    }
    #[inline]
    pub unsafe fn gmt_truss_onaxis_3(&mut self, scale: f64) {
        bundle_gmt_truss_onaxis_3(self, scale)
    }
    #[inline]
    pub unsafe fn gmt_pma_onaxis(&mut self) {
        bundle_gmt_pma_onaxis(self)
    }
    #[inline]
    pub unsafe fn gmt_pma_plate_onaxis(&mut self) {
        bundle_gmt_pma_plate_onaxis(self)
    }
    #[inline]
    pub unsafe fn gmt_m2_baffle(&mut self) {
        bundle_gmt_m2_baffle(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct complex_amplitude {
    pub N_PX: ::std::os::raw::c_int,
    pub N: ::std::os::raw::c_int,
    pub amplitude: *mut f32,
    pub phase: *mut f32,
    pub M: *mut mask,
    pub handle: cublasHandle_t,
    pub buffer: *mut f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of complex_amplitude"][::std::mem::size_of::<complex_amplitude>() - 48usize];
    ["Alignment of complex_amplitude"][::std::mem::align_of::<complex_amplitude>() - 8usize];
    ["Offset of field: complex_amplitude::N_PX"]
        [::std::mem::offset_of!(complex_amplitude, N_PX) - 0usize];
    ["Offset of field: complex_amplitude::N"]
        [::std::mem::offset_of!(complex_amplitude, N) - 4usize];
    ["Offset of field: complex_amplitude::amplitude"]
        [::std::mem::offset_of!(complex_amplitude, amplitude) - 8usize];
    ["Offset of field: complex_amplitude::phase"]
        [::std::mem::offset_of!(complex_amplitude, phase) - 16usize];
    ["Offset of field: complex_amplitude::M"]
        [::std::mem::offset_of!(complex_amplitude, M) - 24usize];
    ["Offset of field: complex_amplitude::handle"]
        [::std::mem::offset_of!(complex_amplitude, handle) - 32usize];
    ["Offset of field: complex_amplitude::buffer"]
        [::std::mem::offset_of!(complex_amplitude, buffer) - 40usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN17complex_amplitude5setupEi"]
    pub fn complex_amplitude_setup(this: *mut complex_amplitude, n_pixel: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN17complex_amplitude5setupEii"]
    pub fn complex_amplitude_setup1(
        this: *mut complex_amplitude,
        n_pixel: ::std::os::raw::c_int,
        n_src: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17complex_amplitude7cleanupEv"]
    pub fn complex_amplitude_cleanup(this: *mut complex_amplitude);
}
extern "C" {
    #[link_name = "\u{1}_ZN17complex_amplitude5resetEv"]
    pub fn complex_amplitude_reset(this: *mut complex_amplitude);
}
extern "C" {
    #[link_name = "\u{1}_ZN17complex_amplitude5resetEPS_"]
    pub fn complex_amplitude_reset1(
        this: *mut complex_amplitude,
        wavefront: *mut complex_amplitude,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17complex_amplitude15reset_amplitudeEv"]
    pub fn complex_amplitude_reset_amplitude(this: *mut complex_amplitude);
}
extern "C" {
    #[link_name = "\u{1}_ZN17complex_amplitude11reset_phaseEv"]
    pub fn complex_amplitude_reset_phase(this: *mut complex_amplitude);
}
extern "C" {
    #[link_name = "\u{1}_ZN17complex_amplitude11reset_phaseEPS_"]
    pub fn complex_amplitude_reset_phase1(
        this: *mut complex_amplitude,
        wavefront_prime: *mut complex_amplitude,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17complex_amplitude9add_phaseEfPf"]
    pub fn complex_amplitude_add_phase(
        this: *mut complex_amplitude,
        alpha: f32,
        phase_prime: *mut f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17complex_amplitude14add_same_phaseEfPf"]
    pub fn complex_amplitude_add_same_phase(
        this: *mut complex_amplitude,
        alpha: f32,
        phase_prime: *mut f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17complex_amplitude6maskedEv"]
    pub fn complex_amplitude_masked(this: *mut complex_amplitude);
}
extern "C" {
    #[link_name = "\u{1}_ZN17complex_amplitude6maskedEP4mask"]
    pub fn complex_amplitude_masked1(this: *mut complex_amplitude, M_in: *mut mask);
}
extern "C" {
    #[link_name = "\u{1}_ZN17complex_amplitude3rmsEPf"]
    pub fn complex_amplitude_rms(this: *mut complex_amplitude, rms: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN17complex_amplitude17finite_differenceEPfS0_if"]
    pub fn complex_amplitude_finite_difference(
        this: *mut complex_amplitude,
        sx: *mut f32,
        sy: *mut f32,
        NL: ::std::os::raw::c_int,
        d: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17complex_amplitude17finite_differenceEPfS0_ifP4mask"]
    pub fn complex_amplitude_finite_difference1(
        this: *mut complex_amplitude,
        sx: *mut f32,
        sy: *mut f32,
        NL: ::std::os::raw::c_int,
        d: f32,
        valid_lenslet: *mut mask,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17complex_amplitude16gradient_averageEPfS0_if"]
    pub fn complex_amplitude_gradient_average(
        this: *mut complex_amplitude,
        sx: *mut f32,
        sy: *mut f32,
        NL: ::std::os::raw::c_int,
        d: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17complex_amplitude16gradient_averageEPfS0_f"]
    pub fn complex_amplitude_gradient_average1(
        this: *mut complex_amplitude,
        sx: *mut f32,
        sy: *mut f32,
        d: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17complex_amplitude25segments_gradient_averageEPfS0_fPi"]
    pub fn complex_amplitude_segments_gradient_average(
        this: *mut complex_amplitude,
        sx: *mut f32,
        sy: *mut f32,
        D: f32,
        segment_markers: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17complex_amplitude29segments_gradient_averageFastEPfS0_fPi"]
    pub fn complex_amplitude_segments_gradient_averageFast(
        this: *mut complex_amplitude,
        sx: *mut f32,
        sy: *mut f32,
        D: f32,
        segment_markers: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17complex_amplitude10show_phaseEPc"]
    pub fn complex_amplitude_show_phase(
        this: *mut complex_amplitude,
        filename: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17complex_amplitude10show_phaseEPci"]
    pub fn complex_amplitude_show_phase1(
        this: *mut complex_amplitude,
        filename: *mut ::std::os::raw::c_char,
        N_SRC: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17complex_amplitude14show_amplitudeEPc"]
    pub fn complex_amplitude_show_amplitude(
        this: *mut complex_amplitude,
        filename: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17complex_amplitude14show_amplitudeEPcii"]
    pub fn complex_amplitude_show_amplitude1(
        this: *mut complex_amplitude,
        filename: *mut ::std::os::raw::c_char,
        N: ::std::os::raw::c_int,
        M: ::std::os::raw::c_int,
    );
}
impl complex_amplitude {
    #[inline]
    pub unsafe fn setup(&mut self, n_pixel: ::std::os::raw::c_int) {
        complex_amplitude_setup(self, n_pixel)
    }
    #[inline]
    pub unsafe fn setup1(&mut self, n_pixel: ::std::os::raw::c_int, n_src: ::std::os::raw::c_int) {
        complex_amplitude_setup1(self, n_pixel, n_src)
    }
    #[inline]
    pub unsafe fn cleanup(&mut self) {
        complex_amplitude_cleanup(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        complex_amplitude_reset(self)
    }
    #[inline]
    pub unsafe fn reset1(&mut self, wavefront: *mut complex_amplitude) {
        complex_amplitude_reset1(self, wavefront)
    }
    #[inline]
    pub unsafe fn reset_amplitude(&mut self) {
        complex_amplitude_reset_amplitude(self)
    }
    #[inline]
    pub unsafe fn reset_phase(&mut self) {
        complex_amplitude_reset_phase(self)
    }
    #[inline]
    pub unsafe fn reset_phase1(&mut self, wavefront_prime: *mut complex_amplitude) {
        complex_amplitude_reset_phase1(self, wavefront_prime)
    }
    #[inline]
    pub unsafe fn add_phase(&mut self, alpha: f32, phase_prime: *mut f32) {
        complex_amplitude_add_phase(self, alpha, phase_prime)
    }
    #[inline]
    pub unsafe fn add_same_phase(&mut self, alpha: f32, phase_prime: *mut f32) {
        complex_amplitude_add_same_phase(self, alpha, phase_prime)
    }
    #[inline]
    pub unsafe fn masked(&mut self) {
        complex_amplitude_masked(self)
    }
    #[inline]
    pub unsafe fn masked1(&mut self, M_in: *mut mask) {
        complex_amplitude_masked1(self, M_in)
    }
    #[inline]
    pub unsafe fn rms(&mut self, rms: *mut f32) {
        complex_amplitude_rms(self, rms)
    }
    #[inline]
    pub unsafe fn finite_difference(
        &mut self,
        sx: *mut f32,
        sy: *mut f32,
        NL: ::std::os::raw::c_int,
        d: f32,
    ) {
        complex_amplitude_finite_difference(self, sx, sy, NL, d)
    }
    #[inline]
    pub unsafe fn finite_difference1(
        &mut self,
        sx: *mut f32,
        sy: *mut f32,
        NL: ::std::os::raw::c_int,
        d: f32,
        valid_lenslet: *mut mask,
    ) {
        complex_amplitude_finite_difference1(self, sx, sy, NL, d, valid_lenslet)
    }
    #[inline]
    pub unsafe fn gradient_average(
        &mut self,
        sx: *mut f32,
        sy: *mut f32,
        NL: ::std::os::raw::c_int,
        d: f32,
    ) {
        complex_amplitude_gradient_average(self, sx, sy, NL, d)
    }
    #[inline]
    pub unsafe fn gradient_average1(&mut self, sx: *mut f32, sy: *mut f32, d: f32) {
        complex_amplitude_gradient_average1(self, sx, sy, d)
    }
    #[inline]
    pub unsafe fn segments_gradient_average(
        &mut self,
        sx: *mut f32,
        sy: *mut f32,
        D: f32,
        segment_markers: *mut ::std::os::raw::c_int,
    ) {
        complex_amplitude_segments_gradient_average(self, sx, sy, D, segment_markers)
    }
    #[inline]
    pub unsafe fn segments_gradient_averageFast(
        &mut self,
        sx: *mut f32,
        sy: *mut f32,
        D: f32,
        segment_markers: *mut ::std::os::raw::c_int,
    ) {
        complex_amplitude_segments_gradient_averageFast(self, sx, sy, D, segment_markers)
    }
    #[inline]
    pub unsafe fn show_phase(&mut self, filename: *mut ::std::os::raw::c_char) {
        complex_amplitude_show_phase(self, filename)
    }
    #[inline]
    pub unsafe fn show_phase1(
        &mut self,
        filename: *mut ::std::os::raw::c_char,
        N_SRC: ::std::os::raw::c_int,
    ) {
        complex_amplitude_show_phase1(self, filename, N_SRC)
    }
    #[inline]
    pub unsafe fn show_amplitude(&mut self, filename: *mut ::std::os::raw::c_char) {
        complex_amplitude_show_amplitude(self, filename)
    }
    #[inline]
    pub unsafe fn show_amplitude1(
        &mut self,
        filename: *mut ::std::os::raw::c_char,
        N: ::std::os::raw::c_int,
        M: ::std::os::raw::c_int,
    ) {
        complex_amplitude_show_amplitude1(self, filename, N, M)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct source {
    pub N_SRC: ::std::os::raw::c_int,
    pub zenith: f32,
    pub azimuth: f32,
    pub height: f32,
    pub theta_x: f32,
    pub theta_y: f32,
    pub _zenith_64_: rtd,
    pub _azimuth_64_: rtd,
    pub _height_64_: rtd,
    pub _theta_x_64_: rtd,
    pub _theta_y_64_: rtd,
    pub photometric_band: *const ::std::os::raw::c_char,
    pub magnitude: f32,
    pub N_PHOTON: f32,
    pub fwhm: f32,
    pub wavefront: complex_amplitude,
    pub dev_ptr: *mut source,
    pub tag: [::std::os::raw::c_char; 8usize],
    pub rays_exist: ::std::os::raw::c_char,
    pub rays: bundle,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of source"][::std::mem::size_of::<source>() - 384usize];
    ["Alignment of source"][::std::mem::align_of::<source>() - 8usize];
    ["Offset of field: source::N_SRC"][::std::mem::offset_of!(source, N_SRC) - 0usize];
    ["Offset of field: source::zenith"][::std::mem::offset_of!(source, zenith) - 4usize];
    ["Offset of field: source::azimuth"][::std::mem::offset_of!(source, azimuth) - 8usize];
    ["Offset of field: source::height"][::std::mem::offset_of!(source, height) - 12usize];
    ["Offset of field: source::theta_x"][::std::mem::offset_of!(source, theta_x) - 16usize];
    ["Offset of field: source::theta_y"][::std::mem::offset_of!(source, theta_y) - 20usize];
    ["Offset of field: source::_zenith_64_"][::std::mem::offset_of!(source, _zenith_64_) - 24usize];
    ["Offset of field: source::_azimuth_64_"]
        [::std::mem::offset_of!(source, _azimuth_64_) - 32usize];
    ["Offset of field: source::_height_64_"][::std::mem::offset_of!(source, _height_64_) - 40usize];
    ["Offset of field: source::_theta_x_64_"]
        [::std::mem::offset_of!(source, _theta_x_64_) - 48usize];
    ["Offset of field: source::_theta_y_64_"]
        [::std::mem::offset_of!(source, _theta_y_64_) - 56usize];
    ["Offset of field: source::photometric_band"]
        [::std::mem::offset_of!(source, photometric_band) - 64usize];
    ["Offset of field: source::magnitude"][::std::mem::offset_of!(source, magnitude) - 72usize];
    ["Offset of field: source::N_PHOTON"][::std::mem::offset_of!(source, N_PHOTON) - 76usize];
    ["Offset of field: source::fwhm"][::std::mem::offset_of!(source, fwhm) - 80usize];
    ["Offset of field: source::wavefront"][::std::mem::offset_of!(source, wavefront) - 88usize];
    ["Offset of field: source::dev_ptr"][::std::mem::offset_of!(source, dev_ptr) - 136usize];
    ["Offset of field: source::tag"][::std::mem::offset_of!(source, tag) - 144usize];
    ["Offset of field: source::rays_exist"][::std::mem::offset_of!(source, rays_exist) - 152usize];
    ["Offset of field: source::rays"][::std::mem::offset_of!(source, rays) - 160usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN6source5setupEPKcfff"]
    pub fn source_setup(
        this: *mut source,
        _photometric_band: *const ::std::os::raw::c_char,
        zenith: f32,
        azimuth: f32,
        height: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6source5setupEPKcfffi"]
    pub fn source_setup1(
        this: *mut source,
        _photometric_band: *const ::std::os::raw::c_char,
        zenith: f32,
        azimuth: f32,
        height: f32,
        resolution: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6source5setupEPKcfffS1_"]
    pub fn source_setup2(
        this: *mut source,
        _photometric_band: *const ::std::os::raw::c_char,
        zenith: f32,
        azimuth: f32,
        height: f32,
        tag_in: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6source5setupEPKcfffiS1_"]
    pub fn source_setup3(
        this: *mut source,
        _photometric_band: *const ::std::os::raw::c_char,
        zenith: f32,
        azimuth: f32,
        height: f32,
        resolution: ::std::os::raw::c_int,
        tag_in: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6source5setupEPKcPfS2_fi"]
    pub fn source_setup4(
        this: *mut source,
        _photometric_band: *const ::std::os::raw::c_char,
        _zenith: *mut f32,
        _azimuth: *mut f32,
        _height: f32,
        _N_SRC: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6source5setupEPKcPfS2_fii"]
    pub fn source_setup5(
        this: *mut source,
        _photometric_band: *const ::std::os::raw::c_char,
        _zenith: *mut f32,
        _azimuth: *mut f32,
        _height: f32,
        _N_SRC: ::std::os::raw::c_int,
        resolution: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6source5setupEPKcPfS2_fidi6vector"]
    pub fn source_setup6(
        this: *mut source,
        _photometric_band: *const ::std::os::raw::c_char,
        _zenith: *mut f32,
        _azimuth: *mut f32,
        _height: f32,
        _N_SRC: ::std::os::raw::c_int,
        _L_: rtd,
        _N_L_: ::std::os::raw::c_int,
        origin: vector,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6source5setupEPKcPfS2_S2_fidi6vector"]
    pub fn source_setup7(
        this: *mut source,
        _photometric_band: *const ::std::os::raw::c_char,
        magnitude: *mut f32,
        _zenith: *mut f32,
        _azimuth: *mut f32,
        _height: f32,
        _N_SRC: ::std::os::raw::c_int,
        _L_: rtd,
        _N_L_: ::std::os::raw::c_int,
        origin: vector,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6source5setupEPKcPfPdS3_fidi6vector"]
    pub fn source_setup8(
        this: *mut source,
        _photometric_band: *const ::std::os::raw::c_char,
        magnitude: *mut f32,
        _zenith: *mut rtd,
        _azimuth: *mut rtd,
        _height: f32,
        _N_SRC: ::std::os::raw::c_int,
        _L_: rtd,
        _N_L_: ::std::os::raw::c_int,
        origin: vector,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6source11setup_chiefEPKcPfPdS3_fidi6vectorS4_"]
    pub fn source_setup_chief(
        this: *mut source,
        _photometric_band: *const ::std::os::raw::c_char,
        magnitude: *mut f32,
        _zenith: *mut rtd,
        _azimuth: *mut rtd,
        _height: f32,
        _N_SRC: ::std::os::raw::c_int,
        _L_: rtd,
        _N_L_: ::std::os::raw::c_int,
        origin: vector,
        chief_origin: vector,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6source5setupEPKcPfPdS3_fiiS3_S3_6vector"]
    pub fn source_setup9(
        this: *mut source,
        _photometric_band: *const ::std::os::raw::c_char,
        _magnitude: *mut f32,
        _zenith: *mut rtd,
        _azimuth: *mut rtd,
        _height: f32,
        _N_SRC: ::std::os::raw::c_int,
        _N_RAY_: ::std::os::raw::c_int,
        x: *mut f64,
        y: *mut f64,
        origin: vector,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6source7cleanupEv"]
    pub fn source_cleanup(this: *mut source);
}
extern "C" {
    #[link_name = "\u{1}_ZN6source10reset_raysEv"]
    pub fn source_reset_rays(this: *mut source);
}
extern "C" {
    #[link_name = "\u{1}_ZN6source10reset_raysEi"]
    pub fn source_reset_rays1(this: *mut source, RESET_RAYS_MASK: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN6source9opd2phaseEv"]
    pub fn source_opd2phase(this: *mut source);
}
extern "C" {
    #[link_name = "\u{1}_ZN6source9opd2phaseEi"]
    pub fn source_opd2phase1(this: *mut source, RESET_RAYS_MASK: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN6source4infoEv"]
    pub fn source_info(this: *mut source);
}
extern "C" {
    #[link_name = "\u{1}_ZN6source10phase2fileEPKc"]
    pub fn source_phase2file(this: *mut source, filename: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_ZN6source10wavelengthEv"]
    pub fn source_wavelength(this: *mut source) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN6source17wavelength_micronEv"]
    pub fn source_wavelength_micron(this: *mut source) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN6source18spectral_bandwidthEv"]
    pub fn source_spectral_bandwidth(this: *mut source) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN6source8n_photonEv"]
    pub fn source_n_photon(this: *mut source) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN6source8n_photonEf"]
    pub fn source_n_photon1(this: *mut source, _magnitude_: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN6source19n_background_photonEf"]
    pub fn source_n_background_photon(this: *mut source, backgroundMagnitude: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN6source10wavenumberEv"]
    pub fn source_wavenumber(this: *mut source) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN6source17update_directionsEPdS0_i"]
    pub fn source_update_directions(
        this: *mut source,
        zenith: *mut f64,
        azimuth: *mut f64,
        N_DIR: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6source16update_magnitudeEPfi"]
    pub fn source_update_magnitude(
        this: *mut source,
        magnitude: *mut f32,
        N_MAG: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6source14copy_magnitudeEPS_"]
    pub fn source_copy_magnitude(this: *mut source, other_src: *mut source);
}
extern "C" {
    #[link_name = "\u{1}_ZN6source25optical_transfer_functionEP6float2"]
    pub fn source_optical_transfer_function(this: *mut source, d__otf: *mut float2);
}
impl source {
    #[inline]
    pub unsafe fn setup(
        &mut self,
        _photometric_band: *const ::std::os::raw::c_char,
        zenith: f32,
        azimuth: f32,
        height: f32,
    ) {
        source_setup(self, _photometric_band, zenith, azimuth, height)
    }
    #[inline]
    pub unsafe fn setup1(
        &mut self,
        _photometric_band: *const ::std::os::raw::c_char,
        zenith: f32,
        azimuth: f32,
        height: f32,
        resolution: ::std::os::raw::c_int,
    ) {
        source_setup1(self, _photometric_band, zenith, azimuth, height, resolution)
    }
    #[inline]
    pub unsafe fn setup2(
        &mut self,
        _photometric_band: *const ::std::os::raw::c_char,
        zenith: f32,
        azimuth: f32,
        height: f32,
        tag_in: *const ::std::os::raw::c_char,
    ) {
        source_setup2(self, _photometric_band, zenith, azimuth, height, tag_in)
    }
    #[inline]
    pub unsafe fn setup3(
        &mut self,
        _photometric_band: *const ::std::os::raw::c_char,
        zenith: f32,
        azimuth: f32,
        height: f32,
        resolution: ::std::os::raw::c_int,
        tag_in: *const ::std::os::raw::c_char,
    ) {
        source_setup3(
            self,
            _photometric_band,
            zenith,
            azimuth,
            height,
            resolution,
            tag_in,
        )
    }
    #[inline]
    pub unsafe fn setup4(
        &mut self,
        _photometric_band: *const ::std::os::raw::c_char,
        _zenith: *mut f32,
        _azimuth: *mut f32,
        _height: f32,
        _N_SRC: ::std::os::raw::c_int,
    ) {
        source_setup4(self, _photometric_band, _zenith, _azimuth, _height, _N_SRC)
    }
    #[inline]
    pub unsafe fn setup5(
        &mut self,
        _photometric_band: *const ::std::os::raw::c_char,
        _zenith: *mut f32,
        _azimuth: *mut f32,
        _height: f32,
        _N_SRC: ::std::os::raw::c_int,
        resolution: ::std::os::raw::c_int,
    ) {
        source_setup5(
            self,
            _photometric_band,
            _zenith,
            _azimuth,
            _height,
            _N_SRC,
            resolution,
        )
    }
    #[inline]
    pub unsafe fn setup6(
        &mut self,
        _photometric_band: *const ::std::os::raw::c_char,
        _zenith: *mut f32,
        _azimuth: *mut f32,
        _height: f32,
        _N_SRC: ::std::os::raw::c_int,
        _L_: rtd,
        _N_L_: ::std::os::raw::c_int,
        origin: vector,
    ) {
        source_setup6(
            self,
            _photometric_band,
            _zenith,
            _azimuth,
            _height,
            _N_SRC,
            _L_,
            _N_L_,
            origin,
        )
    }
    #[inline]
    pub unsafe fn setup7(
        &mut self,
        _photometric_band: *const ::std::os::raw::c_char,
        magnitude: *mut f32,
        _zenith: *mut f32,
        _azimuth: *mut f32,
        _height: f32,
        _N_SRC: ::std::os::raw::c_int,
        _L_: rtd,
        _N_L_: ::std::os::raw::c_int,
        origin: vector,
    ) {
        source_setup7(
            self,
            _photometric_band,
            magnitude,
            _zenith,
            _azimuth,
            _height,
            _N_SRC,
            _L_,
            _N_L_,
            origin,
        )
    }
    #[inline]
    pub unsafe fn setup8(
        &mut self,
        _photometric_band: *const ::std::os::raw::c_char,
        magnitude: *mut f32,
        _zenith: *mut rtd,
        _azimuth: *mut rtd,
        _height: f32,
        _N_SRC: ::std::os::raw::c_int,
        _L_: rtd,
        _N_L_: ::std::os::raw::c_int,
        origin: vector,
    ) {
        source_setup8(
            self,
            _photometric_band,
            magnitude,
            _zenith,
            _azimuth,
            _height,
            _N_SRC,
            _L_,
            _N_L_,
            origin,
        )
    }
    #[inline]
    pub unsafe fn setup_chief(
        &mut self,
        _photometric_band: *const ::std::os::raw::c_char,
        magnitude: *mut f32,
        _zenith: *mut rtd,
        _azimuth: *mut rtd,
        _height: f32,
        _N_SRC: ::std::os::raw::c_int,
        _L_: rtd,
        _N_L_: ::std::os::raw::c_int,
        origin: vector,
        chief_origin: vector,
    ) {
        source_setup_chief(
            self,
            _photometric_band,
            magnitude,
            _zenith,
            _azimuth,
            _height,
            _N_SRC,
            _L_,
            _N_L_,
            origin,
            chief_origin,
        )
    }
    #[inline]
    pub unsafe fn setup9(
        &mut self,
        _photometric_band: *const ::std::os::raw::c_char,
        _magnitude: *mut f32,
        _zenith: *mut rtd,
        _azimuth: *mut rtd,
        _height: f32,
        _N_SRC: ::std::os::raw::c_int,
        _N_RAY_: ::std::os::raw::c_int,
        x: *mut f64,
        y: *mut f64,
        origin: vector,
    ) {
        source_setup9(
            self,
            _photometric_band,
            _magnitude,
            _zenith,
            _azimuth,
            _height,
            _N_SRC,
            _N_RAY_,
            x,
            y,
            origin,
        )
    }
    #[inline]
    pub unsafe fn cleanup(&mut self) {
        source_cleanup(self)
    }
    #[inline]
    pub unsafe fn reset_rays(&mut self) {
        source_reset_rays(self)
    }
    #[inline]
    pub unsafe fn reset_rays1(&mut self, RESET_RAYS_MASK: ::std::os::raw::c_int) {
        source_reset_rays1(self, RESET_RAYS_MASK)
    }
    #[inline]
    pub unsafe fn opd2phase(&mut self) {
        source_opd2phase(self)
    }
    #[inline]
    pub unsafe fn opd2phase1(&mut self, RESET_RAYS_MASK: ::std::os::raw::c_int) {
        source_opd2phase1(self, RESET_RAYS_MASK)
    }
    #[inline]
    pub unsafe fn info(&mut self) {
        source_info(self)
    }
    #[inline]
    pub unsafe fn phase2file(&mut self, filename: *const ::std::os::raw::c_char) {
        source_phase2file(self, filename)
    }
    #[inline]
    pub unsafe fn wavelength(&mut self) -> f32 {
        source_wavelength(self)
    }
    #[inline]
    pub unsafe fn wavelength_micron(&mut self) -> f32 {
        source_wavelength_micron(self)
    }
    #[inline]
    pub unsafe fn spectral_bandwidth(&mut self) -> f32 {
        source_spectral_bandwidth(self)
    }
    #[inline]
    pub unsafe fn n_photon(&mut self) -> f32 {
        source_n_photon(self)
    }
    #[inline]
    pub unsafe fn n_photon1(&mut self, _magnitude_: f32) -> f32 {
        source_n_photon1(self, _magnitude_)
    }
    #[inline]
    pub unsafe fn n_background_photon(&mut self, backgroundMagnitude: f32) -> f32 {
        source_n_background_photon(self, backgroundMagnitude)
    }
    #[inline]
    pub unsafe fn wavenumber(&mut self) -> f32 {
        source_wavenumber(self)
    }
    #[inline]
    pub unsafe fn update_directions(
        &mut self,
        zenith: *mut f64,
        azimuth: *mut f64,
        N_DIR: ::std::os::raw::c_int,
    ) {
        source_update_directions(self, zenith, azimuth, N_DIR)
    }
    #[inline]
    pub unsafe fn update_magnitude(&mut self, magnitude: *mut f32, N_MAG: ::std::os::raw::c_int) {
        source_update_magnitude(self, magnitude, N_MAG)
    }
    #[inline]
    pub unsafe fn copy_magnitude(&mut self, other_src: *mut source) {
        source_copy_magnitude(self, other_src)
    }
    #[inline]
    pub unsafe fn optical_transfer_function(&mut self, d__otf: *mut float2) {
        source_optical_transfer_function(self, d__otf)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pssn {
    pub N_O: ::std::os::raw::c_int,
    pub N_O0: ::std::os::raw::c_int,
    pub n_byte: ::std::os::raw::c_int,
    pub d__O: *mut float2,
    pub d__O0: *mut float2,
    pub buffer: *mut float2,
    pub d__C: *mut float2,
    pub N_PX: ::std::os::raw::c_int,
    pub N: ::std::os::raw::c_int,
    pub d__W: *mut float2,
    pub N_OTF: ::std::os::raw::c_int,
    pub N_OTF2: ::std::os::raw::c_int,
    pub NN: ::std::os::raw::c_int,
    pub plan: cufftHandle,
    pub handle: cublasHandle_t,
    pub num: f32,
    pub denom: *mut f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pssn"][::std::mem::size_of::<pssn>() - 104usize];
    ["Alignment of pssn"][::std::mem::align_of::<pssn>() - 8usize];
    ["Offset of field: pssn::N_O"][::std::mem::offset_of!(pssn, N_O) - 0usize];
    ["Offset of field: pssn::N_O0"][::std::mem::offset_of!(pssn, N_O0) - 4usize];
    ["Offset of field: pssn::n_byte"][::std::mem::offset_of!(pssn, n_byte) - 8usize];
    ["Offset of field: pssn::d__O"][::std::mem::offset_of!(pssn, d__O) - 16usize];
    ["Offset of field: pssn::d__O0"][::std::mem::offset_of!(pssn, d__O0) - 24usize];
    ["Offset of field: pssn::buffer"][::std::mem::offset_of!(pssn, buffer) - 32usize];
    ["Offset of field: pssn::d__C"][::std::mem::offset_of!(pssn, d__C) - 40usize];
    ["Offset of field: pssn::N_PX"][::std::mem::offset_of!(pssn, N_PX) - 48usize];
    ["Offset of field: pssn::N"][::std::mem::offset_of!(pssn, N) - 52usize];
    ["Offset of field: pssn::d__W"][::std::mem::offset_of!(pssn, d__W) - 56usize];
    ["Offset of field: pssn::N_OTF"][::std::mem::offset_of!(pssn, N_OTF) - 64usize];
    ["Offset of field: pssn::N_OTF2"][::std::mem::offset_of!(pssn, N_OTF2) - 68usize];
    ["Offset of field: pssn::NN"][::std::mem::offset_of!(pssn, NN) - 72usize];
    ["Offset of field: pssn::plan"][::std::mem::offset_of!(pssn, plan) - 76usize];
    ["Offset of field: pssn::handle"][::std::mem::offset_of!(pssn, handle) - 80usize];
    ["Offset of field: pssn::num"][::std::mem::offset_of!(pssn, num) - 88usize];
    ["Offset of field: pssn::denom"][::std::mem::offset_of!(pssn, denom) - 96usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN4pssn5setupEP6sourceff"]
    pub fn pssn_setup(this: *mut pssn, src: *mut source, r0: f32, L0: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN4pssn7cleanupEv"]
    pub fn pssn_cleanup(this: *mut pssn);
}
extern "C" {
    #[link_name = "\u{1}_ZN4pssn7__otf__EP6sourceP6float2"]
    pub fn pssn___otf__(this: *mut pssn, src: *mut source, _d__O_: *mut float2);
}
extern "C" {
    #[link_name = "\u{1}_ZN4pssn3otfEP6source"]
    pub fn pssn_otf(this: *mut pssn, src: *mut source);
}
extern "C" {
    #[link_name = "\u{1}_ZN4pssn7atm_otfEfff"]
    pub fn pssn_atm_otf(this: *mut pssn, d: f32, r0: f32, L0: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN4pssn4evalEv"]
    pub fn pssn_eval(this: *mut pssn) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN4pssn5oevalEv"]
    pub fn pssn_oeval(this: *mut pssn) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN4pssn4evalEPf"]
    pub fn pssn_eval1(this: *mut pssn, results: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN4pssn5oevalEPf"]
    pub fn pssn_oeval1(this: *mut pssn, results: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN4pssn4xotfEPf"]
    pub fn pssn_xotf(this: *mut pssn, buffer: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN4pssn1OEPf"]
    pub fn pssn_O(this: *mut pssn, buffer: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN4pssn2O0EPf"]
    pub fn pssn_O0(this: *mut pssn, buffer: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN4pssn1CEPf"]
    pub fn pssn_C(this: *mut pssn, buffer: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN4pssn1BEPf"]
    pub fn pssn_B(this: *mut pssn, buffer: *mut f32);
}
impl pssn {
    #[inline]
    pub unsafe fn setup(&mut self, src: *mut source, r0: f32, L0: f32) {
        pssn_setup(self, src, r0, L0)
    }
    #[inline]
    pub unsafe fn cleanup(&mut self) {
        pssn_cleanup(self)
    }
    #[inline]
    pub unsafe fn __otf__(&mut self, src: *mut source, _d__O_: *mut float2) {
        pssn___otf__(self, src, _d__O_)
    }
    #[inline]
    pub unsafe fn otf(&mut self, src: *mut source) {
        pssn_otf(self, src)
    }
    #[inline]
    pub unsafe fn atm_otf(&mut self, d: f32, r0: f32, L0: f32) {
        pssn_atm_otf(self, d, r0, L0)
    }
    #[inline]
    pub unsafe fn eval(&mut self) -> f32 {
        pssn_eval(self)
    }
    #[inline]
    pub unsafe fn oeval(&mut self) -> f32 {
        pssn_oeval(self)
    }
    #[inline]
    pub unsafe fn eval1(&mut self, results: *mut f32) {
        pssn_eval1(self, results)
    }
    #[inline]
    pub unsafe fn oeval1(&mut self, results: *mut f32) {
        pssn_oeval1(self, results)
    }
    #[inline]
    pub unsafe fn xotf(&mut self, buffer: *mut f32) {
        pssn_xotf(self, buffer)
    }
    #[inline]
    pub unsafe fn O(&mut self, buffer: *mut f32) {
        pssn_O(self, buffer)
    }
    #[inline]
    pub unsafe fn O0(&mut self, buffer: *mut f32) {
        pssn_O0(self, buffer)
    }
    #[inline]
    pub unsafe fn C(&mut self, buffer: *mut f32) {
        pssn_C(self, buffer)
    }
    #[inline]
    pub unsafe fn B(&mut self, buffer: *mut f32) {
        pssn_B(self, buffer)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct coordinate_system {
    pub origin: *mut vector,
    pub euler_angles: *mut vector,
    pub N: ::std::os::raw::c_int,
    pub R: *mut rtd,
    pub d__R: *mut rtd,
    pub float_R: *mut f32,
    pub d__origin: *mut vector,
    pub tag: [::std::os::raw::c_char; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of coordinate_system"][::std::mem::size_of::<coordinate_system>() - 88usize];
    ["Alignment of coordinate_system"][::std::mem::align_of::<coordinate_system>() - 8usize];
    ["Offset of field: coordinate_system::origin"]
        [::std::mem::offset_of!(coordinate_system, origin) - 0usize];
    ["Offset of field: coordinate_system::euler_angles"]
        [::std::mem::offset_of!(coordinate_system, euler_angles) - 8usize];
    ["Offset of field: coordinate_system::N"]
        [::std::mem::offset_of!(coordinate_system, N) - 16usize];
    ["Offset of field: coordinate_system::R"]
        [::std::mem::offset_of!(coordinate_system, R) - 24usize];
    ["Offset of field: coordinate_system::d__R"]
        [::std::mem::offset_of!(coordinate_system, d__R) - 32usize];
    ["Offset of field: coordinate_system::float_R"]
        [::std::mem::offset_of!(coordinate_system, float_R) - 40usize];
    ["Offset of field: coordinate_system::d__origin"]
        [::std::mem::offset_of!(coordinate_system, d__origin) - 48usize];
    ["Offset of field: coordinate_system::tag"]
        [::std::mem::offset_of!(coordinate_system, tag) - 56usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN17coordinate_system5setupEv"]
    pub fn coordinate_system_setup(this: *mut coordinate_system);
}
extern "C" {
    #[link_name = "\u{1}_ZN17coordinate_system5setupE6vectorS0_"]
    pub fn coordinate_system_setup1(
        this: *mut coordinate_system,
        _origin_: vector,
        _euler_angles_: vector,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17coordinate_system5setupEP6vectorS1_i"]
    pub fn coordinate_system_setup2(
        this: *mut coordinate_system,
        _origin_: *mut vector,
        _euler_angles_: *mut vector,
        _N_: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17coordinate_system5setupEP6vectorS1_iPc"]
    pub fn coordinate_system_setup3(
        this: *mut coordinate_system,
        _origin_: *mut vector,
        _euler_angles_: *mut vector,
        _N_: ::std::os::raw::c_int,
        _tag_: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17coordinate_system7cleanupEv"]
    pub fn coordinate_system_cleanup(this: *mut coordinate_system);
}
extern "C" {
    #[link_name = "\u{1}_ZN17coordinate_system4infoEv"]
    pub fn coordinate_system_info(this: *mut coordinate_system);
}
extern "C" {
    #[link_name = "\u{1}_ZN17coordinate_system12info_detailsEv"]
    pub fn coordinate_system_info_details(this: *mut coordinate_system);
}
extern "C" {
    #[link_name = "\u{1}_ZN17coordinate_system6updateEv"]
    pub fn coordinate_system_update(this: *mut coordinate_system);
}
extern "C" {
    #[link_name = "\u{1}_ZN17coordinate_system6updateE6vectorS0_i"]
    pub fn coordinate_system_update1(
        this: *mut coordinate_system,
        _origin_: vector,
        _euler_angles_: vector,
        idx: ::std::os::raw::c_int,
    );
}
impl coordinate_system {
    #[inline]
    pub unsafe fn setup(&mut self) {
        coordinate_system_setup(self)
    }
    #[inline]
    pub unsafe fn setup1(&mut self, _origin_: vector, _euler_angles_: vector) {
        coordinate_system_setup1(self, _origin_, _euler_angles_)
    }
    #[inline]
    pub unsafe fn setup2(
        &mut self,
        _origin_: *mut vector,
        _euler_angles_: *mut vector,
        _N_: ::std::os::raw::c_int,
    ) {
        coordinate_system_setup2(self, _origin_, _euler_angles_, _N_)
    }
    #[inline]
    pub unsafe fn setup3(
        &mut self,
        _origin_: *mut vector,
        _euler_angles_: *mut vector,
        _N_: ::std::os::raw::c_int,
        _tag_: *mut ::std::os::raw::c_char,
    ) {
        coordinate_system_setup3(self, _origin_, _euler_angles_, _N_, _tag_)
    }
    #[inline]
    pub unsafe fn cleanup(&mut self) {
        coordinate_system_cleanup(self)
    }
    #[inline]
    pub unsafe fn info(&mut self) {
        coordinate_system_info(self)
    }
    #[inline]
    pub unsafe fn info_details(&mut self) {
        coordinate_system_info_details(self)
    }
    #[inline]
    pub unsafe fn update(&mut self) {
        coordinate_system_update(self)
    }
    #[inline]
    pub unsafe fn update1(
        &mut self,
        _origin_: vector,
        _euler_angles_: vector,
        idx: ::std::os::raw::c_int,
    ) {
        coordinate_system_update1(self, _origin_, _euler_angles_, idx)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conic {
    pub ref_frame: coordinate_system,
    pub origin: vector,
    pub d__origin: *mut vector,
    pub c: rtd,
    pub k: rtd,
    pub refractive_index: rtd,
    pub even_asphere_N: ::std::os::raw::c_int,
    pub d__even_asphere_a: *mut rtd,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of conic"][::std::mem::size_of::<conic>() - 160usize];
    ["Alignment of conic"][::std::mem::align_of::<conic>() - 8usize];
    ["Offset of field: conic::ref_frame"][::std::mem::offset_of!(conic, ref_frame) - 0usize];
    ["Offset of field: conic::origin"][::std::mem::offset_of!(conic, origin) - 88usize];
    ["Offset of field: conic::d__origin"][::std::mem::offset_of!(conic, d__origin) - 112usize];
    ["Offset of field: conic::c"][::std::mem::offset_of!(conic, c) - 120usize];
    ["Offset of field: conic::k"][::std::mem::offset_of!(conic, k) - 128usize];
    ["Offset of field: conic::refractive_index"]
        [::std::mem::offset_of!(conic, refractive_index) - 136usize];
    ["Offset of field: conic::even_asphere_N"]
        [::std::mem::offset_of!(conic, even_asphere_N) - 144usize];
    ["Offset of field: conic::d__even_asphere_a"]
        [::std::mem::offset_of!(conic, d__even_asphere_a) - 152usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN5conic5setupEdd"]
    pub fn conic_setup(this: *mut conic, _c_: rtd, _k_: rtd);
}
extern "C" {
    #[link_name = "\u{1}_ZN5conic5setupEdd6vectorS0_"]
    pub fn conic_setup1(
        this: *mut conic,
        _c_: rtd,
        _k_: rtd,
        _origin_: vector,
        _euler_angles_: vector,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5conic5setupEdd6vectorS0_S0_"]
    pub fn conic_setup2(
        this: *mut conic,
        _c_: rtd,
        _k_: rtd,
        _origin_: vector,
        _euler_angles_: vector,
        conic_origin: vector,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5conic5setupEdd6vectorS0_S0_d"]
    pub fn conic_setup3(
        this: *mut conic,
        _c_: rtd,
        _k_: rtd,
        _origin_: vector,
        _euler_angles_: vector,
        conic_origin: vector,
        _refractive_index_: rtd,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5conic5setupEdd6vectorS0_S0_diPd"]
    pub fn conic_setup4(
        this: *mut conic,
        _c_: rtd,
        _k_: rtd,
        _origin_: vector,
        _euler_angles_: vector,
        conic_origin: vector,
        _refractive_index_: rtd,
        asphere_N: ::std::os::raw::c_int,
        asphere_a: *mut rtd,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5conic7cleanupEv"]
    pub fn conic_cleanup(this: *mut conic);
}
extern "C" {
    #[link_name = "\u{1}_ZN5conic5traceEP6bundle"]
    pub fn conic_trace(this: *mut conic, src: *mut bundle);
}
extern "C" {
    #[link_name = "\u{1}_ZN5conic4infoEv"]
    pub fn conic_info(this: *mut conic);
}
impl conic {
    #[inline]
    pub unsafe fn setup(&mut self, _c_: rtd, _k_: rtd) {
        conic_setup(self, _c_, _k_)
    }
    #[inline]
    pub unsafe fn setup1(&mut self, _c_: rtd, _k_: rtd, _origin_: vector, _euler_angles_: vector) {
        conic_setup1(self, _c_, _k_, _origin_, _euler_angles_)
    }
    #[inline]
    pub unsafe fn setup2(
        &mut self,
        _c_: rtd,
        _k_: rtd,
        _origin_: vector,
        _euler_angles_: vector,
        conic_origin: vector,
    ) {
        conic_setup2(self, _c_, _k_, _origin_, _euler_angles_, conic_origin)
    }
    #[inline]
    pub unsafe fn setup3(
        &mut self,
        _c_: rtd,
        _k_: rtd,
        _origin_: vector,
        _euler_angles_: vector,
        conic_origin: vector,
        _refractive_index_: rtd,
    ) {
        conic_setup3(
            self,
            _c_,
            _k_,
            _origin_,
            _euler_angles_,
            conic_origin,
            _refractive_index_,
        )
    }
    #[inline]
    pub unsafe fn setup4(
        &mut self,
        _c_: rtd,
        _k_: rtd,
        _origin_: vector,
        _euler_angles_: vector,
        conic_origin: vector,
        _refractive_index_: rtd,
        asphere_N: ::std::os::raw::c_int,
        asphere_a: *mut rtd,
    ) {
        conic_setup4(
            self,
            _c_,
            _k_,
            _origin_,
            _euler_angles_,
            conic_origin,
            _refractive_index_,
            asphere_N,
            asphere_a,
        )
    }
    #[inline]
    pub unsafe fn cleanup(&mut self) {
        conic_cleanup(self)
    }
    #[inline]
    pub unsafe fn trace(&mut self, src: *mut bundle) {
        conic_trace(self, src)
    }
    #[inline]
    pub unsafe fn info(&mut self) {
        conic_info(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zernikeS {
    pub max_n: ::std::os::raw::c_int,
    pub j: ::std::os::raw::c_uint,
    pub n: ::std::os::raw::c_uint,
    pub m: ::std::os::raw::c_uint,
    pub n_mode: ::std::os::raw::c_uint,
    pub a: *mut rtd,
    pub d__a: *mut rtd,
    pub bx: *mut rtd,
    pub by: *mut rtd,
    pub d__bx: *mut rtd,
    pub d__by: *mut rtd,
    pub bx_row_idx: *mut ::std::os::raw::c_uint,
    pub bx_col_ptr: *mut ::std::os::raw::c_uint,
    pub by_row_idx: *mut ::std::os::raw::c_uint,
    pub by_col_ptr: *mut ::std::os::raw::c_uint,
    pub bx_nnz: ::std::os::raw::c_uint,
    pub by_nnz: ::std::os::raw::c_uint,
    pub cx: *mut rtd,
    pub d__cx: *mut rtd,
    pub cy: *mut rtd,
    pub d__cy: *mut rtd,
    pub N: ::std::os::raw::c_int,
    pub ref_frame: coordinate_system,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of zernikeS"][::std::mem::size_of::<zernikeS>() - 240usize];
    ["Alignment of zernikeS"][::std::mem::align_of::<zernikeS>() - 8usize];
    ["Offset of field: zernikeS::max_n"][::std::mem::offset_of!(zernikeS, max_n) - 0usize];
    ["Offset of field: zernikeS::j"][::std::mem::offset_of!(zernikeS, j) - 4usize];
    ["Offset of field: zernikeS::n"][::std::mem::offset_of!(zernikeS, n) - 8usize];
    ["Offset of field: zernikeS::m"][::std::mem::offset_of!(zernikeS, m) - 12usize];
    ["Offset of field: zernikeS::n_mode"][::std::mem::offset_of!(zernikeS, n_mode) - 16usize];
    ["Offset of field: zernikeS::a"][::std::mem::offset_of!(zernikeS, a) - 24usize];
    ["Offset of field: zernikeS::d__a"][::std::mem::offset_of!(zernikeS, d__a) - 32usize];
    ["Offset of field: zernikeS::bx"][::std::mem::offset_of!(zernikeS, bx) - 40usize];
    ["Offset of field: zernikeS::by"][::std::mem::offset_of!(zernikeS, by) - 48usize];
    ["Offset of field: zernikeS::d__bx"][::std::mem::offset_of!(zernikeS, d__bx) - 56usize];
    ["Offset of field: zernikeS::d__by"][::std::mem::offset_of!(zernikeS, d__by) - 64usize];
    ["Offset of field: zernikeS::bx_row_idx"]
        [::std::mem::offset_of!(zernikeS, bx_row_idx) - 72usize];
    ["Offset of field: zernikeS::bx_col_ptr"]
        [::std::mem::offset_of!(zernikeS, bx_col_ptr) - 80usize];
    ["Offset of field: zernikeS::by_row_idx"]
        [::std::mem::offset_of!(zernikeS, by_row_idx) - 88usize];
    ["Offset of field: zernikeS::by_col_ptr"]
        [::std::mem::offset_of!(zernikeS, by_col_ptr) - 96usize];
    ["Offset of field: zernikeS::bx_nnz"][::std::mem::offset_of!(zernikeS, bx_nnz) - 104usize];
    ["Offset of field: zernikeS::by_nnz"][::std::mem::offset_of!(zernikeS, by_nnz) - 108usize];
    ["Offset of field: zernikeS::cx"][::std::mem::offset_of!(zernikeS, cx) - 112usize];
    ["Offset of field: zernikeS::d__cx"][::std::mem::offset_of!(zernikeS, d__cx) - 120usize];
    ["Offset of field: zernikeS::cy"][::std::mem::offset_of!(zernikeS, cy) - 128usize];
    ["Offset of field: zernikeS::d__cy"][::std::mem::offset_of!(zernikeS, d__cy) - 136usize];
    ["Offset of field: zernikeS::N"][::std::mem::offset_of!(zernikeS, N) - 144usize];
    ["Offset of field: zernikeS::ref_frame"]
        [::std::mem::offset_of!(zernikeS, ref_frame) - 152usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN8zernikeS5setupEiPd"]
    pub fn zernikeS_setup(this: *mut zernikeS, max_n: ::std::os::raw::c_int, a: *mut rtd);
}
extern "C" {
    #[link_name = "\u{1}_ZN8zernikeS5setupEiPdi"]
    pub fn zernikeS_setup1(
        this: *mut zernikeS,
        _max_n_: ::std::os::raw::c_int,
        _a_: *mut rtd,
        _N_: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8zernikeS5setupEiPd6vectorS1_"]
    pub fn zernikeS_setup2(
        this: *mut zernikeS,
        max_n: ::std::os::raw::c_int,
        a: *mut rtd,
        _origin_: vector,
        _euler_angles_: vector,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8zernikeS5setupEiPd6vectorS1_i"]
    pub fn zernikeS_setup3(
        this: *mut zernikeS,
        max_n: ::std::os::raw::c_int,
        a: *mut rtd,
        _origin_: vector,
        _euler_angles_: vector,
        _N_: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8zernikeS7cleanupEv"]
    pub fn zernikeS_cleanup(this: *mut zernikeS);
}
extern "C" {
    #[link_name = "\u{1}_ZN8zernikeS7surfaceEPdS0_S0_i"]
    pub fn zernikeS_surface(
        this: *mut zernikeS,
        S: *mut rtd,
        r: *mut rtd,
        o: *mut rtd,
        N: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8zernikeS7surfaceEPdS0_S0_ii"]
    pub fn zernikeS_surface1(
        this: *mut zernikeS,
        S: *mut rtd,
        r: *mut rtd,
        o: *mut rtd,
        N: ::std::os::raw::c_int,
        surf_id: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8zernikeS6updateEPd"]
    pub fn zernikeS_update(this: *mut zernikeS, a: *mut rtd);
}
extern "C" {
    #[link_name = "\u{1}_ZN8zernikeS24surface_derivative_coefsEv"]
    pub fn zernikeS_surface_derivative_coefs(this: *mut zernikeS);
}
extern "C" {
    #[link_name = "\u{1}_ZN8zernikeS19surface_derivativesEPdS0_S0_S0_i"]
    pub fn zernikeS_surface_derivatives(
        this: *mut zernikeS,
        d__dSdx: *mut rtd,
        d__dSdy: *mut rtd,
        d__r: *mut rtd,
        d__o: *mut rtd,
        N: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8zernikeS23surface_and_derivativesEPdS0_S0_S0_S0_i"]
    pub fn zernikeS_surface_and_derivatives(
        this: *mut zernikeS,
        d__S: *mut rtd,
        d__dSdx: *mut rtd,
        d__dSdy: *mut rtd,
        d__r: *mut rtd,
        d__o: *mut rtd,
        N: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8zernikeS23surface_and_derivativesEPdS0_S0_S0_S0_ii"]
    pub fn zernikeS_surface_and_derivatives1(
        this: *mut zernikeS,
        d__S: *mut rtd,
        d__dSdx: *mut rtd,
        d__dSdy: *mut rtd,
        d__r: *mut rtd,
        d__o: *mut rtd,
        N: ::std::os::raw::c_int,
        surf_id: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8zernikeS10projectionEPfPdS1_i"]
    pub fn zernikeS_projection(
        this: *mut zernikeS,
        d__phase: *mut f32,
        d__r: *mut rtd,
        d__o: *mut rtd,
        N: ::std::os::raw::c_int,
    );
}
impl zernikeS {
    #[inline]
    pub unsafe fn setup(&mut self, max_n: ::std::os::raw::c_int, a: *mut rtd) {
        zernikeS_setup(self, max_n, a)
    }
    #[inline]
    pub unsafe fn setup1(
        &mut self,
        _max_n_: ::std::os::raw::c_int,
        _a_: *mut rtd,
        _N_: ::std::os::raw::c_int,
    ) {
        zernikeS_setup1(self, _max_n_, _a_, _N_)
    }
    #[inline]
    pub unsafe fn setup2(
        &mut self,
        max_n: ::std::os::raw::c_int,
        a: *mut rtd,
        _origin_: vector,
        _euler_angles_: vector,
    ) {
        zernikeS_setup2(self, max_n, a, _origin_, _euler_angles_)
    }
    #[inline]
    pub unsafe fn setup3(
        &mut self,
        max_n: ::std::os::raw::c_int,
        a: *mut rtd,
        _origin_: vector,
        _euler_angles_: vector,
        _N_: ::std::os::raw::c_int,
    ) {
        zernikeS_setup3(self, max_n, a, _origin_, _euler_angles_, _N_)
    }
    #[inline]
    pub unsafe fn cleanup(&mut self) {
        zernikeS_cleanup(self)
    }
    #[inline]
    pub unsafe fn surface(
        &mut self,
        S: *mut rtd,
        r: *mut rtd,
        o: *mut rtd,
        N: ::std::os::raw::c_int,
    ) {
        zernikeS_surface(self, S, r, o, N)
    }
    #[inline]
    pub unsafe fn surface1(
        &mut self,
        S: *mut rtd,
        r: *mut rtd,
        o: *mut rtd,
        N: ::std::os::raw::c_int,
        surf_id: ::std::os::raw::c_int,
    ) {
        zernikeS_surface1(self, S, r, o, N, surf_id)
    }
    #[inline]
    pub unsafe fn update(&mut self, a: *mut rtd) {
        zernikeS_update(self, a)
    }
    #[inline]
    pub unsafe fn surface_derivative_coefs(&mut self) {
        zernikeS_surface_derivative_coefs(self)
    }
    #[inline]
    pub unsafe fn surface_derivatives(
        &mut self,
        d__dSdx: *mut rtd,
        d__dSdy: *mut rtd,
        d__r: *mut rtd,
        d__o: *mut rtd,
        N: ::std::os::raw::c_int,
    ) {
        zernikeS_surface_derivatives(self, d__dSdx, d__dSdy, d__r, d__o, N)
    }
    #[inline]
    pub unsafe fn surface_and_derivatives(
        &mut self,
        d__S: *mut rtd,
        d__dSdx: *mut rtd,
        d__dSdy: *mut rtd,
        d__r: *mut rtd,
        d__o: *mut rtd,
        N: ::std::os::raw::c_int,
    ) {
        zernikeS_surface_and_derivatives(self, d__S, d__dSdx, d__dSdy, d__r, d__o, N)
    }
    #[inline]
    pub unsafe fn surface_and_derivatives1(
        &mut self,
        d__S: *mut rtd,
        d__dSdx: *mut rtd,
        d__dSdy: *mut rtd,
        d__r: *mut rtd,
        d__o: *mut rtd,
        N: ::std::os::raw::c_int,
        surf_id: ::std::os::raw::c_int,
    ) {
        zernikeS_surface_and_derivatives1(self, d__S, d__dSdx, d__dSdy, d__r, d__o, N, surf_id)
    }
    #[inline]
    pub unsafe fn projection(
        &mut self,
        d__phase: *mut f32,
        d__r: *mut rtd,
        d__o: *mut rtd,
        N: ::std::os::raw::c_int,
    ) {
        zernikeS_projection(self, d__phase, d__r, d__o, N)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aperture {
    pub D_px: ::std::os::raw::c_int,
    pub D: rtd,
    pub ri: rtd,
    pub D_seg: rtd,
    pub N: ::std::os::raw::c_int,
    pub V: mask,
    pub ref_frame: coordinate_system,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aperture"][::std::mem::size_of::<aperture>() - 208usize];
    ["Alignment of aperture"][::std::mem::align_of::<aperture>() - 8usize];
    ["Offset of field: aperture::D_px"][::std::mem::offset_of!(aperture, D_px) - 0usize];
    ["Offset of field: aperture::D"][::std::mem::offset_of!(aperture, D) - 8usize];
    ["Offset of field: aperture::ri"][::std::mem::offset_of!(aperture, ri) - 16usize];
    ["Offset of field: aperture::D_seg"][::std::mem::offset_of!(aperture, D_seg) - 24usize];
    ["Offset of field: aperture::N"][::std::mem::offset_of!(aperture, N) - 32usize];
    ["Offset of field: aperture::V"][::std::mem::offset_of!(aperture, V) - 40usize];
    ["Offset of field: aperture::ref_frame"]
        [::std::mem::offset_of!(aperture, ref_frame) - 120usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN8aperture5setupEdi6vectorS0_"]
    pub fn aperture_setup(
        this: *mut aperture,
        _D_: rtd,
        _D_px_: ::std::os::raw::c_int,
        _origin_: vector,
        _euler_angles_: vector,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8aperture5setupEddi6vectorS0_"]
    pub fn aperture_setup1(
        this: *mut aperture,
        _D_: rtd,
        _ri_: rtd,
        _D_px_: ::std::os::raw::c_int,
        _origin_: vector,
        _euler_angles_: vector,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8aperture5setupEdddiP6vectorS1_i"]
    pub fn aperture_setup2(
        this: *mut aperture,
        _D_: rtd,
        _ri_: rtd,
        _D_seg_: rtd,
        _D_px_: ::std::os::raw::c_int,
        _origin_: *mut vector,
        _euler_angles_: *mut vector,
        N_segment: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN8aperture12setup_GMT_M1Edi"]
    pub fn aperture_setup_GMT_M1(this: *mut aperture, _D_: rtd, _D_px_: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN8aperture7cleanupEv"]
    pub fn aperture_cleanup(this: *mut aperture);
}
extern "C" {
    #[link_name = "\u{1}_ZN8aperture10vignettingEP6bundle"]
    pub fn aperture_vignetting(this: *mut aperture, rays: *mut bundle);
}
impl aperture {
    #[inline]
    pub unsafe fn setup(
        &mut self,
        _D_: rtd,
        _D_px_: ::std::os::raw::c_int,
        _origin_: vector,
        _euler_angles_: vector,
    ) {
        aperture_setup(self, _D_, _D_px_, _origin_, _euler_angles_)
    }
    #[inline]
    pub unsafe fn setup1(
        &mut self,
        _D_: rtd,
        _ri_: rtd,
        _D_px_: ::std::os::raw::c_int,
        _origin_: vector,
        _euler_angles_: vector,
    ) {
        aperture_setup1(self, _D_, _ri_, _D_px_, _origin_, _euler_angles_)
    }
    #[inline]
    pub unsafe fn setup2(
        &mut self,
        _D_: rtd,
        _ri_: rtd,
        _D_seg_: rtd,
        _D_px_: ::std::os::raw::c_int,
        _origin_: *mut vector,
        _euler_angles_: *mut vector,
        N_segment: ::std::os::raw::c_int,
    ) {
        aperture_setup2(
            self,
            _D_,
            _ri_,
            _D_seg_,
            _D_px_,
            _origin_,
            _euler_angles_,
            N_segment,
        )
    }
    #[inline]
    pub unsafe fn setup_GMT_M1(&mut self, _D_: rtd, _D_px_: ::std::os::raw::c_int) {
        aperture_setup_GMT_M1(self, _D_, _D_px_)
    }
    #[inline]
    pub unsafe fn cleanup(&mut self) {
        aperture_cleanup(self)
    }
    #[inline]
    pub unsafe fn vignetting(&mut self, rays: *mut bundle) {
        aperture_vignetting(self, rays)
    }
}
extern "C" {
    #[link_name = "\u{1}_Z14transform_to_SP6bundleP5conic"]
    pub fn transform_to_S(rays: *mut bundle, F: *mut conic);
}
extern "C" {
    #[link_name = "\u{1}_Z14transform_to_SP6bundleP8aperture"]
    pub fn transform_to_S1(rays: *mut bundle, A: *mut aperture);
}
extern "C" {
    #[link_name = "\u{1}_Z14transform_to_RP6bundleP5conic"]
    pub fn transform_to_R(rays: *mut bundle, F: *mut conic);
}
extern "C" {
    #[link_name = "\u{1}_Z14transform_to_RP6bundleP8aperture"]
    pub fn transform_to_R1(rays: *mut bundle, A: *mut aperture);
}
extern "C" {
    #[link_name = "\u{1}_Z9intersectP6bundleP5conic"]
    pub fn intersect(rays: *mut bundle, F: *mut conic);
}
extern "C" {
    #[link_name = "\u{1}_Z7reflectP6bundle"]
    pub fn reflect(rays: *mut bundle);
}
extern "C" {
    #[link_name = "\u{1}_Z7refractP6bundled"]
    pub fn refract(rays: *mut bundle, mu: rtd);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaging {
    pub N_PX_PUPIL: ::std::os::raw::c_int,
    pub N_DFT: ::std::os::raw::c_int,
    pub N_SIDE_LENSLET: ::std::os::raw::c_int,
    pub N_LENSLET: ::std::os::raw::c_int,
    pub N_SOURCE: ::std::os::raw::c_int,
    pub N_PX_IMAGE: ::std::os::raw::c_int,
    pub N_PX_CAMERA: ::std::os::raw::c_int,
    pub N_FRAME: ::std::os::raw::c_int,
    pub BIN_IMAGE: ::std::os::raw::c_int,
    pub LOCAL_RAND_SEED: ::std::os::raw::c_int,
    pub plan: cufftHandle,
    pub N_PHOTON_PER_SECOND_PER_FRAME: f32,
    pub N_PHOTON_PER_FRAME: f32,
    pub d__wave_PUPIL: *mut float2,
    pub d__frame: *mut f32,
    pub zenith: f32,
    pub azimuth: f32,
    pub theta_x: f32,
    pub theta_y: f32,
    pub d__zenith: *mut f32,
    pub d__azimuth: *mut f32,
    pub d__theta_x: *mut f32,
    pub d__theta_y: *mut f32,
    pub pixel_scale: f32,
    pub photoelectron_gain: f32,
    pub absolute_pointing: ::std::os::raw::c_char,
    pub devStates: *mut curandState,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of imaging"][::std::mem::size_of::<imaging>() - 144usize];
    ["Alignment of imaging"][::std::mem::align_of::<imaging>() - 8usize];
    ["Offset of field: imaging::N_PX_PUPIL"][::std::mem::offset_of!(imaging, N_PX_PUPIL) - 0usize];
    ["Offset of field: imaging::N_DFT"][::std::mem::offset_of!(imaging, N_DFT) - 4usize];
    ["Offset of field: imaging::N_SIDE_LENSLET"]
        [::std::mem::offset_of!(imaging, N_SIDE_LENSLET) - 8usize];
    ["Offset of field: imaging::N_LENSLET"][::std::mem::offset_of!(imaging, N_LENSLET) - 12usize];
    ["Offset of field: imaging::N_SOURCE"][::std::mem::offset_of!(imaging, N_SOURCE) - 16usize];
    ["Offset of field: imaging::N_PX_IMAGE"][::std::mem::offset_of!(imaging, N_PX_IMAGE) - 20usize];
    ["Offset of field: imaging::N_PX_CAMERA"]
        [::std::mem::offset_of!(imaging, N_PX_CAMERA) - 24usize];
    ["Offset of field: imaging::N_FRAME"][::std::mem::offset_of!(imaging, N_FRAME) - 28usize];
    ["Offset of field: imaging::BIN_IMAGE"][::std::mem::offset_of!(imaging, BIN_IMAGE) - 32usize];
    ["Offset of field: imaging::LOCAL_RAND_SEED"]
        [::std::mem::offset_of!(imaging, LOCAL_RAND_SEED) - 36usize];
    ["Offset of field: imaging::plan"][::std::mem::offset_of!(imaging, plan) - 40usize];
    ["Offset of field: imaging::N_PHOTON_PER_SECOND_PER_FRAME"]
        [::std::mem::offset_of!(imaging, N_PHOTON_PER_SECOND_PER_FRAME) - 44usize];
    ["Offset of field: imaging::N_PHOTON_PER_FRAME"]
        [::std::mem::offset_of!(imaging, N_PHOTON_PER_FRAME) - 48usize];
    ["Offset of field: imaging::d__wave_PUPIL"]
        [::std::mem::offset_of!(imaging, d__wave_PUPIL) - 56usize];
    ["Offset of field: imaging::d__frame"][::std::mem::offset_of!(imaging, d__frame) - 64usize];
    ["Offset of field: imaging::zenith"][::std::mem::offset_of!(imaging, zenith) - 72usize];
    ["Offset of field: imaging::azimuth"][::std::mem::offset_of!(imaging, azimuth) - 76usize];
    ["Offset of field: imaging::theta_x"][::std::mem::offset_of!(imaging, theta_x) - 80usize];
    ["Offset of field: imaging::theta_y"][::std::mem::offset_of!(imaging, theta_y) - 84usize];
    ["Offset of field: imaging::d__zenith"][::std::mem::offset_of!(imaging, d__zenith) - 88usize];
    ["Offset of field: imaging::d__azimuth"][::std::mem::offset_of!(imaging, d__azimuth) - 96usize];
    ["Offset of field: imaging::d__theta_x"]
        [::std::mem::offset_of!(imaging, d__theta_x) - 104usize];
    ["Offset of field: imaging::d__theta_y"]
        [::std::mem::offset_of!(imaging, d__theta_y) - 112usize];
    ["Offset of field: imaging::pixel_scale"]
        [::std::mem::offset_of!(imaging, pixel_scale) - 120usize];
    ["Offset of field: imaging::photoelectron_gain"]
        [::std::mem::offset_of!(imaging, photoelectron_gain) - 124usize];
    ["Offset of field: imaging::absolute_pointing"]
        [::std::mem::offset_of!(imaging, absolute_pointing) - 128usize];
    ["Offset of field: imaging::devStates"][::std::mem::offset_of!(imaging, devStates) - 136usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN7imaging5setupEiiiff"]
    pub fn imaging_setup(
        this: *mut imaging,
        __N_PX_PUPIL: ::std::os::raw::c_int,
        __N_SIDE_LENSLET: ::std::os::raw::c_int,
        DFT_osf: ::std::os::raw::c_int,
        IMAGE_osf: f32,
        CAMERA_osf: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7imaging5setupEiiiffi"]
    pub fn imaging_setup1(
        this: *mut imaging,
        __N_PX_PUPIL: ::std::os::raw::c_int,
        __N_SIDE_LENSLET: ::std::os::raw::c_int,
        DFT_osf: ::std::os::raw::c_int,
        IMAGE_osf: f32,
        CAMERA_osf: f32,
        __N_SOURCE: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7imaging5setupEiiiifi"]
    pub fn imaging_setup2(
        this: *mut imaging,
        __N_PX_PUPIL: ::std::os::raw::c_int,
        __N_SIDE_LENSLET: ::std::os::raw::c_int,
        DFT_osf: ::std::os::raw::c_int,
        N_PX_IMAGE_: ::std::os::raw::c_int,
        CAMERA_osf: f32,
        __N_SOURCE: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7imaging5setupEiiiiii"]
    pub fn imaging_setup3(
        this: *mut imaging,
        __N_PX_PUPIL: ::std::os::raw::c_int,
        __N_SIDE_LENSLET: ::std::os::raw::c_int,
        DFT_osf: ::std::os::raw::c_int,
        N_PX_IMAGE_: ::std::os::raw::c_int,
        BIN_IMAGE: ::std::os::raw::c_int,
        __N_SOURCE: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7imaging24setupSegmentPistonSensorEiiiiii"]
    pub fn imaging_setupSegmentPistonSensor(
        this: *mut imaging,
        __N_PX_PUPIL: ::std::os::raw::c_int,
        __N_SIDE_LENSLET: ::std::os::raw::c_int,
        _N_DFT_: ::std::os::raw::c_int,
        N_PX_IMAGE_: ::std::os::raw::c_int,
        _BIN_IMAGE_: ::std::os::raw::c_int,
        __N_SOURCE: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7imaging7cleanupEv"]
    pub fn imaging_cleanup(this: *mut imaging);
}
extern "C" {
    #[link_name = "\u{1}_ZN7imaging26cleanupSegmentPistonSensorEv"]
    pub fn imaging_cleanupSegmentPistonSensor(this: *mut imaging);
}
extern "C" {
    #[link_name = "\u{1}_ZN7imaging22set_pointing_directionEPfS0_"]
    pub fn imaging_set_pointing_direction(this: *mut imaging, zen: *mut f32, azim: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN7imaging5resetEv"]
    pub fn imaging_reset(this: *mut imaging);
}
extern "C" {
    #[link_name = "\u{1}_ZN7imaging9reset_rngEi"]
    pub fn imaging_reset_rng(this: *mut imaging, SEED: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN7imaging9propagateEP6source"]
    pub fn imaging_propagate(this: *mut imaging, src: *mut source);
}
extern "C" {
    #[link_name = "\u{1}_ZN7imaging13propagate_cpxEP6source"]
    pub fn imaging_propagate_cpx(this: *mut imaging, src: *mut source);
}
extern "C" {
    #[link_name = "\u{1}_ZN7imaging18propagateNoOverlapEP6source"]
    pub fn imaging_propagateNoOverlap(this: *mut imaging, src: *mut source);
}
extern "C" {
    #[link_name = "\u{1}_ZN7imaging22propagateNoOverlapBareEP6source"]
    pub fn imaging_propagateNoOverlapBare(this: *mut imaging, src: *mut source);
}
extern "C" {
    #[link_name = "\u{1}_ZN7imaging21propagateNoOverlapSPSEP6sourceff"]
    pub fn imaging_propagateNoOverlapSPS(
        this: *mut imaging,
        src: *mut source,
        d: f32,
        wavenumber: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7imaging12propagateTT7EP6source"]
    pub fn imaging_propagateTT7(this: *mut imaging, src: *mut source);
}
extern "C" {
    #[link_name = "\u{1}_ZN7imaging12propagateTT7EP6sourcePi"]
    pub fn imaging_propagateTT71(
        this: *mut imaging,
        src: *mut source,
        d__piston_mask: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7imaging25propagateThroughFieldStopEP6sourcef"]
    pub fn imaging_propagateThroughFieldStop(
        this: *mut imaging,
        src: *mut source,
        field_stop_diam: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7imaging23propagateThroughPyramidEP6sourcef"]
    pub fn imaging_propagateThroughPyramid(this: *mut imaging, src: *mut source, alpha: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN7imaging32propagateThroughModulatedPyramidEP6sourcefif"]
    pub fn imaging_propagateThroughModulatedPyramid(
        this: *mut imaging,
        src: *mut source,
        modulation: f32,
        modulation_sampling: ::std::os::raw::c_int,
        alpha: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7imaging7readoutEff"]
    pub fn imaging_readout(this: *mut imaging, exposureTime: f32, readOutNoiseRms: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN7imaging17noiseless_readoutEf"]
    pub fn imaging_noiseless_readout(this: *mut imaging, exposureTime: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN7imaging7readoutEffff"]
    pub fn imaging_readout1(
        this: *mut imaging,
        exposureTime: f32,
        readOutNoiseRms: f32,
        nBackgroundPhoton: f32,
        noiseFactor: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7imaging12strehl_ratioEPS_"]
    pub fn imaging_strehl_ratio(this: *mut imaging, ref_: *mut imaging) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN7imaging4infoEv"]
    pub fn imaging_info(this: *mut imaging);
}
extern "C" {
    #[link_name = "\u{1}_ZN7imaging10frame2fileEPKc"]
    pub fn imaging_frame2file(this: *mut imaging, filename: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_ZN7imaging10show_frameEPc"]
    pub fn imaging_show_frame(this: *mut imaging, filename: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_ZN7imaging10show_frameEPcPS_"]
    pub fn imaging_show_frame1(
        this: *mut imaging,
        filename: *mut ::std::os::raw::c_char,
        ref_: *mut imaging,
    );
}
impl imaging {
    #[inline]
    pub unsafe fn setup(
        &mut self,
        __N_PX_PUPIL: ::std::os::raw::c_int,
        __N_SIDE_LENSLET: ::std::os::raw::c_int,
        DFT_osf: ::std::os::raw::c_int,
        IMAGE_osf: f32,
        CAMERA_osf: f32,
    ) {
        imaging_setup(
            self,
            __N_PX_PUPIL,
            __N_SIDE_LENSLET,
            DFT_osf,
            IMAGE_osf,
            CAMERA_osf,
        )
    }
    #[inline]
    pub unsafe fn setup1(
        &mut self,
        __N_PX_PUPIL: ::std::os::raw::c_int,
        __N_SIDE_LENSLET: ::std::os::raw::c_int,
        DFT_osf: ::std::os::raw::c_int,
        IMAGE_osf: f32,
        CAMERA_osf: f32,
        __N_SOURCE: ::std::os::raw::c_int,
    ) {
        imaging_setup1(
            self,
            __N_PX_PUPIL,
            __N_SIDE_LENSLET,
            DFT_osf,
            IMAGE_osf,
            CAMERA_osf,
            __N_SOURCE,
        )
    }
    #[inline]
    pub unsafe fn setup2(
        &mut self,
        __N_PX_PUPIL: ::std::os::raw::c_int,
        __N_SIDE_LENSLET: ::std::os::raw::c_int,
        DFT_osf: ::std::os::raw::c_int,
        N_PX_IMAGE_: ::std::os::raw::c_int,
        CAMERA_osf: f32,
        __N_SOURCE: ::std::os::raw::c_int,
    ) {
        imaging_setup2(
            self,
            __N_PX_PUPIL,
            __N_SIDE_LENSLET,
            DFT_osf,
            N_PX_IMAGE_,
            CAMERA_osf,
            __N_SOURCE,
        )
    }
    #[inline]
    pub unsafe fn setup3(
        &mut self,
        __N_PX_PUPIL: ::std::os::raw::c_int,
        __N_SIDE_LENSLET: ::std::os::raw::c_int,
        DFT_osf: ::std::os::raw::c_int,
        N_PX_IMAGE_: ::std::os::raw::c_int,
        BIN_IMAGE: ::std::os::raw::c_int,
        __N_SOURCE: ::std::os::raw::c_int,
    ) {
        imaging_setup3(
            self,
            __N_PX_PUPIL,
            __N_SIDE_LENSLET,
            DFT_osf,
            N_PX_IMAGE_,
            BIN_IMAGE,
            __N_SOURCE,
        )
    }
    #[inline]
    pub unsafe fn setupSegmentPistonSensor(
        &mut self,
        __N_PX_PUPIL: ::std::os::raw::c_int,
        __N_SIDE_LENSLET: ::std::os::raw::c_int,
        _N_DFT_: ::std::os::raw::c_int,
        N_PX_IMAGE_: ::std::os::raw::c_int,
        _BIN_IMAGE_: ::std::os::raw::c_int,
        __N_SOURCE: ::std::os::raw::c_int,
    ) {
        imaging_setupSegmentPistonSensor(
            self,
            __N_PX_PUPIL,
            __N_SIDE_LENSLET,
            _N_DFT_,
            N_PX_IMAGE_,
            _BIN_IMAGE_,
            __N_SOURCE,
        )
    }
    #[inline]
    pub unsafe fn cleanup(&mut self) {
        imaging_cleanup(self)
    }
    #[inline]
    pub unsafe fn cleanupSegmentPistonSensor(&mut self) {
        imaging_cleanupSegmentPistonSensor(self)
    }
    #[inline]
    pub unsafe fn set_pointing_direction(&mut self, zen: *mut f32, azim: *mut f32) {
        imaging_set_pointing_direction(self, zen, azim)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        imaging_reset(self)
    }
    #[inline]
    pub unsafe fn reset_rng(&mut self, SEED: ::std::os::raw::c_int) {
        imaging_reset_rng(self, SEED)
    }
    #[inline]
    pub unsafe fn propagate(&mut self, src: *mut source) {
        imaging_propagate(self, src)
    }
    #[inline]
    pub unsafe fn propagate_cpx(&mut self, src: *mut source) {
        imaging_propagate_cpx(self, src)
    }
    #[inline]
    pub unsafe fn propagateNoOverlap(&mut self, src: *mut source) {
        imaging_propagateNoOverlap(self, src)
    }
    #[inline]
    pub unsafe fn propagateNoOverlapBare(&mut self, src: *mut source) {
        imaging_propagateNoOverlapBare(self, src)
    }
    #[inline]
    pub unsafe fn propagateNoOverlapSPS(&mut self, src: *mut source, d: f32, wavenumber: f32) {
        imaging_propagateNoOverlapSPS(self, src, d, wavenumber)
    }
    #[inline]
    pub unsafe fn propagateTT7(&mut self, src: *mut source) {
        imaging_propagateTT7(self, src)
    }
    #[inline]
    pub unsafe fn propagateTT71(
        &mut self,
        src: *mut source,
        d__piston_mask: *mut ::std::os::raw::c_int,
    ) {
        imaging_propagateTT71(self, src, d__piston_mask)
    }
    #[inline]
    pub unsafe fn propagateThroughFieldStop(&mut self, src: *mut source, field_stop_diam: f32) {
        imaging_propagateThroughFieldStop(self, src, field_stop_diam)
    }
    #[inline]
    pub unsafe fn propagateThroughPyramid(&mut self, src: *mut source, alpha: f32) {
        imaging_propagateThroughPyramid(self, src, alpha)
    }
    #[inline]
    pub unsafe fn propagateThroughModulatedPyramid(
        &mut self,
        src: *mut source,
        modulation: f32,
        modulation_sampling: ::std::os::raw::c_int,
        alpha: f32,
    ) {
        imaging_propagateThroughModulatedPyramid(self, src, modulation, modulation_sampling, alpha)
    }
    #[inline]
    pub unsafe fn readout(&mut self, exposureTime: f32, readOutNoiseRms: f32) {
        imaging_readout(self, exposureTime, readOutNoiseRms)
    }
    #[inline]
    pub unsafe fn noiseless_readout(&mut self, exposureTime: f32) {
        imaging_noiseless_readout(self, exposureTime)
    }
    #[inline]
    pub unsafe fn readout1(
        &mut self,
        exposureTime: f32,
        readOutNoiseRms: f32,
        nBackgroundPhoton: f32,
        noiseFactor: f32,
    ) {
        imaging_readout1(
            self,
            exposureTime,
            readOutNoiseRms,
            nBackgroundPhoton,
            noiseFactor,
        )
    }
    #[inline]
    pub unsafe fn strehl_ratio(&mut self, ref_: *mut imaging) -> f32 {
        imaging_strehl_ratio(self, ref_)
    }
    #[inline]
    pub unsafe fn info(&mut self) {
        imaging_info(self)
    }
    #[inline]
    pub unsafe fn frame2file(&mut self, filename: *const ::std::os::raw::c_char) {
        imaging_frame2file(self, filename)
    }
    #[inline]
    pub unsafe fn show_frame(&mut self, filename: *mut ::std::os::raw::c_char) {
        imaging_show_frame(self, filename)
    }
    #[inline]
    pub unsafe fn show_frame1(
        &mut self,
        filename: *mut ::std::os::raw::c_char,
        ref_: *mut imaging,
    ) {
        imaging_show_frame1(self, filename, ref_)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct centroiding {
    pub _N_SIDE_LENSLET_: ::std::os::raw::c_int,
    pub N_LENSLET: ::std::os::raw::c_int,
    pub N_SOURCE: ::std::os::raw::c_int,
    pub d__c: *mut f32,
    pub d__cx: *mut f32,
    pub d__cy: *mut f32,
    pub d__mass: *mut f32,
    pub lenslet_mask: *mut ::std::os::raw::c_char,
    pub MASK_SET: ::std::os::raw::c_char,
    pub n_data: ::std::os::raw::c_int,
    pub DEV_SHARED_MEM: ::std::os::raw::c_int,
    pub DEV_MAX_THREADS: ::std::os::raw::c_int,
    pub handle: cublasHandle_t,
    pub status: cublasStatus_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of centroiding"][::std::mem::size_of::<centroiding>() - 88usize];
    ["Alignment of centroiding"][::std::mem::align_of::<centroiding>() - 8usize];
    ["Offset of field: centroiding::_N_SIDE_LENSLET_"]
        [::std::mem::offset_of!(centroiding, _N_SIDE_LENSLET_) - 0usize];
    ["Offset of field: centroiding::N_LENSLET"]
        [::std::mem::offset_of!(centroiding, N_LENSLET) - 4usize];
    ["Offset of field: centroiding::N_SOURCE"]
        [::std::mem::offset_of!(centroiding, N_SOURCE) - 8usize];
    ["Offset of field: centroiding::d__c"][::std::mem::offset_of!(centroiding, d__c) - 16usize];
    ["Offset of field: centroiding::d__cx"][::std::mem::offset_of!(centroiding, d__cx) - 24usize];
    ["Offset of field: centroiding::d__cy"][::std::mem::offset_of!(centroiding, d__cy) - 32usize];
    ["Offset of field: centroiding::d__mass"]
        [::std::mem::offset_of!(centroiding, d__mass) - 40usize];
    ["Offset of field: centroiding::lenslet_mask"]
        [::std::mem::offset_of!(centroiding, lenslet_mask) - 48usize];
    ["Offset of field: centroiding::MASK_SET"]
        [::std::mem::offset_of!(centroiding, MASK_SET) - 56usize];
    ["Offset of field: centroiding::n_data"][::std::mem::offset_of!(centroiding, n_data) - 60usize];
    ["Offset of field: centroiding::DEV_SHARED_MEM"]
        [::std::mem::offset_of!(centroiding, DEV_SHARED_MEM) - 64usize];
    ["Offset of field: centroiding::DEV_MAX_THREADS"]
        [::std::mem::offset_of!(centroiding, DEV_MAX_THREADS) - 68usize];
    ["Offset of field: centroiding::handle"][::std::mem::offset_of!(centroiding, handle) - 72usize];
    ["Offset of field: centroiding::status"][::std::mem::offset_of!(centroiding, status) - 80usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN11centroiding5setupEii"]
    pub fn centroiding_setup(
        this: *mut centroiding,
        _N_SIDE_LENSLET: ::std::os::raw::c_int,
        _N_SOURCE: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11centroiding7cleanupEv"]
    pub fn centroiding_cleanup(this: *mut centroiding);
}
extern "C" {
    #[link_name = "\u{1}_ZN11centroiding8get_dataEP7imaging"]
    pub fn centroiding_get_data(this: *mut centroiding, wfs: *mut imaging);
}
extern "C" {
    #[link_name = "\u{1}_ZN11centroiding8get_dataEPfi"]
    pub fn centroiding_get_data1(this: *mut centroiding, frame: *mut f32, N: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN11centroiding8get_dataEPfifff"]
    pub fn centroiding_get_data2(
        this: *mut centroiding,
        frame: *mut f32,
        N: ::std::os::raw::c_int,
        cx0: f32,
        cy0: f32,
        units: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11centroiding8get_dataEPfiS0_S0_fPc"]
    pub fn centroiding_get_data3(
        this: *mut centroiding,
        frame: *mut f32,
        N: ::std::os::raw::c_int,
        cx0: *mut f32,
        cy0: *mut f32,
        units: f32,
        valid_lenset: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11centroiding14show_centroidsEPc"]
    pub fn centroiding_show_centroids(
        this: *mut centroiding,
        filename: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11centroiding9show_fluxEPc"]
    pub fn centroiding_show_flux(this: *mut centroiding, filename: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_ZN11centroiding14fried_geometryEP4maskS1_if"]
    pub fn centroiding_fried_geometry(
        this: *mut centroiding,
        dm: *mut mask,
        pupil: *mut mask,
        n: ::std::os::raw::c_int,
        threshold: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN11centroiding6filterEPf"]
    pub fn centroiding_filter(this: *mut centroiding, F: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN11centroiding7noisifyEf"]
    pub fn centroiding_noisify(this: *mut centroiding, stddev: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN11centroiding5resetEv"]
    pub fn centroiding_reset(this: *mut centroiding);
}
impl centroiding {
    #[inline]
    pub unsafe fn setup(
        &mut self,
        _N_SIDE_LENSLET: ::std::os::raw::c_int,
        _N_SOURCE: ::std::os::raw::c_int,
    ) {
        centroiding_setup(self, _N_SIDE_LENSLET, _N_SOURCE)
    }
    #[inline]
    pub unsafe fn cleanup(&mut self) {
        centroiding_cleanup(self)
    }
    #[inline]
    pub unsafe fn get_data(&mut self, wfs: *mut imaging) {
        centroiding_get_data(self, wfs)
    }
    #[inline]
    pub unsafe fn get_data1(&mut self, frame: *mut f32, N: ::std::os::raw::c_int) {
        centroiding_get_data1(self, frame, N)
    }
    #[inline]
    pub unsafe fn get_data2(
        &mut self,
        frame: *mut f32,
        N: ::std::os::raw::c_int,
        cx0: f32,
        cy0: f32,
        units: f32,
    ) {
        centroiding_get_data2(self, frame, N, cx0, cy0, units)
    }
    #[inline]
    pub unsafe fn get_data3(
        &mut self,
        frame: *mut f32,
        N: ::std::os::raw::c_int,
        cx0: *mut f32,
        cy0: *mut f32,
        units: f32,
        valid_lenset: *mut ::std::os::raw::c_char,
    ) {
        centroiding_get_data3(self, frame, N, cx0, cy0, units, valid_lenset)
    }
    #[inline]
    pub unsafe fn show_centroids(&mut self, filename: *mut ::std::os::raw::c_char) {
        centroiding_show_centroids(self, filename)
    }
    #[inline]
    pub unsafe fn show_flux(&mut self, filename: *mut ::std::os::raw::c_char) {
        centroiding_show_flux(self, filename)
    }
    #[inline]
    pub unsafe fn fried_geometry(
        &mut self,
        dm: *mut mask,
        pupil: *mut mask,
        n: ::std::os::raw::c_int,
        threshold: f32,
    ) {
        centroiding_fried_geometry(self, dm, pupil, n, threshold)
    }
    #[inline]
    pub unsafe fn filter(&mut self, F: *mut f32) {
        centroiding_filter(self, F)
    }
    #[inline]
    pub unsafe fn noisify(&mut self, stddev: f32) {
        centroiding_noisify(self, stddev)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        centroiding_reset(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shackHartmann {
    pub N_WFS: ::std::os::raw::c_int,
    pub N_SIDE_LENSLET: ::std::os::raw::c_int,
    pub N_LENSLET: ::std::os::raw::c_int,
    pub N_ACTUATOR: ::std::os::raw::c_int,
    pub N_SLOPE: ::std::os::raw::c_int,
    pub d__c0: *mut f32,
    pub d__cx0: *mut f32,
    pub d__cy0: *mut f32,
    pub valid_lenslet: mask,
    pub valid_actuator: mask,
    pub camera: imaging,
    pub data_proc: centroiding,
    pub DFT_osf: ::std::os::raw::c_int,
    pub lenslet_pitch: f32,
    pub pixel_scale: f32,
    pub intensity_threshold: f32,
    pub slopes_gain: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of shackHartmann"][::std::mem::size_of::<shackHartmann>() - 464usize];
    ["Alignment of shackHartmann"][::std::mem::align_of::<shackHartmann>() - 8usize];
    ["Offset of field: shackHartmann::N_WFS"]
        [::std::mem::offset_of!(shackHartmann, N_WFS) - 0usize];
    ["Offset of field: shackHartmann::N_SIDE_LENSLET"]
        [::std::mem::offset_of!(shackHartmann, N_SIDE_LENSLET) - 4usize];
    ["Offset of field: shackHartmann::N_LENSLET"]
        [::std::mem::offset_of!(shackHartmann, N_LENSLET) - 8usize];
    ["Offset of field: shackHartmann::N_ACTUATOR"]
        [::std::mem::offset_of!(shackHartmann, N_ACTUATOR) - 12usize];
    ["Offset of field: shackHartmann::N_SLOPE"]
        [::std::mem::offset_of!(shackHartmann, N_SLOPE) - 16usize];
    ["Offset of field: shackHartmann::d__c0"]
        [::std::mem::offset_of!(shackHartmann, d__c0) - 24usize];
    ["Offset of field: shackHartmann::d__cx0"]
        [::std::mem::offset_of!(shackHartmann, d__cx0) - 32usize];
    ["Offset of field: shackHartmann::d__cy0"]
        [::std::mem::offset_of!(shackHartmann, d__cy0) - 40usize];
    ["Offset of field: shackHartmann::valid_lenslet"]
        [::std::mem::offset_of!(shackHartmann, valid_lenslet) - 48usize];
    ["Offset of field: shackHartmann::valid_actuator"]
        [::std::mem::offset_of!(shackHartmann, valid_actuator) - 128usize];
    ["Offset of field: shackHartmann::camera"]
        [::std::mem::offset_of!(shackHartmann, camera) - 208usize];
    ["Offset of field: shackHartmann::data_proc"]
        [::std::mem::offset_of!(shackHartmann, data_proc) - 352usize];
    ["Offset of field: shackHartmann::DFT_osf"]
        [::std::mem::offset_of!(shackHartmann, DFT_osf) - 440usize];
    ["Offset of field: shackHartmann::lenslet_pitch"]
        [::std::mem::offset_of!(shackHartmann, lenslet_pitch) - 444usize];
    ["Offset of field: shackHartmann::pixel_scale"]
        [::std::mem::offset_of!(shackHartmann, pixel_scale) - 448usize];
    ["Offset of field: shackHartmann::intensity_threshold"]
        [::std::mem::offset_of!(shackHartmann, intensity_threshold) - 452usize];
    ["Offset of field: shackHartmann::slopes_gain"]
        [::std::mem::offset_of!(shackHartmann, slopes_gain) - 456usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN13shackHartmann5setupEiifiiii"]
    pub fn shackHartmann_setup(
        this: *mut shackHartmann,
        N_SIDE_LENSLET: ::std::os::raw::c_int,
        N_PX_LENSLET: ::std::os::raw::c_int,
        d: f32,
        DFT_osf_: ::std::os::raw::c_int,
        N_PX_IMAGE: ::std::os::raw::c_int,
        BIN_IMAGE: ::std::os::raw::c_int,
        N_GS: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13shackHartmann7cleanupEv"]
    pub fn shackHartmann_cleanup(this: *mut shackHartmann);
}
extern "C" {
    #[link_name = "\u{1}_ZN13shackHartmann22identify_valid_lensletEP6sourcef"]
    pub fn shackHartmann_identify_valid_lenslet(
        this: *mut shackHartmann,
        src: *mut source,
        threshold: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13shackHartmann20set_reference_slopesEP6source"]
    pub fn shackHartmann_set_reference_slopes(this: *mut shackHartmann, src: *mut source);
}
extern "C" {
    #[link_name = "\u{1}_ZN13shackHartmann9calibrateEP6sourcef"]
    pub fn shackHartmann_calibrate(this: *mut shackHartmann, src: *mut source, threshold: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN13shackHartmann9propagateEP6source"]
    pub fn shackHartmann_propagate(this: *mut shackHartmann, gs: *mut source);
}
extern "C" {
    #[link_name = "\u{1}_ZN13shackHartmann9propagateEP6sourcePi"]
    pub fn shackHartmann_propagate1(
        this: *mut shackHartmann,
        gs: *mut source,
        maks: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13shackHartmann7processEv"]
    pub fn shackHartmann_process(this: *mut shackHartmann);
}
extern "C" {
    #[link_name = "\u{1}_ZN13shackHartmann7analyzeEP6source"]
    pub fn shackHartmann_analyze(this: *mut shackHartmann, gs: *mut source);
}
extern "C" {
    #[link_name = "\u{1}_ZN13shackHartmann26get_valid_reference_slopesEPf"]
    pub fn shackHartmann_get_valid_reference_slopes(
        this: *mut shackHartmann,
        d__valid_slopes: *mut f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13shackHartmann16get_valid_slopesEPf"]
    pub fn shackHartmann_get_valid_slopes(this: *mut shackHartmann, d__valid_slopes: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN13shackHartmann13masked_slopesEPfP4mask"]
    pub fn shackHartmann_masked_slopes(
        this: *mut shackHartmann,
        d__valid_slopes: *mut f32,
        lenslet_mask: *mut mask,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13shackHartmann21get_valid_slopes_normEPf"]
    pub fn shackHartmann_get_valid_slopes_norm(
        this: *mut shackHartmann,
        d__valid_slopes_norm: *mut f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN13shackHartmann17get_frame_dev_ptrEv"]
    pub fn shackHartmann_get_frame_dev_ptr(this: *mut shackHartmann) -> *mut f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN13shackHartmann14update_lensletEPf"]
    pub fn shackHartmann_update_lenslet(this: *mut shackHartmann, filter: *mut f32);
}
impl shackHartmann {
    #[inline]
    pub unsafe fn setup(
        &mut self,
        N_SIDE_LENSLET: ::std::os::raw::c_int,
        N_PX_LENSLET: ::std::os::raw::c_int,
        d: f32,
        DFT_osf_: ::std::os::raw::c_int,
        N_PX_IMAGE: ::std::os::raw::c_int,
        BIN_IMAGE: ::std::os::raw::c_int,
        N_GS: ::std::os::raw::c_int,
    ) {
        shackHartmann_setup(
            self,
            N_SIDE_LENSLET,
            N_PX_LENSLET,
            d,
            DFT_osf_,
            N_PX_IMAGE,
            BIN_IMAGE,
            N_GS,
        )
    }
    #[inline]
    pub unsafe fn cleanup(&mut self) {
        shackHartmann_cleanup(self)
    }
    #[inline]
    pub unsafe fn identify_valid_lenslet(&mut self, src: *mut source, threshold: f32) {
        shackHartmann_identify_valid_lenslet(self, src, threshold)
    }
    #[inline]
    pub unsafe fn set_reference_slopes(&mut self, src: *mut source) {
        shackHartmann_set_reference_slopes(self, src)
    }
    #[inline]
    pub unsafe fn calibrate(&mut self, src: *mut source, threshold: f32) {
        shackHartmann_calibrate(self, src, threshold)
    }
    #[inline]
    pub unsafe fn propagate(&mut self, gs: *mut source) {
        shackHartmann_propagate(self, gs)
    }
    #[inline]
    pub unsafe fn propagate1(&mut self, gs: *mut source, maks: *mut ::std::os::raw::c_int) {
        shackHartmann_propagate1(self, gs, maks)
    }
    #[inline]
    pub unsafe fn process(&mut self) {
        shackHartmann_process(self)
    }
    #[inline]
    pub unsafe fn analyze(&mut self, gs: *mut source) {
        shackHartmann_analyze(self, gs)
    }
    #[inline]
    pub unsafe fn get_valid_reference_slopes(&mut self, d__valid_slopes: *mut f32) {
        shackHartmann_get_valid_reference_slopes(self, d__valid_slopes)
    }
    #[inline]
    pub unsafe fn get_valid_slopes(&mut self, d__valid_slopes: *mut f32) {
        shackHartmann_get_valid_slopes(self, d__valid_slopes)
    }
    #[inline]
    pub unsafe fn masked_slopes(&mut self, d__valid_slopes: *mut f32, lenslet_mask: *mut mask) {
        shackHartmann_masked_slopes(self, d__valid_slopes, lenslet_mask)
    }
    #[inline]
    pub unsafe fn get_valid_slopes_norm(&mut self, d__valid_slopes_norm: *mut f32) {
        shackHartmann_get_valid_slopes_norm(self, d__valid_slopes_norm)
    }
    #[inline]
    pub unsafe fn get_frame_dev_ptr(&mut self) -> *mut f32 {
        shackHartmann_get_frame_dev_ptr(self)
    }
    #[inline]
    pub unsafe fn update_lenslet(&mut self, filter: *mut f32) {
        shackHartmann_update_lenslet(self, filter)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometricShackHartmann {
    pub N_WFS: ::std::os::raw::c_int,
    pub N_SIDE_LENSLET: ::std::os::raw::c_int,
    pub N_LENSLET: ::std::os::raw::c_int,
    pub N_ACTUATOR: ::std::os::raw::c_int,
    pub N_SLOPE: ::std::os::raw::c_int,
    pub d__c0: *mut f32,
    pub d__cx0: *mut f32,
    pub d__cy0: *mut f32,
    pub valid_lenslet: mask,
    pub valid_actuator: mask,
    pub camera: imaging,
    pub data_proc: centroiding,
    pub DFT_osf: ::std::os::raw::c_int,
    pub lenslet_pitch: f32,
    pub pixel_scale: f32,
    pub intensity_threshold: f32,
    pub slopes_gain: f32,
    pub _d__c_: *mut f32,
    pub _d__cx_: *mut f32,
    pub _d__cy_: *mut f32,
    pub N_FRAME: ::std::os::raw::c_int,
    pub handle: cublasHandle_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of geometricShackHartmann"][::std::mem::size_of::<geometricShackHartmann>() - 504usize];
    ["Alignment of geometricShackHartmann"]
        [::std::mem::align_of::<geometricShackHartmann>() - 8usize];
    ["Offset of field: geometricShackHartmann::N_WFS"]
        [::std::mem::offset_of!(geometricShackHartmann, N_WFS) - 0usize];
    ["Offset of field: geometricShackHartmann::N_SIDE_LENSLET"]
        [::std::mem::offset_of!(geometricShackHartmann, N_SIDE_LENSLET) - 4usize];
    ["Offset of field: geometricShackHartmann::N_LENSLET"]
        [::std::mem::offset_of!(geometricShackHartmann, N_LENSLET) - 8usize];
    ["Offset of field: geometricShackHartmann::N_ACTUATOR"]
        [::std::mem::offset_of!(geometricShackHartmann, N_ACTUATOR) - 12usize];
    ["Offset of field: geometricShackHartmann::N_SLOPE"]
        [::std::mem::offset_of!(geometricShackHartmann, N_SLOPE) - 16usize];
    ["Offset of field: geometricShackHartmann::d__c0"]
        [::std::mem::offset_of!(geometricShackHartmann, d__c0) - 24usize];
    ["Offset of field: geometricShackHartmann::d__cx0"]
        [::std::mem::offset_of!(geometricShackHartmann, d__cx0) - 32usize];
    ["Offset of field: geometricShackHartmann::d__cy0"]
        [::std::mem::offset_of!(geometricShackHartmann, d__cy0) - 40usize];
    ["Offset of field: geometricShackHartmann::valid_lenslet"]
        [::std::mem::offset_of!(geometricShackHartmann, valid_lenslet) - 48usize];
    ["Offset of field: geometricShackHartmann::valid_actuator"]
        [::std::mem::offset_of!(geometricShackHartmann, valid_actuator) - 128usize];
    ["Offset of field: geometricShackHartmann::camera"]
        [::std::mem::offset_of!(geometricShackHartmann, camera) - 208usize];
    ["Offset of field: geometricShackHartmann::data_proc"]
        [::std::mem::offset_of!(geometricShackHartmann, data_proc) - 352usize];
    ["Offset of field: geometricShackHartmann::DFT_osf"]
        [::std::mem::offset_of!(geometricShackHartmann, DFT_osf) - 440usize];
    ["Offset of field: geometricShackHartmann::lenslet_pitch"]
        [::std::mem::offset_of!(geometricShackHartmann, lenslet_pitch) - 444usize];
    ["Offset of field: geometricShackHartmann::pixel_scale"]
        [::std::mem::offset_of!(geometricShackHartmann, pixel_scale) - 448usize];
    ["Offset of field: geometricShackHartmann::intensity_threshold"]
        [::std::mem::offset_of!(geometricShackHartmann, intensity_threshold) - 452usize];
    ["Offset of field: geometricShackHartmann::slopes_gain"]
        [::std::mem::offset_of!(geometricShackHartmann, slopes_gain) - 456usize];
    ["Offset of field: geometricShackHartmann::_d__c_"]
        [::std::mem::offset_of!(geometricShackHartmann, _d__c_) - 464usize];
    ["Offset of field: geometricShackHartmann::_d__cx_"]
        [::std::mem::offset_of!(geometricShackHartmann, _d__cx_) - 472usize];
    ["Offset of field: geometricShackHartmann::_d__cy_"]
        [::std::mem::offset_of!(geometricShackHartmann, _d__cy_) - 480usize];
    ["Offset of field: geometricShackHartmann::N_FRAME"]
        [::std::mem::offset_of!(geometricShackHartmann, N_FRAME) - 488usize];
    ["Offset of field: geometricShackHartmann::handle"]
        [::std::mem::offset_of!(geometricShackHartmann, handle) - 496usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN22geometricShackHartmann5setupEifi"]
    pub fn geometricShackHartmann_setup(
        this: *mut geometricShackHartmann,
        N_SIDE_LENSLET: ::std::os::raw::c_int,
        d: f32,
        N_GS: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22geometricShackHartmann7cleanupEv"]
    pub fn geometricShackHartmann_cleanup(this: *mut geometricShackHartmann);
}
extern "C" {
    #[link_name = "\u{1}_ZN22geometricShackHartmann22identify_valid_lensletEP6sourcef"]
    pub fn geometricShackHartmann_identify_valid_lenslet(
        this: *mut geometricShackHartmann,
        src: *mut source,
        threshold: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22geometricShackHartmann20set_reference_slopesEP6source"]
    pub fn geometricShackHartmann_set_reference_slopes(
        this: *mut geometricShackHartmann,
        src: *mut source,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22geometricShackHartmann9calibrateEP6sourcef"]
    pub fn geometricShackHartmann_calibrate(
        this: *mut geometricShackHartmann,
        src: *mut source,
        threshold: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22geometricShackHartmann9propagateEP6source"]
    pub fn geometricShackHartmann_propagate(this: *mut geometricShackHartmann, gs: *mut source);
}
extern "C" {
    #[link_name = "\u{1}_ZN22geometricShackHartmann9propagateEP6sourcePi"]
    pub fn geometricShackHartmann_propagate1(
        this: *mut geometricShackHartmann,
        gs: *mut source,
        maks: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22geometricShackHartmann7processEv"]
    pub fn geometricShackHartmann_process(this: *mut geometricShackHartmann);
}
extern "C" {
    #[link_name = "\u{1}_ZN22geometricShackHartmann7analyzeEP6source"]
    pub fn geometricShackHartmann_analyze(this: *mut geometricShackHartmann, gs: *mut source);
}
extern "C" {
    #[link_name = "\u{1}_ZN22geometricShackHartmann26get_valid_reference_slopesEPf"]
    pub fn geometricShackHartmann_get_valid_reference_slopes(
        this: *mut geometricShackHartmann,
        d__valid_slopes: *mut f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22geometricShackHartmann16get_valid_slopesEPf"]
    pub fn geometricShackHartmann_get_valid_slopes(
        this: *mut geometricShackHartmann,
        d__valid_slopes: *mut f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22geometricShackHartmann13masked_slopesEPfP4mask"]
    pub fn geometricShackHartmann_masked_slopes(
        this: *mut geometricShackHartmann,
        d__valid_slopes: *mut f32,
        lenslet_mask: *mut mask,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22geometricShackHartmann21get_valid_slopes_normEPf"]
    pub fn geometricShackHartmann_get_valid_slopes_norm(
        this: *mut geometricShackHartmann,
        d__valid_slopes_norm: *mut f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22geometricShackHartmann13folded_slopesEPfP4mask"]
    pub fn geometricShackHartmann_folded_slopes(
        this: *mut geometricShackHartmann,
        d__valid_slopes: *mut f32,
        lenslet_mask: *mut mask,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN22geometricShackHartmann5resetEv"]
    pub fn geometricShackHartmann_reset(this: *mut geometricShackHartmann);
}
impl geometricShackHartmann {
    #[inline]
    pub unsafe fn setup(
        &mut self,
        N_SIDE_LENSLET: ::std::os::raw::c_int,
        d: f32,
        N_GS: ::std::os::raw::c_int,
    ) {
        geometricShackHartmann_setup(self, N_SIDE_LENSLET, d, N_GS)
    }
    #[inline]
    pub unsafe fn cleanup(&mut self) {
        geometricShackHartmann_cleanup(self)
    }
    #[inline]
    pub unsafe fn identify_valid_lenslet(&mut self, src: *mut source, threshold: f32) {
        geometricShackHartmann_identify_valid_lenslet(self, src, threshold)
    }
    #[inline]
    pub unsafe fn set_reference_slopes(&mut self, src: *mut source) {
        geometricShackHartmann_set_reference_slopes(self, src)
    }
    #[inline]
    pub unsafe fn calibrate(&mut self, src: *mut source, threshold: f32) {
        geometricShackHartmann_calibrate(self, src, threshold)
    }
    #[inline]
    pub unsafe fn propagate(&mut self, gs: *mut source) {
        geometricShackHartmann_propagate(self, gs)
    }
    #[inline]
    pub unsafe fn propagate1(&mut self, gs: *mut source, maks: *mut ::std::os::raw::c_int) {
        geometricShackHartmann_propagate1(self, gs, maks)
    }
    #[inline]
    pub unsafe fn process(&mut self) {
        geometricShackHartmann_process(self)
    }
    #[inline]
    pub unsafe fn analyze(&mut self, gs: *mut source) {
        geometricShackHartmann_analyze(self, gs)
    }
    #[inline]
    pub unsafe fn get_valid_reference_slopes(&mut self, d__valid_slopes: *mut f32) {
        geometricShackHartmann_get_valid_reference_slopes(self, d__valid_slopes)
    }
    #[inline]
    pub unsafe fn get_valid_slopes(&mut self, d__valid_slopes: *mut f32) {
        geometricShackHartmann_get_valid_slopes(self, d__valid_slopes)
    }
    #[inline]
    pub unsafe fn masked_slopes(&mut self, d__valid_slopes: *mut f32, lenslet_mask: *mut mask) {
        geometricShackHartmann_masked_slopes(self, d__valid_slopes, lenslet_mask)
    }
    #[inline]
    pub unsafe fn get_valid_slopes_norm(&mut self, d__valid_slopes_norm: *mut f32) {
        geometricShackHartmann_get_valid_slopes_norm(self, d__valid_slopes_norm)
    }
    #[inline]
    pub unsafe fn folded_slopes(&mut self, d__valid_slopes: *mut f32, lenslet_mask: *mut mask) {
        geometricShackHartmann_folded_slopes(self, d__valid_slopes, lenslet_mask)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        geometricShackHartmann_reset(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct modes {
    pub d__x_BM: *mut f64,
    pub d__y_BM: *mut f64,
    pub d__BM: *mut f64,
    pub d__BMS: *mut f64,
    pub BM_radius: f64,
    pub BM_N_SAMPLE: ::std::os::raw::c_int,
    pub d__BM_buffer: *mut f64,
    pub n_mode: ::std::os::raw::c_int,
    pub b: *mut rtd,
    pub d__b: *mut rtd,
    pub N: ::std::os::raw::c_int,
    pub filename: [::std::os::raw::c_char; 256usize],
    pub N_SET: ::std::os::raw::c_int,
    pub N_MODE: ::std::os::raw::c_int,
    pub d__s2b: *mut ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of modes"][::std::mem::size_of::<modes>() - 360usize];
    ["Alignment of modes"][::std::mem::align_of::<modes>() - 8usize];
    ["Offset of field: modes::d__x_BM"][::std::mem::offset_of!(modes, d__x_BM) - 0usize];
    ["Offset of field: modes::d__y_BM"][::std::mem::offset_of!(modes, d__y_BM) - 8usize];
    ["Offset of field: modes::d__BM"][::std::mem::offset_of!(modes, d__BM) - 16usize];
    ["Offset of field: modes::d__BMS"][::std::mem::offset_of!(modes, d__BMS) - 24usize];
    ["Offset of field: modes::BM_radius"][::std::mem::offset_of!(modes, BM_radius) - 32usize];
    ["Offset of field: modes::BM_N_SAMPLE"][::std::mem::offset_of!(modes, BM_N_SAMPLE) - 40usize];
    ["Offset of field: modes::d__BM_buffer"][::std::mem::offset_of!(modes, d__BM_buffer) - 48usize];
    ["Offset of field: modes::n_mode"][::std::mem::offset_of!(modes, n_mode) - 56usize];
    ["Offset of field: modes::b"][::std::mem::offset_of!(modes, b) - 64usize];
    ["Offset of field: modes::d__b"][::std::mem::offset_of!(modes, d__b) - 72usize];
    ["Offset of field: modes::N"][::std::mem::offset_of!(modes, N) - 80usize];
    ["Offset of field: modes::filename"][::std::mem::offset_of!(modes, filename) - 84usize];
    ["Offset of field: modes::N_SET"][::std::mem::offset_of!(modes, N_SET) - 340usize];
    ["Offset of field: modes::N_MODE"][::std::mem::offset_of!(modes, N_MODE) - 344usize];
    ["Offset of field: modes::d__s2b"][::std::mem::offset_of!(modes, d__s2b) - 352usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN5modes5setupEPcii"]
    pub fn modes_setup(
        this: *mut modes,
        filename: *mut ::std::os::raw::c_char,
        N: ::std::os::raw::c_int,
        n_mode: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5modes5setupEidiiPiPdii"]
    pub fn modes_setup1(
        this: *mut modes,
        _BM_N_SAMPLE_: ::std::os::raw::c_int,
        _BM_radius_: f64,
        _N_SET_: ::std::os::raw::c_int,
        _N_MODE_: ::std::os::raw::c_int,
        s2b: *mut ::std::os::raw::c_int,
        buffer: *mut f64,
        _N_: ::std::os::raw::c_int,
        _n_mode_: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5modes7cleanupEv"]
    pub fn modes_cleanup(this: *mut modes);
}
extern "C" {
    #[link_name = "\u{1}_ZN5modes4loadEv"]
    pub fn modes_load(this: *mut modes);
}
extern "C" {
    #[link_name = "\u{1}_ZN5modes4loadEidiiPiPd"]
    pub fn modes_load1(
        this: *mut modes,
        _BM_N_SAMPLE_: ::std::os::raw::c_int,
        _BM_radius_: f64,
        _N_SET_: ::std::os::raw::c_int,
        _N_MODE_: ::std::os::raw::c_int,
        s2b: *mut ::std::os::raw::c_int,
        buffer: *mut f64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5modes11reset_modesEPd"]
    pub fn modes_reset_modes(this: *mut modes, buffer: *mut f64);
}
extern "C" {
    #[link_name = "\u{1}_ZN5modes6updateEPd"]
    pub fn modes_update(this: *mut modes, b: *mut rtd);
}
impl modes {
    #[inline]
    pub unsafe fn setup(
        &mut self,
        filename: *mut ::std::os::raw::c_char,
        N: ::std::os::raw::c_int,
        n_mode: ::std::os::raw::c_int,
    ) {
        modes_setup(self, filename, N, n_mode)
    }
    #[inline]
    pub unsafe fn setup1(
        &mut self,
        _BM_N_SAMPLE_: ::std::os::raw::c_int,
        _BM_radius_: f64,
        _N_SET_: ::std::os::raw::c_int,
        _N_MODE_: ::std::os::raw::c_int,
        s2b: *mut ::std::os::raw::c_int,
        buffer: *mut f64,
        _N_: ::std::os::raw::c_int,
        _n_mode_: ::std::os::raw::c_int,
    ) {
        modes_setup1(
            self,
            _BM_N_SAMPLE_,
            _BM_radius_,
            _N_SET_,
            _N_MODE_,
            s2b,
            buffer,
            _N_,
            _n_mode_,
        )
    }
    #[inline]
    pub unsafe fn cleanup(&mut self) {
        modes_cleanup(self)
    }
    #[inline]
    pub unsafe fn load(&mut self) {
        modes_load(self)
    }
    #[inline]
    pub unsafe fn load1(
        &mut self,
        _BM_N_SAMPLE_: ::std::os::raw::c_int,
        _BM_radius_: f64,
        _N_SET_: ::std::os::raw::c_int,
        _N_MODE_: ::std::os::raw::c_int,
        s2b: *mut ::std::os::raw::c_int,
        buffer: *mut f64,
    ) {
        modes_load1(
            self,
            _BM_N_SAMPLE_,
            _BM_radius_,
            _N_SET_,
            _N_MODE_,
            s2b,
            buffer,
        )
    }
    #[inline]
    pub unsafe fn reset_modes(&mut self, buffer: *mut f64) {
        modes_reset_modes(self, buffer)
    }
    #[inline]
    pub unsafe fn update(&mut self, b: *mut rtd) {
        modes_update(self, b)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gmt_m1 {
    pub M_ID: ::std::os::raw::c_int,
    pub D_assembly: rtd,
    pub D_clear: rtd,
    pub D_full: rtd,
    pub ri: rtd,
    pub beta: rtd,
    pub L: rtd,
    pub area0: rtd,
    pub area_fraction: rtd,
    pub area0_px: f32,
    pub area: rtd,
    pub N: ::std::os::raw::c_int,
    pub depth: rtd,
    pub aperture_CS: coordinate_system,
    pub conic_CS: coordinate_system,
    pub conic_origin: [vector; 7usize],
    pub d__conic_origin: *mut vector,
    pub conic_c: rtd,
    pub conic_k: rtd,
    pub d__conic_c: *mut rtd,
    pub d__conic_k: *mut rtd,
    pub rigid_body_CS: coordinate_system,
    pub motion_CS: coordinate_system,
    pub height: rtd,
    pub V: *mut mask,
    pub idx_offset: ::std::os::raw::c_int,
    pub ZS: *mut zernikeS,
    pub d__piston_mask: *mut ::std::os::raw::c_int,
    pub TT_CS: coordinate_system,
    pub d__C: *mut f64,
    pub d__D: *mut f64,
    pub handle: cublasHandle_t,
    pub d__valid_segments: *mut ::std::os::raw::c_char,
    pub BS: modes,
    pub d__segment_reflectivity: *mut f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of gmt_m1"][::std::mem::size_of::<gmt_m1>() - 1192usize];
    ["Alignment of gmt_m1"][::std::mem::align_of::<gmt_m1>() - 8usize];
    ["Offset of field: gmt_m1::M_ID"][::std::mem::offset_of!(gmt_m1, M_ID) - 0usize];
    ["Offset of field: gmt_m1::D_assembly"][::std::mem::offset_of!(gmt_m1, D_assembly) - 8usize];
    ["Offset of field: gmt_m1::D_clear"][::std::mem::offset_of!(gmt_m1, D_clear) - 16usize];
    ["Offset of field: gmt_m1::D_full"][::std::mem::offset_of!(gmt_m1, D_full) - 24usize];
    ["Offset of field: gmt_m1::ri"][::std::mem::offset_of!(gmt_m1, ri) - 32usize];
    ["Offset of field: gmt_m1::beta"][::std::mem::offset_of!(gmt_m1, beta) - 40usize];
    ["Offset of field: gmt_m1::L"][::std::mem::offset_of!(gmt_m1, L) - 48usize];
    ["Offset of field: gmt_m1::area0"][::std::mem::offset_of!(gmt_m1, area0) - 56usize];
    ["Offset of field: gmt_m1::area_fraction"]
        [::std::mem::offset_of!(gmt_m1, area_fraction) - 64usize];
    ["Offset of field: gmt_m1::area0_px"][::std::mem::offset_of!(gmt_m1, area0_px) - 72usize];
    ["Offset of field: gmt_m1::area"][::std::mem::offset_of!(gmt_m1, area) - 80usize];
    ["Offset of field: gmt_m1::N"][::std::mem::offset_of!(gmt_m1, N) - 88usize];
    ["Offset of field: gmt_m1::depth"][::std::mem::offset_of!(gmt_m1, depth) - 96usize];
    ["Offset of field: gmt_m1::aperture_CS"]
        [::std::mem::offset_of!(gmt_m1, aperture_CS) - 104usize];
    ["Offset of field: gmt_m1::conic_CS"][::std::mem::offset_of!(gmt_m1, conic_CS) - 192usize];
    ["Offset of field: gmt_m1::conic_origin"]
        [::std::mem::offset_of!(gmt_m1, conic_origin) - 280usize];
    ["Offset of field: gmt_m1::d__conic_origin"]
        [::std::mem::offset_of!(gmt_m1, d__conic_origin) - 448usize];
    ["Offset of field: gmt_m1::conic_c"][::std::mem::offset_of!(gmt_m1, conic_c) - 456usize];
    ["Offset of field: gmt_m1::conic_k"][::std::mem::offset_of!(gmt_m1, conic_k) - 464usize];
    ["Offset of field: gmt_m1::d__conic_c"][::std::mem::offset_of!(gmt_m1, d__conic_c) - 472usize];
    ["Offset of field: gmt_m1::d__conic_k"][::std::mem::offset_of!(gmt_m1, d__conic_k) - 480usize];
    ["Offset of field: gmt_m1::rigid_body_CS"]
        [::std::mem::offset_of!(gmt_m1, rigid_body_CS) - 488usize];
    ["Offset of field: gmt_m1::motion_CS"][::std::mem::offset_of!(gmt_m1, motion_CS) - 576usize];
    ["Offset of field: gmt_m1::height"][::std::mem::offset_of!(gmt_m1, height) - 664usize];
    ["Offset of field: gmt_m1::V"][::std::mem::offset_of!(gmt_m1, V) - 672usize];
    ["Offset of field: gmt_m1::idx_offset"][::std::mem::offset_of!(gmt_m1, idx_offset) - 680usize];
    ["Offset of field: gmt_m1::ZS"][::std::mem::offset_of!(gmt_m1, ZS) - 688usize];
    ["Offset of field: gmt_m1::d__piston_mask"]
        [::std::mem::offset_of!(gmt_m1, d__piston_mask) - 696usize];
    ["Offset of field: gmt_m1::TT_CS"][::std::mem::offset_of!(gmt_m1, TT_CS) - 704usize];
    ["Offset of field: gmt_m1::d__C"][::std::mem::offset_of!(gmt_m1, d__C) - 792usize];
    ["Offset of field: gmt_m1::d__D"][::std::mem::offset_of!(gmt_m1, d__D) - 800usize];
    ["Offset of field: gmt_m1::handle"][::std::mem::offset_of!(gmt_m1, handle) - 808usize];
    ["Offset of field: gmt_m1::d__valid_segments"]
        [::std::mem::offset_of!(gmt_m1, d__valid_segments) - 816usize];
    ["Offset of field: gmt_m1::BS"][::std::mem::offset_of!(gmt_m1, BS) - 824usize];
    ["Offset of field: gmt_m1::d__segment_reflectivity"]
        [::std::mem::offset_of!(gmt_m1, d__segment_reflectivity) - 1184usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m15setupEv"]
    pub fn gmt_m1_setup(this: *mut gmt_m1);
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m15setupEPcii"]
    pub fn gmt_m1_setup1(
        this: *mut gmt_m1,
        _filename_: *mut ::std::os::raw::c_char,
        _N_: ::std::os::raw::c_int,
        _n_mode_: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m15setupEP8zernikeS"]
    pub fn gmt_m1_setup2(this: *mut gmt_m1, ZS: *mut zernikeS);
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m17cleanupEv"]
    pub fn gmt_m1_cleanup(this: *mut gmt_m1);
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m16updateE6vectorS0_i"]
    pub fn gmt_m1_update(
        this: *mut gmt_m1,
        _origin_: vector,
        _euler_angles_: vector,
        idx: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m15resetEv"]
    pub fn gmt_m1_reset(this: *mut gmt_m1);
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m15traceEP6bundle"]
    pub fn gmt_m1_trace(this: *mut gmt_m1, rays: *mut bundle);
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m18traceallEP6bundle"]
    pub fn gmt_m1_traceall(this: *mut gmt_m1, rays: *mut bundle);
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m18blockingEP6bundle"]
    pub fn gmt_m1_blocking(this: *mut gmt_m1, rays: *mut bundle);
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m114global_tiptiltEff"]
    pub fn gmt_m1_global_tiptilt(this: *mut gmt_m1, tip: f32, tilt: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m116test_ray_tracingEv"]
    pub fn gmt_m1_test_ray_tracing(this: *mut gmt_m1);
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m15trackEPfS0_S0_ii"]
    pub fn gmt_m1_track(
        this: *mut gmt_m1,
        x: *mut f32,
        y: *mut f32,
        z: *mut f32,
        N: ::std::os::raw::c_int,
        idx: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m16locateEPfS0_S0_ii"]
    pub fn gmt_m1_locate(
        this: *mut gmt_m1,
        x: *mut f32,
        y: *mut f32,
        z: *mut f32,
        N: ::std::os::raw::c_int,
        idx: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m16removeEPii"]
    pub fn gmt_m1_remove(
        this: *mut gmt_m1,
        seg_ID: *mut ::std::os::raw::c_int,
        N_ID: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m14keepEPii"]
    pub fn gmt_m1_keep(
        this: *mut gmt_m1,
        seg_ID: *mut ::std::os::raw::c_int,
        N_ID: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m114update_conic_cEPd"]
    pub fn gmt_m1_update_conic_c(this: *mut gmt_m1, _conic_c_: *mut rtd);
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m114update_conic_kEPd"]
    pub fn gmt_m1_update_conic_k(this: *mut gmt_m1, _conic_k_: *mut rtd);
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m116set_reflectivityEPf"]
    pub fn gmt_m1_set_reflectivity(this: *mut gmt_m1, reflectivity: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m16presetEP6bundled"]
    pub fn gmt_m1_preset(this: *mut gmt_m1, rays: *mut bundle, margin: rtd);
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m117edge_sensors_dataEv"]
    pub fn gmt_m1_edge_sensors_data(this: *mut gmt_m1);
}
impl gmt_m1 {
    #[inline]
    pub unsafe fn setup(&mut self) {
        gmt_m1_setup(self)
    }
    #[inline]
    pub unsafe fn setup1(
        &mut self,
        _filename_: *mut ::std::os::raw::c_char,
        _N_: ::std::os::raw::c_int,
        _n_mode_: ::std::os::raw::c_int,
    ) {
        gmt_m1_setup1(self, _filename_, _N_, _n_mode_)
    }
    #[inline]
    pub unsafe fn setup2(&mut self, ZS: *mut zernikeS) {
        gmt_m1_setup2(self, ZS)
    }
    #[inline]
    pub unsafe fn cleanup(&mut self) {
        gmt_m1_cleanup(self)
    }
    #[inline]
    pub unsafe fn update(
        &mut self,
        _origin_: vector,
        _euler_angles_: vector,
        idx: ::std::os::raw::c_int,
    ) {
        gmt_m1_update(self, _origin_, _euler_angles_, idx)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        gmt_m1_reset(self)
    }
    #[inline]
    pub unsafe fn trace(&mut self, rays: *mut bundle) {
        gmt_m1_trace(self, rays)
    }
    #[inline]
    pub unsafe fn traceall(&mut self, rays: *mut bundle) {
        gmt_m1_traceall(self, rays)
    }
    #[inline]
    pub unsafe fn blocking(&mut self, rays: *mut bundle) {
        gmt_m1_blocking(self, rays)
    }
    #[inline]
    pub unsafe fn global_tiptilt(&mut self, tip: f32, tilt: f32) {
        gmt_m1_global_tiptilt(self, tip, tilt)
    }
    #[inline]
    pub unsafe fn test_ray_tracing(&mut self) {
        gmt_m1_test_ray_tracing(self)
    }
    #[inline]
    pub unsafe fn track(
        &mut self,
        x: *mut f32,
        y: *mut f32,
        z: *mut f32,
        N: ::std::os::raw::c_int,
        idx: ::std::os::raw::c_int,
    ) {
        gmt_m1_track(self, x, y, z, N, idx)
    }
    #[inline]
    pub unsafe fn locate(
        &mut self,
        x: *mut f32,
        y: *mut f32,
        z: *mut f32,
        N: ::std::os::raw::c_int,
        idx: ::std::os::raw::c_int,
    ) {
        gmt_m1_locate(self, x, y, z, N, idx)
    }
    #[inline]
    pub unsafe fn remove(
        &mut self,
        seg_ID: *mut ::std::os::raw::c_int,
        N_ID: ::std::os::raw::c_int,
    ) {
        gmt_m1_remove(self, seg_ID, N_ID)
    }
    #[inline]
    pub unsafe fn keep(&mut self, seg_ID: *mut ::std::os::raw::c_int, N_ID: ::std::os::raw::c_int) {
        gmt_m1_keep(self, seg_ID, N_ID)
    }
    #[inline]
    pub unsafe fn update_conic_c(&mut self, _conic_c_: *mut rtd) {
        gmt_m1_update_conic_c(self, _conic_c_)
    }
    #[inline]
    pub unsafe fn update_conic_k(&mut self, _conic_k_: *mut rtd) {
        gmt_m1_update_conic_k(self, _conic_k_)
    }
    #[inline]
    pub unsafe fn set_reflectivity(&mut self, reflectivity: *mut f32) {
        gmt_m1_set_reflectivity(self, reflectivity)
    }
    #[inline]
    pub unsafe fn preset(&mut self, rays: *mut bundle, margin: rtd) {
        gmt_m1_preset(self, rays, margin)
    }
    #[inline]
    pub unsafe fn edge_sensors_data(&mut self) {
        gmt_m1_edge_sensors_data(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gmt_m2 {
    pub M_ID: ::std::os::raw::c_int,
    pub D_assembly: rtd,
    pub D_clear: rtd,
    pub D_full: rtd,
    pub ri: rtd,
    pub beta: rtd,
    pub L: rtd,
    pub area0: rtd,
    pub area_fraction: rtd,
    pub area0_px: f32,
    pub area: rtd,
    pub N: ::std::os::raw::c_int,
    pub depth: rtd,
    pub aperture_CS: coordinate_system,
    pub conic_CS: coordinate_system,
    pub conic_origin: [vector; 7usize],
    pub d__conic_origin: *mut vector,
    pub conic_c: rtd,
    pub conic_k: rtd,
    pub d__conic_c: *mut rtd,
    pub d__conic_k: *mut rtd,
    pub rigid_body_CS: coordinate_system,
    pub motion_CS: coordinate_system,
    pub height: rtd,
    pub V: *mut mask,
    pub idx_offset: ::std::os::raw::c_int,
    pub ZS: *mut zernikeS,
    pub d__piston_mask: *mut ::std::os::raw::c_int,
    pub TT_CS: coordinate_system,
    pub d__C: *mut f64,
    pub d__D: *mut f64,
    pub handle: cublasHandle_t,
    pub d__valid_segments: *mut ::std::os::raw::c_char,
    pub BS: modes,
    pub d__segment_reflectivity: *mut f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of gmt_m2"][::std::mem::size_of::<gmt_m2>() - 1192usize];
    ["Alignment of gmt_m2"][::std::mem::align_of::<gmt_m2>() - 8usize];
    ["Offset of field: gmt_m2::M_ID"][::std::mem::offset_of!(gmt_m2, M_ID) - 0usize];
    ["Offset of field: gmt_m2::D_assembly"][::std::mem::offset_of!(gmt_m2, D_assembly) - 8usize];
    ["Offset of field: gmt_m2::D_clear"][::std::mem::offset_of!(gmt_m2, D_clear) - 16usize];
    ["Offset of field: gmt_m2::D_full"][::std::mem::offset_of!(gmt_m2, D_full) - 24usize];
    ["Offset of field: gmt_m2::ri"][::std::mem::offset_of!(gmt_m2, ri) - 32usize];
    ["Offset of field: gmt_m2::beta"][::std::mem::offset_of!(gmt_m2, beta) - 40usize];
    ["Offset of field: gmt_m2::L"][::std::mem::offset_of!(gmt_m2, L) - 48usize];
    ["Offset of field: gmt_m2::area0"][::std::mem::offset_of!(gmt_m2, area0) - 56usize];
    ["Offset of field: gmt_m2::area_fraction"]
        [::std::mem::offset_of!(gmt_m2, area_fraction) - 64usize];
    ["Offset of field: gmt_m2::area0_px"][::std::mem::offset_of!(gmt_m2, area0_px) - 72usize];
    ["Offset of field: gmt_m2::area"][::std::mem::offset_of!(gmt_m2, area) - 80usize];
    ["Offset of field: gmt_m2::N"][::std::mem::offset_of!(gmt_m2, N) - 88usize];
    ["Offset of field: gmt_m2::depth"][::std::mem::offset_of!(gmt_m2, depth) - 96usize];
    ["Offset of field: gmt_m2::aperture_CS"]
        [::std::mem::offset_of!(gmt_m2, aperture_CS) - 104usize];
    ["Offset of field: gmt_m2::conic_CS"][::std::mem::offset_of!(gmt_m2, conic_CS) - 192usize];
    ["Offset of field: gmt_m2::conic_origin"]
        [::std::mem::offset_of!(gmt_m2, conic_origin) - 280usize];
    ["Offset of field: gmt_m2::d__conic_origin"]
        [::std::mem::offset_of!(gmt_m2, d__conic_origin) - 448usize];
    ["Offset of field: gmt_m2::conic_c"][::std::mem::offset_of!(gmt_m2, conic_c) - 456usize];
    ["Offset of field: gmt_m2::conic_k"][::std::mem::offset_of!(gmt_m2, conic_k) - 464usize];
    ["Offset of field: gmt_m2::d__conic_c"][::std::mem::offset_of!(gmt_m2, d__conic_c) - 472usize];
    ["Offset of field: gmt_m2::d__conic_k"][::std::mem::offset_of!(gmt_m2, d__conic_k) - 480usize];
    ["Offset of field: gmt_m2::rigid_body_CS"]
        [::std::mem::offset_of!(gmt_m2, rigid_body_CS) - 488usize];
    ["Offset of field: gmt_m2::motion_CS"][::std::mem::offset_of!(gmt_m2, motion_CS) - 576usize];
    ["Offset of field: gmt_m2::height"][::std::mem::offset_of!(gmt_m2, height) - 664usize];
    ["Offset of field: gmt_m2::V"][::std::mem::offset_of!(gmt_m2, V) - 672usize];
    ["Offset of field: gmt_m2::idx_offset"][::std::mem::offset_of!(gmt_m2, idx_offset) - 680usize];
    ["Offset of field: gmt_m2::ZS"][::std::mem::offset_of!(gmt_m2, ZS) - 688usize];
    ["Offset of field: gmt_m2::d__piston_mask"]
        [::std::mem::offset_of!(gmt_m2, d__piston_mask) - 696usize];
    ["Offset of field: gmt_m2::TT_CS"][::std::mem::offset_of!(gmt_m2, TT_CS) - 704usize];
    ["Offset of field: gmt_m2::d__C"][::std::mem::offset_of!(gmt_m2, d__C) - 792usize];
    ["Offset of field: gmt_m2::d__D"][::std::mem::offset_of!(gmt_m2, d__D) - 800usize];
    ["Offset of field: gmt_m2::handle"][::std::mem::offset_of!(gmt_m2, handle) - 808usize];
    ["Offset of field: gmt_m2::d__valid_segments"]
        [::std::mem::offset_of!(gmt_m2, d__valid_segments) - 816usize];
    ["Offset of field: gmt_m2::BS"][::std::mem::offset_of!(gmt_m2, BS) - 824usize];
    ["Offset of field: gmt_m2::d__segment_reflectivity"]
        [::std::mem::offset_of!(gmt_m2, d__segment_reflectivity) - 1184usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m25setupEv"]
    pub fn gmt_m2_setup(this: *mut gmt_m2);
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m25setupEPcii"]
    pub fn gmt_m2_setup1(
        this: *mut gmt_m2,
        _filename_: *mut ::std::os::raw::c_char,
        _N_: ::std::os::raw::c_int,
        _n_mode_: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m25setupEP8zernikeS"]
    pub fn gmt_m2_setup2(this: *mut gmt_m2, ZS: *mut zernikeS);
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m27cleanupEv"]
    pub fn gmt_m2_cleanup(this: *mut gmt_m2);
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m26updateE6vectorS0_i"]
    pub fn gmt_m2_update(
        this: *mut gmt_m2,
        _origin_: vector,
        _euler_angles_: vector,
        idx: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m25resetEv"]
    pub fn gmt_m2_reset(this: *mut gmt_m2);
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m25traceEP6bundle"]
    pub fn gmt_m2_trace(this: *mut gmt_m2, rays: *mut bundle);
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m28traceallEP6bundle"]
    pub fn gmt_m2_traceall(this: *mut gmt_m2, rays: *mut bundle);
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m28blockingEP6bundle"]
    pub fn gmt_m2_blocking(this: *mut gmt_m2, rays: *mut bundle);
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m214global_tiptiltEff"]
    pub fn gmt_m2_global_tiptilt(this: *mut gmt_m2, tip: f32, tilt: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m216test_ray_tracingEv"]
    pub fn gmt_m2_test_ray_tracing(this: *mut gmt_m2);
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m25trackEPfS0_S0_ii"]
    pub fn gmt_m2_track(
        this: *mut gmt_m2,
        x: *mut f32,
        y: *mut f32,
        z: *mut f32,
        N: ::std::os::raw::c_int,
        idx: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m26locateEPfS0_S0_ii"]
    pub fn gmt_m2_locate(
        this: *mut gmt_m2,
        x: *mut f32,
        y: *mut f32,
        z: *mut f32,
        N: ::std::os::raw::c_int,
        idx: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m26removeEPii"]
    pub fn gmt_m2_remove(
        this: *mut gmt_m2,
        seg_ID: *mut ::std::os::raw::c_int,
        N_ID: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m24keepEPii"]
    pub fn gmt_m2_keep(
        this: *mut gmt_m2,
        seg_ID: *mut ::std::os::raw::c_int,
        N_ID: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m214update_conic_cEPd"]
    pub fn gmt_m2_update_conic_c(this: *mut gmt_m2, _conic_c_: *mut rtd);
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m214update_conic_kEPd"]
    pub fn gmt_m2_update_conic_k(this: *mut gmt_m2, _conic_k_: *mut rtd);
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m216set_reflectivityEPf"]
    pub fn gmt_m2_set_reflectivity(this: *mut gmt_m2, reflectivity: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m216pointing_neutralEff"]
    pub fn gmt_m2_pointing_neutral(this: *mut gmt_m2, tip: f32, tilt: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN6gmt_m212coma_neutralEff"]
    pub fn gmt_m2_coma_neutral(this: *mut gmt_m2, tip: f32, tilt: f32);
}
impl gmt_m2 {
    #[inline]
    pub unsafe fn setup(&mut self) {
        gmt_m2_setup(self)
    }
    #[inline]
    pub unsafe fn setup1(
        &mut self,
        _filename_: *mut ::std::os::raw::c_char,
        _N_: ::std::os::raw::c_int,
        _n_mode_: ::std::os::raw::c_int,
    ) {
        gmt_m2_setup1(self, _filename_, _N_, _n_mode_)
    }
    #[inline]
    pub unsafe fn setup2(&mut self, ZS: *mut zernikeS) {
        gmt_m2_setup2(self, ZS)
    }
    #[inline]
    pub unsafe fn cleanup(&mut self) {
        gmt_m2_cleanup(self)
    }
    #[inline]
    pub unsafe fn update(
        &mut self,
        _origin_: vector,
        _euler_angles_: vector,
        idx: ::std::os::raw::c_int,
    ) {
        gmt_m2_update(self, _origin_, _euler_angles_, idx)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        gmt_m2_reset(self)
    }
    #[inline]
    pub unsafe fn trace(&mut self, rays: *mut bundle) {
        gmt_m2_trace(self, rays)
    }
    #[inline]
    pub unsafe fn traceall(&mut self, rays: *mut bundle) {
        gmt_m2_traceall(self, rays)
    }
    #[inline]
    pub unsafe fn blocking(&mut self, rays: *mut bundle) {
        gmt_m2_blocking(self, rays)
    }
    #[inline]
    pub unsafe fn global_tiptilt(&mut self, tip: f32, tilt: f32) {
        gmt_m2_global_tiptilt(self, tip, tilt)
    }
    #[inline]
    pub unsafe fn test_ray_tracing(&mut self) {
        gmt_m2_test_ray_tracing(self)
    }
    #[inline]
    pub unsafe fn track(
        &mut self,
        x: *mut f32,
        y: *mut f32,
        z: *mut f32,
        N: ::std::os::raw::c_int,
        idx: ::std::os::raw::c_int,
    ) {
        gmt_m2_track(self, x, y, z, N, idx)
    }
    #[inline]
    pub unsafe fn locate(
        &mut self,
        x: *mut f32,
        y: *mut f32,
        z: *mut f32,
        N: ::std::os::raw::c_int,
        idx: ::std::os::raw::c_int,
    ) {
        gmt_m2_locate(self, x, y, z, N, idx)
    }
    #[inline]
    pub unsafe fn remove(
        &mut self,
        seg_ID: *mut ::std::os::raw::c_int,
        N_ID: ::std::os::raw::c_int,
    ) {
        gmt_m2_remove(self, seg_ID, N_ID)
    }
    #[inline]
    pub unsafe fn keep(&mut self, seg_ID: *mut ::std::os::raw::c_int, N_ID: ::std::os::raw::c_int) {
        gmt_m2_keep(self, seg_ID, N_ID)
    }
    #[inline]
    pub unsafe fn update_conic_c(&mut self, _conic_c_: *mut rtd) {
        gmt_m2_update_conic_c(self, _conic_c_)
    }
    #[inline]
    pub unsafe fn update_conic_k(&mut self, _conic_k_: *mut rtd) {
        gmt_m2_update_conic_k(self, _conic_k_)
    }
    #[inline]
    pub unsafe fn set_reflectivity(&mut self, reflectivity: *mut f32) {
        gmt_m2_set_reflectivity(self, reflectivity)
    }
    #[inline]
    pub unsafe fn pointing_neutral(&mut self, tip: f32, tilt: f32) {
        gmt_m2_pointing_neutral(self, tip, tilt)
    }
    #[inline]
    pub unsafe fn coma_neutral(&mut self, tip: f32, tilt: f32) {
        gmt_m2_coma_neutral(self, tip, tilt)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct layer {
    pub altitude: f32,
    pub xi0: f32,
    pub wind_speed: f32,
    pub wind_direction: f32,
    pub vx: f32,
    pub vy: f32,
    pub WIDTH_LAYER: f32,
    pub LENGTH_LAYER: f32,
    pub N_WIDTH_LAYER: ::std::os::raw::c_int,
    pub N_LENGTH_LAYER: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of layer"][::std::mem::size_of::<layer>() - 40usize];
    ["Alignment of layer"][::std::mem::align_of::<layer>() - 4usize];
    ["Offset of field: layer::altitude"][::std::mem::offset_of!(layer, altitude) - 0usize];
    ["Offset of field: layer::xi0"][::std::mem::offset_of!(layer, xi0) - 4usize];
    ["Offset of field: layer::wind_speed"][::std::mem::offset_of!(layer, wind_speed) - 8usize];
    ["Offset of field: layer::wind_direction"]
        [::std::mem::offset_of!(layer, wind_direction) - 12usize];
    ["Offset of field: layer::vx"][::std::mem::offset_of!(layer, vx) - 16usize];
    ["Offset of field: layer::vy"][::std::mem::offset_of!(layer, vy) - 20usize];
    ["Offset of field: layer::WIDTH_LAYER"][::std::mem::offset_of!(layer, WIDTH_LAYER) - 24usize];
    ["Offset of field: layer::LENGTH_LAYER"][::std::mem::offset_of!(layer, LENGTH_LAYER) - 28usize];
    ["Offset of field: layer::N_WIDTH_LAYER"]
        [::std::mem::offset_of!(layer, N_WIDTH_LAYER) - 32usize];
    ["Offset of field: layer::N_LENGTH_LAYER"]
        [::std::mem::offset_of!(layer, N_LENGTH_LAYER) - 36usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN5layer5setupEfffffifif"]
    pub fn layer_setup(
        this: *mut layer,
        _altitude: f32,
        _xi0: f32,
        _wind_speed_: f32,
        _wind_direction: f32,
        W: f32,
        N_W: ::std::os::raw::c_int,
        field_size: f32,
        OSF: ::std::os::raw::c_int,
        duration: f32,
    ) -> ::std::os::raw::c_int;
}
impl layer {
    #[inline]
    pub unsafe fn setup(
        &mut self,
        _altitude: f32,
        _xi0: f32,
        _wind_speed_: f32,
        _wind_direction: f32,
        W: f32,
        N_W: ::std::os::raw::c_int,
        field_size: f32,
        OSF: ::std::os::raw::c_int,
        duration: f32,
    ) -> ::std::os::raw::c_int {
        layer_setup(
            self,
            _altitude,
            _xi0,
            _wind_speed_,
            _wind_direction,
            W,
            N_W,
            field_size,
            OSF,
            duration,
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct profile {
    pub L0: f32,
    pub l0: f32,
    pub L: f32,
    pub f: f32,
    pub delta: f32,
    pub N_k: f32,
    pub N_a: f32,
    pub kmin: f32,
    pub altitude: *mut f32,
    pub xi0: *mut f32,
    pub wind_speed: *mut f32,
    pub wind_direction: *mut f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of profile"][::std::mem::size_of::<profile>() - 64usize];
    ["Alignment of profile"][::std::mem::align_of::<profile>() - 8usize];
    ["Offset of field: profile::L0"][::std::mem::offset_of!(profile, L0) - 0usize];
    ["Offset of field: profile::l0"][::std::mem::offset_of!(profile, l0) - 4usize];
    ["Offset of field: profile::L"][::std::mem::offset_of!(profile, L) - 8usize];
    ["Offset of field: profile::f"][::std::mem::offset_of!(profile, f) - 12usize];
    ["Offset of field: profile::delta"][::std::mem::offset_of!(profile, delta) - 16usize];
    ["Offset of field: profile::N_k"][::std::mem::offset_of!(profile, N_k) - 20usize];
    ["Offset of field: profile::N_a"][::std::mem::offset_of!(profile, N_a) - 24usize];
    ["Offset of field: profile::kmin"][::std::mem::offset_of!(profile, kmin) - 28usize];
    ["Offset of field: profile::altitude"][::std::mem::offset_of!(profile, altitude) - 32usize];
    ["Offset of field: profile::xi0"][::std::mem::offset_of!(profile, xi0) - 40usize];
    ["Offset of field: profile::wind_speed"][::std::mem::offset_of!(profile, wind_speed) - 48usize];
    ["Offset of field: profile::wind_direction"]
        [::std::mem::offset_of!(profile, wind_direction) - 56usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN7profile5setupEPfS0_S0_S0_i"]
    pub fn profile_setup(
        this: *mut profile,
        altitude: *mut f32,
        xi0: *mut f32,
        wind_speed: *mut f32,
        wind_direction: *mut f32,
        N_LAYER: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7profile7cleanupEv"]
    pub fn profile_cleanup(this: *mut profile);
}
impl profile {
    #[inline]
    pub unsafe fn setup(
        &mut self,
        altitude: *mut f32,
        xi0: *mut f32,
        wind_speed: *mut f32,
        wind_direction: *mut f32,
        N_LAYER: ::std::os::raw::c_int,
    ) {
        profile_setup(self, altitude, xi0, wind_speed, wind_direction, N_LAYER)
    }
    #[inline]
    pub unsafe fn cleanup(&mut self) {
        profile_cleanup(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atmosphere {
    pub photometric_band: *mut ::std::os::raw::c_char,
    pub wavelength: f32,
    pub r0: f32,
    pub wavenumber: f32,
    pub N_LAYER: ::std::os::raw::c_int,
    pub field_size: f32,
    pub layers_OSF: ::std::os::raw::c_int,
    pub layers_duration: f32,
    pub layers_tau0: f32,
    pub W: f32,
    pub N_W: ::std::os::raw::c_int,
    pub phase_screen_LAYER: *mut f32,
    pub N_DURATION: ::std::os::raw::c_int,
    pub LOCAL_RAND_SEED: ::std::os::raw::c_int,
    pub ID: ::std::os::raw::c_int,
    pub EPH: f32,
    pub d__phase_screen_LAYER: *mut f32,
    pub N_PHASE_LAYER: ::std::os::raw::c_ulong,
    pub mmap_size: usize,
    pub zeta1: *mut f32,
    pub eta1: *mut f32,
    pub zeta2: *mut f32,
    pub eta2: *mut f32,
    pub devStates: *mut curandState,
    pub turbulence: profile,
    pub d__turbulence: *mut profile,
    pub layers: *mut layer,
    pub d__layers: *mut layer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of atmosphere"][::std::mem::size_of::<atmosphere>() - 224usize];
    ["Alignment of atmosphere"][::std::mem::align_of::<atmosphere>() - 8usize];
    ["Offset of field: atmosphere::photometric_band"]
        [::std::mem::offset_of!(atmosphere, photometric_band) - 0usize];
    ["Offset of field: atmosphere::wavelength"]
        [::std::mem::offset_of!(atmosphere, wavelength) - 8usize];
    ["Offset of field: atmosphere::r0"][::std::mem::offset_of!(atmosphere, r0) - 12usize];
    ["Offset of field: atmosphere::wavenumber"]
        [::std::mem::offset_of!(atmosphere, wavenumber) - 16usize];
    ["Offset of field: atmosphere::N_LAYER"][::std::mem::offset_of!(atmosphere, N_LAYER) - 20usize];
    ["Offset of field: atmosphere::field_size"]
        [::std::mem::offset_of!(atmosphere, field_size) - 24usize];
    ["Offset of field: atmosphere::layers_OSF"]
        [::std::mem::offset_of!(atmosphere, layers_OSF) - 28usize];
    ["Offset of field: atmosphere::layers_duration"]
        [::std::mem::offset_of!(atmosphere, layers_duration) - 32usize];
    ["Offset of field: atmosphere::layers_tau0"]
        [::std::mem::offset_of!(atmosphere, layers_tau0) - 36usize];
    ["Offset of field: atmosphere::W"][::std::mem::offset_of!(atmosphere, W) - 40usize];
    ["Offset of field: atmosphere::N_W"][::std::mem::offset_of!(atmosphere, N_W) - 44usize];
    ["Offset of field: atmosphere::phase_screen_LAYER"]
        [::std::mem::offset_of!(atmosphere, phase_screen_LAYER) - 48usize];
    ["Offset of field: atmosphere::N_DURATION"]
        [::std::mem::offset_of!(atmosphere, N_DURATION) - 56usize];
    ["Offset of field: atmosphere::LOCAL_RAND_SEED"]
        [::std::mem::offset_of!(atmosphere, LOCAL_RAND_SEED) - 60usize];
    ["Offset of field: atmosphere::ID"][::std::mem::offset_of!(atmosphere, ID) - 64usize];
    ["Offset of field: atmosphere::EPH"][::std::mem::offset_of!(atmosphere, EPH) - 68usize];
    ["Offset of field: atmosphere::d__phase_screen_LAYER"]
        [::std::mem::offset_of!(atmosphere, d__phase_screen_LAYER) - 72usize];
    ["Offset of field: atmosphere::N_PHASE_LAYER"]
        [::std::mem::offset_of!(atmosphere, N_PHASE_LAYER) - 80usize];
    ["Offset of field: atmosphere::mmap_size"]
        [::std::mem::offset_of!(atmosphere, mmap_size) - 88usize];
    ["Offset of field: atmosphere::zeta1"][::std::mem::offset_of!(atmosphere, zeta1) - 96usize];
    ["Offset of field: atmosphere::eta1"][::std::mem::offset_of!(atmosphere, eta1) - 104usize];
    ["Offset of field: atmosphere::zeta2"][::std::mem::offset_of!(atmosphere, zeta2) - 112usize];
    ["Offset of field: atmosphere::eta2"][::std::mem::offset_of!(atmosphere, eta2) - 120usize];
    ["Offset of field: atmosphere::devStates"]
        [::std::mem::offset_of!(atmosphere, devStates) - 128usize];
    ["Offset of field: atmosphere::turbulence"]
        [::std::mem::offset_of!(atmosphere, turbulence) - 136usize];
    ["Offset of field: atmosphere::d__turbulence"]
        [::std::mem::offset_of!(atmosphere, d__turbulence) - 200usize];
    ["Offset of field: atmosphere::layers"][::std::mem::offset_of!(atmosphere, layers) - 208usize];
    ["Offset of field: atmosphere::d__layers"]
        [::std::mem::offset_of!(atmosphere, d__layers) - 216usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere5setupEffiPfS0_S0_S0_"]
    pub fn atmosphere_setup(
        this: *mut atmosphere,
        r0_: f32,
        L0: f32,
        N_LAYER: ::std::os::raw::c_int,
        altitude: *mut f32,
        xi0: *mut f32,
        wind_speed: *mut f32,
        wind_direction: *mut f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere5setupEffiPfS0_S0_S0_fiff"]
    pub fn atmosphere_setup1(
        this: *mut atmosphere,
        r0_: f32,
        L0: f32,
        N_LAYER: ::std::os::raw::c_int,
        altitude: *mut f32,
        xi0: *mut f32,
        wind_speed: *mut f32,
        wind_direction: *mut f32,
        _L_: f32,
        _NXY_PUPIL_: ::std::os::raw::c_int,
        field_size: f32,
        duration: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere5setupEffiPfS0_S0_S0_fiffPKci"]
    pub fn atmosphere_setup2(
        this: *mut atmosphere,
        r0_: f32,
        L0: f32,
        _NLAYER: ::std::os::raw::c_int,
        altitude: *mut f32,
        xi0: *mut f32,
        wind_speed: *mut f32,
        wind_direction: *mut f32,
        _L_: f32,
        _NXY_PUPIL_: ::std::os::raw::c_int,
        field_size: f32,
        duration: f32,
        fullpath_to_phasescreens: *const ::std::os::raw::c_char,
        _N_DURATION: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere9gmt_setupEv"]
    pub fn atmosphere_gmt_setup(this: *mut atmosphere);
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere9gmt_setupEff"]
    pub fn atmosphere_gmt_setup1(this: *mut atmosphere, r0_: f32, L0: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere9gmt_setupEfffiff"]
    pub fn atmosphere_gmt_setup2(
        this: *mut atmosphere,
        r0_: f32,
        L0: f32,
        _L_: f32,
        _NXY_PUPIL_: ::std::os::raw::c_int,
        field_size: f32,
        duration: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere9gmt_setupEfffiffPKci"]
    pub fn atmosphere_gmt_setup3(
        this: *mut atmosphere,
        r0_: f32,
        L0: f32,
        _L_: f32,
        _NXY_PUPIL_: ::std::os::raw::c_int,
        field_size: f32,
        duration: f32,
        fullpath_to_phasescreens: *const ::std::os::raw::c_char,
        _N_DURATION: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere9gmt_setupEffi"]
    pub fn atmosphere_gmt_setup4(
        this: *mut atmosphere,
        r0_: f32,
        L0: f32,
        _RAND_SEED_: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere9gmt_setupEfffiffi"]
    pub fn atmosphere_gmt_setup5(
        this: *mut atmosphere,
        r0_: f32,
        L0: f32,
        _L_: f32,
        _NXY_PUPIL_: ::std::os::raw::c_int,
        field_size: f32,
        duration: f32,
        _RAND_SEED_: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere9gmt_setupEfffiffPKcii"]
    pub fn atmosphere_gmt_setup6(
        this: *mut atmosphere,
        r0_: f32,
        L0: f32,
        _L_: f32,
        _NXY_PUPIL_: ::std::os::raw::c_int,
        field_size: f32,
        duration: f32,
        fullpath_to_phasescreens: *const ::std::os::raw::c_char,
        _N_DURATION: ::std::os::raw::c_int,
        _RAND_SEED_: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere10gmt_set_idEi"]
    pub fn atmosphere_gmt_set_id(this: *mut atmosphere, _ID_: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere11gmt_set_ephEf"]
    pub fn atmosphere_gmt_set_eph(this: *mut atmosphere, _EPH_: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere7cleanupEv"]
    pub fn atmosphere_cleanup(this: *mut atmosphere);
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere4infoEv"]
    pub fn atmosphere_info(this: *mut atmosphere);
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere5resetEv"]
    pub fn atmosphere_reset(this: *mut atmosphere);
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere23save_layer_phasescreensEPKci"]
    pub fn atmosphere_save_layer_phasescreens(
        this: *mut atmosphere,
        fullpath_to_phasescreens: *const ::std::os::raw::c_char,
        _N_DURATION: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere16get_phase_screenEPfPKfS2_iP6sourcef"]
    pub fn atmosphere_get_phase_screen(
        this: *mut atmosphere,
        phase_screen: *mut f32,
        x: *const f32,
        y: *const f32,
        N_xy: ::std::os::raw::c_int,
        src: *mut source,
        time: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere16get_phase_screenEPKfS1_iP6sourcef"]
    pub fn atmosphere_get_phase_screen1(
        this: *mut atmosphere,
        x: *const f32,
        y: *const f32,
        N_xy: ::std::os::raw::c_int,
        src: *mut source,
        time: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere16get_phase_screenEfifiP6sourcef"]
    pub fn atmosphere_get_phase_screen2(
        this: *mut atmosphere,
        delta_x: f32,
        N_x: ::std::os::raw::c_int,
        delta_y: f32,
        N_y: ::std::os::raw::c_int,
        src: *mut source,
        time: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere16get_phase_screenEPffifiP6sourcef"]
    pub fn atmosphere_get_phase_screen3(
        this: *mut atmosphere,
        phase_screen: *mut f32,
        delta_x: f32,
        N_x: ::std::os::raw::c_int,
        delta_y: f32,
        N_y: ::std::os::raw::c_int,
        src: *mut source,
        time: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere16get_phase_screenEP6sourcefifif"]
    pub fn atmosphere_get_phase_screen4(
        this: *mut atmosphere,
        src: *mut source,
        delta_x: f32,
        N_x: ::std::os::raw::c_int,
        delta_y: f32,
        N_y: ::std::os::raw::c_int,
        time: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere16get_phase_screenEP6sourcefififf"]
    pub fn atmosphere_get_phase_screen5(
        this: *mut atmosphere,
        src: *mut source,
        delta_x: f32,
        N_x: ::std::os::raw::c_int,
        delta_y: f32,
        N_y: ::std::os::raw::c_int,
        time: f32,
        exponent: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere16get_phase_screenEP6sourceififif"]
    pub fn atmosphere_get_phase_screen6(
        this: *mut atmosphere,
        src: *mut source,
        N_SRC: ::std::os::raw::c_int,
        delta_x: f32,
        N_x: ::std::os::raw::c_int,
        delta_y: f32,
        N_y: ::std::os::raw::c_int,
        time: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere16get_phase_screenEP6sourcef"]
    pub fn atmosphere_get_phase_screen7(this: *mut atmosphere, src: *mut source, time: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere25get_phase_screen_gradientEPfS0_S0_S0_iP6sourcef"]
    pub fn atmosphere_get_phase_screen_gradient(
        this: *mut atmosphere,
        sx: *mut f32,
        sy: *mut f32,
        x: *mut f32,
        y: *mut f32,
        Nxy: ::std::os::raw::c_int,
        src: *mut source,
        time: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere25get_phase_screen_gradientEPfS0_ifP6sourcef"]
    pub fn atmosphere_get_phase_screen_gradient1(
        this: *mut atmosphere,
        sx: *mut f32,
        sy: *mut f32,
        NL: ::std::os::raw::c_int,
        d: f32,
        src: *mut source,
        time: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere25get_phase_screen_gradientEPfS0_iPcfP6sourcef"]
    pub fn atmosphere_get_phase_screen_gradient2(
        this: *mut atmosphere,
        sx: *mut f32,
        sy: *mut f32,
        NL: ::std::os::raw::c_int,
        valid_lenslet: *mut ::std::os::raw::c_char,
        d: f32,
        src: *mut source,
        time: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere25get_phase_screen_gradientEP11centroidingifP6sourcef"]
    pub fn atmosphere_get_phase_screen_gradient3(
        this: *mut atmosphere,
        cog: *mut centroiding,
        NL: ::std::os::raw::c_int,
        d: f32,
        src: *mut source,
        time: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere41get_phase_screen_gradient_rolling_shutterEP11centroidingifP6sourceff"]
    pub fn atmosphere_get_phase_screen_gradient_rolling_shutter(
        this: *mut atmosphere,
        cog: *mut centroiding,
        NL: ::std::os::raw::c_int,
        d: f32,
        src: *mut source,
        time: f32,
        delay: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere25get_phase_screen_gradientEP11centroidingifP6sourceif"]
    pub fn atmosphere_get_phase_screen_gradient4(
        this: *mut atmosphere,
        cog: *mut centroiding,
        NL: ::std::os::raw::c_int,
        d: f32,
        src: *mut source,
        N_SRC: ::std::os::raw::c_int,
        time: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere25get_phase_screen_gradientEP11centroidingiPcfP6sourceif"]
    pub fn atmosphere_get_phase_screen_gradient5(
        this: *mut atmosphere,
        cog: *mut centroiding,
        NL: ::std::os::raw::c_int,
        valid_lenslet: *mut ::std::os::raw::c_char,
        d: f32,
        src: *mut source,
        N_SRC: ::std::os::raw::c_int,
        time: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere31get_phase_screen_circ_centroidsEP11centroidingfP6sourceif"]
    pub fn atmosphere_get_phase_screen_circ_centroids(
        this: *mut atmosphere,
        cog: *mut centroiding,
        R: f32,
        src: *mut source,
        N_SRC: ::std::os::raw::c_int,
        time: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere38get_phase_screen_circ_uplink_centroidsEP11centroidingfP6sourceifc"]
    pub fn atmosphere_get_phase_screen_circ_uplink_centroids(
        this: *mut atmosphere,
        cog: *mut centroiding,
        R: f32,
        src: *mut source,
        N_SRC: ::std::os::raw::c_int,
        time: f32,
        focused: ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere10rayTracingEPKfS1_PfiPK6sourcef"]
    pub fn atmosphere_rayTracing(
        this: *mut atmosphere,
        x_PUPIL: *const f32,
        y_PUPIL: *const f32,
        phase_screen_PUPIL: *mut f32,
        NXY_PUPIL: ::std::os::raw::c_int,
        src: *const source,
        tau: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN10atmosphere10rayTracingEP6sourcefifif"]
    pub fn atmosphere_rayTracing1(
        this: *mut atmosphere,
        src: *mut source,
        delta_x: f32,
        N_X: ::std::os::raw::c_int,
        delta_y: f32,
        N_Y: ::std::os::raw::c_int,
        tau: f32,
    );
}
impl atmosphere {
    #[inline]
    pub unsafe fn setup(
        &mut self,
        r0_: f32,
        L0: f32,
        N_LAYER: ::std::os::raw::c_int,
        altitude: *mut f32,
        xi0: *mut f32,
        wind_speed: *mut f32,
        wind_direction: *mut f32,
    ) {
        atmosphere_setup(
            self,
            r0_,
            L0,
            N_LAYER,
            altitude,
            xi0,
            wind_speed,
            wind_direction,
        )
    }
    #[inline]
    pub unsafe fn setup1(
        &mut self,
        r0_: f32,
        L0: f32,
        N_LAYER: ::std::os::raw::c_int,
        altitude: *mut f32,
        xi0: *mut f32,
        wind_speed: *mut f32,
        wind_direction: *mut f32,
        _L_: f32,
        _NXY_PUPIL_: ::std::os::raw::c_int,
        field_size: f32,
        duration: f32,
    ) {
        atmosphere_setup1(
            self,
            r0_,
            L0,
            N_LAYER,
            altitude,
            xi0,
            wind_speed,
            wind_direction,
            _L_,
            _NXY_PUPIL_,
            field_size,
            duration,
        )
    }
    #[inline]
    pub unsafe fn setup2(
        &mut self,
        r0_: f32,
        L0: f32,
        _NLAYER: ::std::os::raw::c_int,
        altitude: *mut f32,
        xi0: *mut f32,
        wind_speed: *mut f32,
        wind_direction: *mut f32,
        _L_: f32,
        _NXY_PUPIL_: ::std::os::raw::c_int,
        field_size: f32,
        duration: f32,
        fullpath_to_phasescreens: *const ::std::os::raw::c_char,
        _N_DURATION: ::std::os::raw::c_int,
    ) {
        atmosphere_setup2(
            self,
            r0_,
            L0,
            _NLAYER,
            altitude,
            xi0,
            wind_speed,
            wind_direction,
            _L_,
            _NXY_PUPIL_,
            field_size,
            duration,
            fullpath_to_phasescreens,
            _N_DURATION,
        )
    }
    #[inline]
    pub unsafe fn gmt_setup(&mut self) {
        atmosphere_gmt_setup(self)
    }
    #[inline]
    pub unsafe fn gmt_setup1(&mut self, r0_: f32, L0: f32) {
        atmosphere_gmt_setup1(self, r0_, L0)
    }
    #[inline]
    pub unsafe fn gmt_setup2(
        &mut self,
        r0_: f32,
        L0: f32,
        _L_: f32,
        _NXY_PUPIL_: ::std::os::raw::c_int,
        field_size: f32,
        duration: f32,
    ) {
        atmosphere_gmt_setup2(self, r0_, L0, _L_, _NXY_PUPIL_, field_size, duration)
    }
    #[inline]
    pub unsafe fn gmt_setup3(
        &mut self,
        r0_: f32,
        L0: f32,
        _L_: f32,
        _NXY_PUPIL_: ::std::os::raw::c_int,
        field_size: f32,
        duration: f32,
        fullpath_to_phasescreens: *const ::std::os::raw::c_char,
        _N_DURATION: ::std::os::raw::c_int,
    ) {
        atmosphere_gmt_setup3(
            self,
            r0_,
            L0,
            _L_,
            _NXY_PUPIL_,
            field_size,
            duration,
            fullpath_to_phasescreens,
            _N_DURATION,
        )
    }
    #[inline]
    pub unsafe fn gmt_setup4(&mut self, r0_: f32, L0: f32, _RAND_SEED_: ::std::os::raw::c_int) {
        atmosphere_gmt_setup4(self, r0_, L0, _RAND_SEED_)
    }
    #[inline]
    pub unsafe fn gmt_setup5(
        &mut self,
        r0_: f32,
        L0: f32,
        _L_: f32,
        _NXY_PUPIL_: ::std::os::raw::c_int,
        field_size: f32,
        duration: f32,
        _RAND_SEED_: ::std::os::raw::c_int,
    ) {
        atmosphere_gmt_setup5(
            self,
            r0_,
            L0,
            _L_,
            _NXY_PUPIL_,
            field_size,
            duration,
            _RAND_SEED_,
        )
    }
    #[inline]
    pub unsafe fn gmt_setup6(
        &mut self,
        r0_: f32,
        L0: f32,
        _L_: f32,
        _NXY_PUPIL_: ::std::os::raw::c_int,
        field_size: f32,
        duration: f32,
        fullpath_to_phasescreens: *const ::std::os::raw::c_char,
        _N_DURATION: ::std::os::raw::c_int,
        _RAND_SEED_: ::std::os::raw::c_int,
    ) {
        atmosphere_gmt_setup6(
            self,
            r0_,
            L0,
            _L_,
            _NXY_PUPIL_,
            field_size,
            duration,
            fullpath_to_phasescreens,
            _N_DURATION,
            _RAND_SEED_,
        )
    }
    #[inline]
    pub unsafe fn gmt_set_id(&mut self, _ID_: ::std::os::raw::c_int) {
        atmosphere_gmt_set_id(self, _ID_)
    }
    #[inline]
    pub unsafe fn gmt_set_eph(&mut self, _EPH_: f32) {
        atmosphere_gmt_set_eph(self, _EPH_)
    }
    #[inline]
    pub unsafe fn cleanup(&mut self) {
        atmosphere_cleanup(self)
    }
    #[inline]
    pub unsafe fn info(&mut self) {
        atmosphere_info(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        atmosphere_reset(self)
    }
    #[inline]
    pub unsafe fn save_layer_phasescreens(
        &mut self,
        fullpath_to_phasescreens: *const ::std::os::raw::c_char,
        _N_DURATION: ::std::os::raw::c_int,
    ) {
        atmosphere_save_layer_phasescreens(self, fullpath_to_phasescreens, _N_DURATION)
    }
    #[inline]
    pub unsafe fn get_phase_screen(
        &mut self,
        phase_screen: *mut f32,
        x: *const f32,
        y: *const f32,
        N_xy: ::std::os::raw::c_int,
        src: *mut source,
        time: f32,
    ) {
        atmosphere_get_phase_screen(self, phase_screen, x, y, N_xy, src, time)
    }
    #[inline]
    pub unsafe fn get_phase_screen1(
        &mut self,
        x: *const f32,
        y: *const f32,
        N_xy: ::std::os::raw::c_int,
        src: *mut source,
        time: f32,
    ) {
        atmosphere_get_phase_screen1(self, x, y, N_xy, src, time)
    }
    #[inline]
    pub unsafe fn get_phase_screen2(
        &mut self,
        delta_x: f32,
        N_x: ::std::os::raw::c_int,
        delta_y: f32,
        N_y: ::std::os::raw::c_int,
        src: *mut source,
        time: f32,
    ) {
        atmosphere_get_phase_screen2(self, delta_x, N_x, delta_y, N_y, src, time)
    }
    #[inline]
    pub unsafe fn get_phase_screen3(
        &mut self,
        phase_screen: *mut f32,
        delta_x: f32,
        N_x: ::std::os::raw::c_int,
        delta_y: f32,
        N_y: ::std::os::raw::c_int,
        src: *mut source,
        time: f32,
    ) {
        atmosphere_get_phase_screen3(self, phase_screen, delta_x, N_x, delta_y, N_y, src, time)
    }
    #[inline]
    pub unsafe fn get_phase_screen4(
        &mut self,
        src: *mut source,
        delta_x: f32,
        N_x: ::std::os::raw::c_int,
        delta_y: f32,
        N_y: ::std::os::raw::c_int,
        time: f32,
    ) {
        atmosphere_get_phase_screen4(self, src, delta_x, N_x, delta_y, N_y, time)
    }
    #[inline]
    pub unsafe fn get_phase_screen5(
        &mut self,
        src: *mut source,
        delta_x: f32,
        N_x: ::std::os::raw::c_int,
        delta_y: f32,
        N_y: ::std::os::raw::c_int,
        time: f32,
        exponent: f32,
    ) {
        atmosphere_get_phase_screen5(self, src, delta_x, N_x, delta_y, N_y, time, exponent)
    }
    #[inline]
    pub unsafe fn get_phase_screen6(
        &mut self,
        src: *mut source,
        N_SRC: ::std::os::raw::c_int,
        delta_x: f32,
        N_x: ::std::os::raw::c_int,
        delta_y: f32,
        N_y: ::std::os::raw::c_int,
        time: f32,
    ) {
        atmosphere_get_phase_screen6(self, src, N_SRC, delta_x, N_x, delta_y, N_y, time)
    }
    #[inline]
    pub unsafe fn get_phase_screen7(&mut self, src: *mut source, time: f32) {
        atmosphere_get_phase_screen7(self, src, time)
    }
    #[inline]
    pub unsafe fn get_phase_screen_gradient(
        &mut self,
        sx: *mut f32,
        sy: *mut f32,
        x: *mut f32,
        y: *mut f32,
        Nxy: ::std::os::raw::c_int,
        src: *mut source,
        time: f32,
    ) {
        atmosphere_get_phase_screen_gradient(self, sx, sy, x, y, Nxy, src, time)
    }
    #[inline]
    pub unsafe fn get_phase_screen_gradient1(
        &mut self,
        sx: *mut f32,
        sy: *mut f32,
        NL: ::std::os::raw::c_int,
        d: f32,
        src: *mut source,
        time: f32,
    ) {
        atmosphere_get_phase_screen_gradient1(self, sx, sy, NL, d, src, time)
    }
    #[inline]
    pub unsafe fn get_phase_screen_gradient2(
        &mut self,
        sx: *mut f32,
        sy: *mut f32,
        NL: ::std::os::raw::c_int,
        valid_lenslet: *mut ::std::os::raw::c_char,
        d: f32,
        src: *mut source,
        time: f32,
    ) {
        atmosphere_get_phase_screen_gradient2(self, sx, sy, NL, valid_lenslet, d, src, time)
    }
    #[inline]
    pub unsafe fn get_phase_screen_gradient3(
        &mut self,
        cog: *mut centroiding,
        NL: ::std::os::raw::c_int,
        d: f32,
        src: *mut source,
        time: f32,
    ) {
        atmosphere_get_phase_screen_gradient3(self, cog, NL, d, src, time)
    }
    #[inline]
    pub unsafe fn get_phase_screen_gradient_rolling_shutter(
        &mut self,
        cog: *mut centroiding,
        NL: ::std::os::raw::c_int,
        d: f32,
        src: *mut source,
        time: f32,
        delay: f32,
    ) {
        atmosphere_get_phase_screen_gradient_rolling_shutter(self, cog, NL, d, src, time, delay)
    }
    #[inline]
    pub unsafe fn get_phase_screen_gradient4(
        &mut self,
        cog: *mut centroiding,
        NL: ::std::os::raw::c_int,
        d: f32,
        src: *mut source,
        N_SRC: ::std::os::raw::c_int,
        time: f32,
    ) {
        atmosphere_get_phase_screen_gradient4(self, cog, NL, d, src, N_SRC, time)
    }
    #[inline]
    pub unsafe fn get_phase_screen_gradient5(
        &mut self,
        cog: *mut centroiding,
        NL: ::std::os::raw::c_int,
        valid_lenslet: *mut ::std::os::raw::c_char,
        d: f32,
        src: *mut source,
        N_SRC: ::std::os::raw::c_int,
        time: f32,
    ) {
        atmosphere_get_phase_screen_gradient5(self, cog, NL, valid_lenslet, d, src, N_SRC, time)
    }
    #[inline]
    pub unsafe fn get_phase_screen_circ_centroids(
        &mut self,
        cog: *mut centroiding,
        R: f32,
        src: *mut source,
        N_SRC: ::std::os::raw::c_int,
        time: f32,
    ) {
        atmosphere_get_phase_screen_circ_centroids(self, cog, R, src, N_SRC, time)
    }
    #[inline]
    pub unsafe fn get_phase_screen_circ_uplink_centroids(
        &mut self,
        cog: *mut centroiding,
        R: f32,
        src: *mut source,
        N_SRC: ::std::os::raw::c_int,
        time: f32,
        focused: ::std::os::raw::c_char,
    ) {
        atmosphere_get_phase_screen_circ_uplink_centroids(self, cog, R, src, N_SRC, time, focused)
    }
    #[inline]
    pub unsafe fn rayTracing(
        &mut self,
        x_PUPIL: *const f32,
        y_PUPIL: *const f32,
        phase_screen_PUPIL: *mut f32,
        NXY_PUPIL: ::std::os::raw::c_int,
        src: *const source,
        tau: f32,
    ) {
        atmosphere_rayTracing(
            self,
            x_PUPIL,
            y_PUPIL,
            phase_screen_PUPIL,
            NXY_PUPIL,
            src,
            tau,
        )
    }
    #[inline]
    pub unsafe fn rayTracing1(
        &mut self,
        src: *mut source,
        delta_x: f32,
        N_X: ::std::os::raw::c_int,
        delta_y: f32,
        N_Y: ::std::os::raw::c_int,
        tau: f32,
    ) {
        atmosphere_rayTracing1(self, src, delta_x, N_X, delta_y, N_Y, tau)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aaStats {
    pub N: ::std::os::raw::c_int,
    pub N2: ::std::os::raw::c_int,
    pub NU: ::std::os::raw::c_int,
    pub NU2: ::std::os::raw::c_int,
    pub NF: ::std::os::raw::c_int,
    pub NF2: ::std::os::raw::c_int,
    pub psd_size: ::std::os::raw::c_int,
    pub cov_size: ::std::os::raw::c_int,
    pub ind_size: ::std::os::raw::c_int,
    pub d__psd: *mut float2,
    pub d__cov: *mut f32,
    pub d__alpha: *mut f32,
    pub d__beta: *mut f32,
    pub n_full: f32,
    pub n_comp: f32,
    pub b_full: f32,
    pub b_comp: f32,
    pub cov_eval_et: f32,
    pub sampling: f32,
    pub plan: cufftHandle,
    pub N_SRC2: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of aaStats"][::std::mem::size_of::<aaStats>() - 104usize];
    ["Alignment of aaStats"][::std::mem::align_of::<aaStats>() - 8usize];
    ["Offset of field: aaStats::N"][::std::mem::offset_of!(aaStats, N) - 0usize];
    ["Offset of field: aaStats::N2"][::std::mem::offset_of!(aaStats, N2) - 4usize];
    ["Offset of field: aaStats::NU"][::std::mem::offset_of!(aaStats, NU) - 8usize];
    ["Offset of field: aaStats::NU2"][::std::mem::offset_of!(aaStats, NU2) - 12usize];
    ["Offset of field: aaStats::NF"][::std::mem::offset_of!(aaStats, NF) - 16usize];
    ["Offset of field: aaStats::NF2"][::std::mem::offset_of!(aaStats, NF2) - 20usize];
    ["Offset of field: aaStats::psd_size"][::std::mem::offset_of!(aaStats, psd_size) - 24usize];
    ["Offset of field: aaStats::cov_size"][::std::mem::offset_of!(aaStats, cov_size) - 28usize];
    ["Offset of field: aaStats::ind_size"][::std::mem::offset_of!(aaStats, ind_size) - 32usize];
    ["Offset of field: aaStats::d__psd"][::std::mem::offset_of!(aaStats, d__psd) - 40usize];
    ["Offset of field: aaStats::d__cov"][::std::mem::offset_of!(aaStats, d__cov) - 48usize];
    ["Offset of field: aaStats::d__alpha"][::std::mem::offset_of!(aaStats, d__alpha) - 56usize];
    ["Offset of field: aaStats::d__beta"][::std::mem::offset_of!(aaStats, d__beta) - 64usize];
    ["Offset of field: aaStats::n_full"][::std::mem::offset_of!(aaStats, n_full) - 72usize];
    ["Offset of field: aaStats::n_comp"][::std::mem::offset_of!(aaStats, n_comp) - 76usize];
    ["Offset of field: aaStats::b_full"][::std::mem::offset_of!(aaStats, b_full) - 80usize];
    ["Offset of field: aaStats::b_comp"][::std::mem::offset_of!(aaStats, b_comp) - 84usize];
    ["Offset of field: aaStats::cov_eval_et"]
        [::std::mem::offset_of!(aaStats, cov_eval_et) - 88usize];
    ["Offset of field: aaStats::sampling"][::std::mem::offset_of!(aaStats, sampling) - 92usize];
    ["Offset of field: aaStats::plan"][::std::mem::offset_of!(aaStats, plan) - 96usize];
    ["Offset of field: aaStats::N_SRC2"][::std::mem::offset_of!(aaStats, N_SRC2) - 100usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN7aaStats5setupEiPK10atmospherefPK6sourcei"]
    pub fn aaStats_setup(
        this: *mut aaStats,
        N: ::std::os::raw::c_int,
        atm: *const atmosphere,
        lenslet_pitch: f32,
        src: *const source,
        N_SRC: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7aaStats7cleanupEv"]
    pub fn aaStats_cleanup(this: *mut aaStats);
}
extern "C" {
    #[link_name = "\u{1}_ZN7aaStats4infoEif"]
    pub fn aaStats_info(this: *mut aaStats, kappa: ::std::os::raw::c_int, d: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN7aaStats8varianceEv"]
    pub fn aaStats_variance(this: *mut aaStats) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN7aaStats6toFileEPc"]
    pub fn aaStats_toFile(this: *mut aaStats, filename: *mut ::std::os::raw::c_char);
}
impl aaStats {
    #[inline]
    pub unsafe fn setup(
        &mut self,
        N: ::std::os::raw::c_int,
        atm: *const atmosphere,
        lenslet_pitch: f32,
        src: *const source,
        N_SRC: ::std::os::raw::c_int,
    ) {
        aaStats_setup(self, N, atm, lenslet_pitch, src, N_SRC)
    }
    #[inline]
    pub unsafe fn cleanup(&mut self) {
        aaStats_cleanup(self)
    }
    #[inline]
    pub unsafe fn info(&mut self, kappa: ::std::os::raw::c_int, d: f32) {
        aaStats_info(self, kappa, d)
    }
    #[inline]
    pub unsafe fn variance(&mut self) -> f32 {
        aaStats_variance(self)
    }
    #[inline]
    pub unsafe fn toFile(&mut self, filename: *mut ::std::os::raw::c_char) {
        aaStats_toFile(self, filename)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct paStats {
    pub osf: ::std::os::raw::c_int,
    pub M: ::std::os::raw::c_int,
    pub shift: ::std::os::raw::c_int,
    pub M_LAYER: *mut ::std::os::raw::c_int,
    pub N: ::std::os::raw::c_int,
    pub N2: ::std::os::raw::c_int,
    pub NU: ::std::os::raw::c_int,
    pub NU2: ::std::os::raw::c_int,
    pub NF: ::std::os::raw::c_int,
    pub NF2: ::std::os::raw::c_int,
    pub psd_size: ::std::os::raw::c_int,
    pub cov_size: ::std::os::raw::c_int,
    pub ind_size: ::std::os::raw::c_int,
    pub d__psd: *mut float2,
    pub d__cov: *mut f32,
    pub d__alpha: *mut f32,
    pub d__beta: *mut f32,
    pub n_full: f32,
    pub n_comp: f32,
    pub b_full: f32,
    pub b_comp: f32,
    pub cov_eval_et: f32,
    pub sampling: f32,
    pub plan: cufftHandle,
    pub N_SRC2: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of paStats"][::std::mem::size_of::<paStats>() - 128usize];
    ["Alignment of paStats"][::std::mem::align_of::<paStats>() - 8usize];
    ["Offset of field: paStats::osf"][::std::mem::offset_of!(paStats, osf) - 0usize];
    ["Offset of field: paStats::M"][::std::mem::offset_of!(paStats, M) - 4usize];
    ["Offset of field: paStats::shift"][::std::mem::offset_of!(paStats, shift) - 8usize];
    ["Offset of field: paStats::M_LAYER"][::std::mem::offset_of!(paStats, M_LAYER) - 16usize];
    ["Offset of field: paStats::N"][::std::mem::offset_of!(paStats, N) - 24usize];
    ["Offset of field: paStats::N2"][::std::mem::offset_of!(paStats, N2) - 28usize];
    ["Offset of field: paStats::NU"][::std::mem::offset_of!(paStats, NU) - 32usize];
    ["Offset of field: paStats::NU2"][::std::mem::offset_of!(paStats, NU2) - 36usize];
    ["Offset of field: paStats::NF"][::std::mem::offset_of!(paStats, NF) - 40usize];
    ["Offset of field: paStats::NF2"][::std::mem::offset_of!(paStats, NF2) - 44usize];
    ["Offset of field: paStats::psd_size"][::std::mem::offset_of!(paStats, psd_size) - 48usize];
    ["Offset of field: paStats::cov_size"][::std::mem::offset_of!(paStats, cov_size) - 52usize];
    ["Offset of field: paStats::ind_size"][::std::mem::offset_of!(paStats, ind_size) - 56usize];
    ["Offset of field: paStats::d__psd"][::std::mem::offset_of!(paStats, d__psd) - 64usize];
    ["Offset of field: paStats::d__cov"][::std::mem::offset_of!(paStats, d__cov) - 72usize];
    ["Offset of field: paStats::d__alpha"][::std::mem::offset_of!(paStats, d__alpha) - 80usize];
    ["Offset of field: paStats::d__beta"][::std::mem::offset_of!(paStats, d__beta) - 88usize];
    ["Offset of field: paStats::n_full"][::std::mem::offset_of!(paStats, n_full) - 96usize];
    ["Offset of field: paStats::n_comp"][::std::mem::offset_of!(paStats, n_comp) - 100usize];
    ["Offset of field: paStats::b_full"][::std::mem::offset_of!(paStats, b_full) - 104usize];
    ["Offset of field: paStats::b_comp"][::std::mem::offset_of!(paStats, b_comp) - 108usize];
    ["Offset of field: paStats::cov_eval_et"]
        [::std::mem::offset_of!(paStats, cov_eval_et) - 112usize];
    ["Offset of field: paStats::sampling"][::std::mem::offset_of!(paStats, sampling) - 116usize];
    ["Offset of field: paStats::plan"][::std::mem::offset_of!(paStats, plan) - 120usize];
    ["Offset of field: paStats::N_SRC2"][::std::mem::offset_of!(paStats, N_SRC2) - 124usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN7paStats5setupEiiiPK10atmospherefP6sourceiPKS3_i"]
    pub fn paStats_setup(
        this: *mut paStats,
        M_: ::std::os::raw::c_int,
        N_: ::std::os::raw::c_int,
        osf_: ::std::os::raw::c_int,
        atm: *const atmosphere,
        lenslet_pitch: f32,
        phase_src: *mut source,
        N_P_SRC: ::std::os::raw::c_int,
        slopes_src: *const source,
        N_S_SRC: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7paStats5setupEiiiPK10atmospherefPK6sourceif"]
    pub fn paStats_setup1(
        this: *mut paStats,
        M_: ::std::os::raw::c_int,
        N_: ::std::os::raw::c_int,
        osf_: ::std::os::raw::c_int,
        atm: *const atmosphere,
        lenslet_pitch: f32,
        slopes_src: *const source,
        N_S_SRC: ::std::os::raw::c_int,
        z_radius: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7paStats7cleanupEv"]
    pub fn paStats_cleanup(this: *mut paStats);
}
extern "C" {
    #[link_name = "\u{1}_ZN7paStats4infoEif"]
    pub fn paStats_info(this: *mut paStats, kappa: ::std::os::raw::c_int, d: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN7paStats3MVMEPfS0_ffifiP10atmosphereP6sourceiS4_i"]
    pub fn paStats_MVM(
        this: *mut paStats,
        out_vector: *mut f32,
        in_vector: *mut f32,
        d1: f32,
        g1: f32,
        N1: ::std::os::raw::c_int,
        d2: f32,
        N2: ::std::os::raw::c_int,
        atm: *mut atmosphere,
        phase_src: *mut source,
        N_P_SRC: ::std::os::raw::c_int,
        slopes_src: *mut source,
        N_S_SRC: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7paStats6toFileEPc"]
    pub fn paStats_toFile(this: *mut paStats, filename: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_ZN7paStats8varianceEv"]
    pub fn paStats_variance(this: *mut paStats);
}
impl paStats {
    #[inline]
    pub unsafe fn setup(
        &mut self,
        M_: ::std::os::raw::c_int,
        N_: ::std::os::raw::c_int,
        osf_: ::std::os::raw::c_int,
        atm: *const atmosphere,
        lenslet_pitch: f32,
        phase_src: *mut source,
        N_P_SRC: ::std::os::raw::c_int,
        slopes_src: *const source,
        N_S_SRC: ::std::os::raw::c_int,
    ) {
        paStats_setup(
            self,
            M_,
            N_,
            osf_,
            atm,
            lenslet_pitch,
            phase_src,
            N_P_SRC,
            slopes_src,
            N_S_SRC,
        )
    }
    #[inline]
    pub unsafe fn setup1(
        &mut self,
        M_: ::std::os::raw::c_int,
        N_: ::std::os::raw::c_int,
        osf_: ::std::os::raw::c_int,
        atm: *const atmosphere,
        lenslet_pitch: f32,
        slopes_src: *const source,
        N_S_SRC: ::std::os::raw::c_int,
        z_radius: f32,
    ) {
        paStats_setup1(
            self,
            M_,
            N_,
            osf_,
            atm,
            lenslet_pitch,
            slopes_src,
            N_S_SRC,
            z_radius,
        )
    }
    #[inline]
    pub unsafe fn cleanup(&mut self) {
        paStats_cleanup(self)
    }
    #[inline]
    pub unsafe fn info(&mut self, kappa: ::std::os::raw::c_int, d: f32) {
        paStats_info(self, kappa, d)
    }
    #[inline]
    pub unsafe fn MVM(
        &mut self,
        out_vector: *mut f32,
        in_vector: *mut f32,
        d1: f32,
        g1: f32,
        N1: ::std::os::raw::c_int,
        d2: f32,
        N2: ::std::os::raw::c_int,
        atm: *mut atmosphere,
        phase_src: *mut source,
        N_P_SRC: ::std::os::raw::c_int,
        slopes_src: *mut source,
        N_S_SRC: ::std::os::raw::c_int,
    ) {
        paStats_MVM(
            self, out_vector, in_vector, d1, g1, N1, d2, N2, atm, phase_src, N_P_SRC, slopes_src,
            N_S_SRC,
        )
    }
    #[inline]
    pub unsafe fn toFile(&mut self, filename: *mut ::std::os::raw::c_char) {
        paStats_toFile(self, filename)
    }
    #[inline]
    pub unsafe fn variance(&mut self) {
        paStats_variance(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BTBT {
    pub M: ::std::os::raw::c_int,
    pub N: ::std::os::raw::c_int,
    pub MT: ::std::os::raw::c_int,
    pub MT2: ::std::os::raw::c_int,
    pub NT: ::std::os::raw::c_int,
    pub NT2: ::std::os::raw::c_int,
    pub NU: ::std::os::raw::c_int,
    pub NU2: ::std::os::raw::c_int,
    pub NDFT: ::std::os::raw::c_int,
    pub HALF_NDFT: ::std::os::raw::c_int,
    pub NU_TOTAL: ::std::os::raw::c_int,
    pub NF: ::std::os::raw::c_int,
    pub NF2: ::std::os::raw::c_int,
    pub ind_size: ::std::os::raw::c_int,
    pub cov_size: ::std::os::raw::c_int,
    pub mask: *mut ::std::os::raw::c_char,
    pub d__cov: *mut float2,
    pub d__b: *mut float2,
    pub d__c: *mut float2,
    pub d__alpha: *mut f32,
    pub d__beta: *mut f32,
    pub n_full: f32,
    pub n_comp: f32,
    pub b_full: f32,
    pub b_comp: f32,
    pub cov_eval_et: f32,
    pub d__mu: *mut ::std::os::raw::c_uint,
    pub d__xi: *mut ::std::os::raw::c_uint,
    pub raster_plan: cufftHandle,
    pub MVM_input_plan: cufftHandle,
    pub MVM_output_plan: cufftHandle,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of BTBT"][::std::mem::size_of::<BTBT>() - 168usize];
    ["Alignment of BTBT"][::std::mem::align_of::<BTBT>() - 8usize];
    ["Offset of field: BTBT::M"][::std::mem::offset_of!(BTBT, M) - 0usize];
    ["Offset of field: BTBT::N"][::std::mem::offset_of!(BTBT, N) - 4usize];
    ["Offset of field: BTBT::MT"][::std::mem::offset_of!(BTBT, MT) - 8usize];
    ["Offset of field: BTBT::MT2"][::std::mem::offset_of!(BTBT, MT2) - 12usize];
    ["Offset of field: BTBT::NT"][::std::mem::offset_of!(BTBT, NT) - 16usize];
    ["Offset of field: BTBT::NT2"][::std::mem::offset_of!(BTBT, NT2) - 20usize];
    ["Offset of field: BTBT::NU"][::std::mem::offset_of!(BTBT, NU) - 24usize];
    ["Offset of field: BTBT::NU2"][::std::mem::offset_of!(BTBT, NU2) - 28usize];
    ["Offset of field: BTBT::NDFT"][::std::mem::offset_of!(BTBT, NDFT) - 32usize];
    ["Offset of field: BTBT::HALF_NDFT"][::std::mem::offset_of!(BTBT, HALF_NDFT) - 36usize];
    ["Offset of field: BTBT::NU_TOTAL"][::std::mem::offset_of!(BTBT, NU_TOTAL) - 40usize];
    ["Offset of field: BTBT::NF"][::std::mem::offset_of!(BTBT, NF) - 44usize];
    ["Offset of field: BTBT::NF2"][::std::mem::offset_of!(BTBT, NF2) - 48usize];
    ["Offset of field: BTBT::ind_size"][::std::mem::offset_of!(BTBT, ind_size) - 52usize];
    ["Offset of field: BTBT::cov_size"][::std::mem::offset_of!(BTBT, cov_size) - 56usize];
    ["Offset of field: BTBT::mask"][::std::mem::offset_of!(BTBT, mask) - 64usize];
    ["Offset of field: BTBT::d__cov"][::std::mem::offset_of!(BTBT, d__cov) - 72usize];
    ["Offset of field: BTBT::d__b"][::std::mem::offset_of!(BTBT, d__b) - 80usize];
    ["Offset of field: BTBT::d__c"][::std::mem::offset_of!(BTBT, d__c) - 88usize];
    ["Offset of field: BTBT::d__alpha"][::std::mem::offset_of!(BTBT, d__alpha) - 96usize];
    ["Offset of field: BTBT::d__beta"][::std::mem::offset_of!(BTBT, d__beta) - 104usize];
    ["Offset of field: BTBT::n_full"][::std::mem::offset_of!(BTBT, n_full) - 112usize];
    ["Offset of field: BTBT::n_comp"][::std::mem::offset_of!(BTBT, n_comp) - 116usize];
    ["Offset of field: BTBT::b_full"][::std::mem::offset_of!(BTBT, b_full) - 120usize];
    ["Offset of field: BTBT::b_comp"][::std::mem::offset_of!(BTBT, b_comp) - 124usize];
    ["Offset of field: BTBT::cov_eval_et"][::std::mem::offset_of!(BTBT, cov_eval_et) - 128usize];
    ["Offset of field: BTBT::d__mu"][::std::mem::offset_of!(BTBT, d__mu) - 136usize];
    ["Offset of field: BTBT::d__xi"][::std::mem::offset_of!(BTBT, d__xi) - 144usize];
    ["Offset of field: BTBT::raster_plan"][::std::mem::offset_of!(BTBT, raster_plan) - 152usize];
    ["Offset of field: BTBT::MVM_input_plan"]
        [::std::mem::offset_of!(BTBT, MVM_input_plan) - 156usize];
    ["Offset of field: BTBT::MVM_output_plan"]
        [::std::mem::offset_of!(BTBT, MVM_output_plan) - 160usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN4BTBT5setupEi"]
    pub fn BTBT_setup(this: *mut BTBT, n_x: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN4BTBT5setupEiiiPf"]
    pub fn BTBT_setup1(
        this: *mut BTBT,
        M_: ::std::os::raw::c_int,
        N_: ::std::os::raw::c_int,
        NT_: ::std::os::raw::c_int,
        d__cov_: *mut f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4BTBT5setupEiiiiPf"]
    pub fn BTBT_setup2(
        this: *mut BTBT,
        M_: ::std::os::raw::c_int,
        N_: ::std::os::raw::c_int,
        MT_: ::std::os::raw::c_int,
        NT_: ::std::os::raw::c_int,
        d__cov_: *mut f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4BTBT7cleanupEv"]
    pub fn BTBT_cleanup(this: *mut BTBT);
}
extern "C" {
    #[link_name = "\u{1}_ZN4BTBT4infoEv"]
    pub fn BTBT_info(this: *mut BTBT);
}
extern "C" {
    #[link_name = "\u{1}_ZN4BTBT3MVMEPfS0_"]
    pub fn BTBT_MVM(this: *mut BTBT, y: *mut f32, x: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN4BTBT5MVM_iEPfS0_"]
    pub fn BTBT_MVM_i(this: *mut BTBT, y: *mut f32, x: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN4BTBT6MVM_iiEPfS0_"]
    pub fn BTBT_MVM_ii(this: *mut BTBT, y: *mut f32, x: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN4BTBT7MVM_iiiEPfS0_"]
    pub fn BTBT_MVM_iii(this: *mut BTBT, y: *mut f32, x: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN4BTBT6MVM_ivEPfS0_"]
    pub fn BTBT_MVM_iv(this: *mut BTBT, y: *mut f32, x: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN4BTBT5MVM_vEPfS0_"]
    pub fn BTBT_MVM_v(this: *mut BTBT, y: *mut f32, x: *mut f32);
}
impl BTBT {
    #[inline]
    pub unsafe fn setup(&mut self, n_x: ::std::os::raw::c_int) {
        BTBT_setup(self, n_x)
    }
    #[inline]
    pub unsafe fn setup1(
        &mut self,
        M_: ::std::os::raw::c_int,
        N_: ::std::os::raw::c_int,
        NT_: ::std::os::raw::c_int,
        d__cov_: *mut f32,
    ) {
        BTBT_setup1(self, M_, N_, NT_, d__cov_)
    }
    #[inline]
    pub unsafe fn setup2(
        &mut self,
        M_: ::std::os::raw::c_int,
        N_: ::std::os::raw::c_int,
        MT_: ::std::os::raw::c_int,
        NT_: ::std::os::raw::c_int,
        d__cov_: *mut f32,
    ) {
        BTBT_setup2(self, M_, N_, MT_, NT_, d__cov_)
    }
    #[inline]
    pub unsafe fn cleanup(&mut self) {
        BTBT_cleanup(self)
    }
    #[inline]
    pub unsafe fn info(&mut self) {
        BTBT_info(self)
    }
    #[inline]
    pub unsafe fn MVM(&mut self, y: *mut f32, x: *mut f32) {
        BTBT_MVM(self, y, x)
    }
    #[inline]
    pub unsafe fn MVM_i(&mut self, y: *mut f32, x: *mut f32) {
        BTBT_MVM_i(self, y, x)
    }
    #[inline]
    pub unsafe fn MVM_ii(&mut self, y: *mut f32, x: *mut f32) {
        BTBT_MVM_ii(self, y, x)
    }
    #[inline]
    pub unsafe fn MVM_iii(&mut self, y: *mut f32, x: *mut f32) {
        BTBT_MVM_iii(self, y, x)
    }
    #[inline]
    pub unsafe fn MVM_iv(&mut self, y: *mut f32, x: *mut f32) {
        BTBT_MVM_iv(self, y, x)
    }
    #[inline]
    pub unsafe fn MVM_v(&mut self, y: *mut f32, x: *mut f32) {
        BTBT_MVM_v(self, y, x)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GBTBT {
    pub M: ::std::os::raw::c_int,
    pub N: ::std::os::raw::c_int,
    pub NT: ::std::os::raw::c_int,
    pub NT2: ::std::os::raw::c_int,
    pub NDFT: ::std::os::raw::c_int,
    pub HALF_NDFT: ::std::os::raw::c_int,
    pub NU_TOTAL: ::std::os::raw::c_int,
    pub NF: ::std::os::raw::c_int,
    pub NF2: ::std::os::raw::c_int,
    pub ind_size: ::std::os::raw::c_int,
    pub cov_size: ::std::os::raw::c_int,
    pub MT2_TOTAL: ::std::os::raw::c_int,
    pub MT_size: ::std::os::raw::c_int,
    pub MAX_MT: ::std::os::raw::c_int,
    pub MT: *mut ::std::os::raw::c_int,
    pub MT2: *mut ::std::os::raw::c_int,
    pub NU: *mut ::std::os::raw::c_int,
    pub NU2: *mut ::std::os::raw::c_int,
    pub CS_MT2: *mut ::std::os::raw::c_int,
    pub d__MT: *mut ::std::os::raw::c_int,
    pub d__MT2: *mut ::std::os::raw::c_int,
    pub d__NU: *mut ::std::os::raw::c_int,
    pub d__NU2: *mut ::std::os::raw::c_int,
    pub d__CS_MT2: *mut ::std::os::raw::c_int,
    pub mask: *mut ::std::os::raw::c_char,
    pub d__cov: *mut float2,
    pub d__b: *mut float2,
    pub d__c: *mut float2,
    pub d__alpha: *mut f32,
    pub d__beta: *mut f32,
    pub n_full: f32,
    pub n_comp: f32,
    pub b_full: f32,
    pub b_comp: f32,
    pub cov_eval_et: f32,
    pub d__mu: *mut ::std::os::raw::c_uint,
    pub d__xi: *mut ::std::os::raw::c_uint,
    pub raster_plan: cufftHandle,
    pub MVM_input_plan: cufftHandle,
    pub MVM_output_plan: cufftHandle,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GBTBT"][::std::mem::size_of::<GBTBT>() - 240usize];
    ["Alignment of GBTBT"][::std::mem::align_of::<GBTBT>() - 8usize];
    ["Offset of field: GBTBT::M"][::std::mem::offset_of!(GBTBT, M) - 0usize];
    ["Offset of field: GBTBT::N"][::std::mem::offset_of!(GBTBT, N) - 4usize];
    ["Offset of field: GBTBT::NT"][::std::mem::offset_of!(GBTBT, NT) - 8usize];
    ["Offset of field: GBTBT::NT2"][::std::mem::offset_of!(GBTBT, NT2) - 12usize];
    ["Offset of field: GBTBT::NDFT"][::std::mem::offset_of!(GBTBT, NDFT) - 16usize];
    ["Offset of field: GBTBT::HALF_NDFT"][::std::mem::offset_of!(GBTBT, HALF_NDFT) - 20usize];
    ["Offset of field: GBTBT::NU_TOTAL"][::std::mem::offset_of!(GBTBT, NU_TOTAL) - 24usize];
    ["Offset of field: GBTBT::NF"][::std::mem::offset_of!(GBTBT, NF) - 28usize];
    ["Offset of field: GBTBT::NF2"][::std::mem::offset_of!(GBTBT, NF2) - 32usize];
    ["Offset of field: GBTBT::ind_size"][::std::mem::offset_of!(GBTBT, ind_size) - 36usize];
    ["Offset of field: GBTBT::cov_size"][::std::mem::offset_of!(GBTBT, cov_size) - 40usize];
    ["Offset of field: GBTBT::MT2_TOTAL"][::std::mem::offset_of!(GBTBT, MT2_TOTAL) - 44usize];
    ["Offset of field: GBTBT::MT_size"][::std::mem::offset_of!(GBTBT, MT_size) - 48usize];
    ["Offset of field: GBTBT::MAX_MT"][::std::mem::offset_of!(GBTBT, MAX_MT) - 52usize];
    ["Offset of field: GBTBT::MT"][::std::mem::offset_of!(GBTBT, MT) - 56usize];
    ["Offset of field: GBTBT::MT2"][::std::mem::offset_of!(GBTBT, MT2) - 64usize];
    ["Offset of field: GBTBT::NU"][::std::mem::offset_of!(GBTBT, NU) - 72usize];
    ["Offset of field: GBTBT::NU2"][::std::mem::offset_of!(GBTBT, NU2) - 80usize];
    ["Offset of field: GBTBT::CS_MT2"][::std::mem::offset_of!(GBTBT, CS_MT2) - 88usize];
    ["Offset of field: GBTBT::d__MT"][::std::mem::offset_of!(GBTBT, d__MT) - 96usize];
    ["Offset of field: GBTBT::d__MT2"][::std::mem::offset_of!(GBTBT, d__MT2) - 104usize];
    ["Offset of field: GBTBT::d__NU"][::std::mem::offset_of!(GBTBT, d__NU) - 112usize];
    ["Offset of field: GBTBT::d__NU2"][::std::mem::offset_of!(GBTBT, d__NU2) - 120usize];
    ["Offset of field: GBTBT::d__CS_MT2"][::std::mem::offset_of!(GBTBT, d__CS_MT2) - 128usize];
    ["Offset of field: GBTBT::mask"][::std::mem::offset_of!(GBTBT, mask) - 136usize];
    ["Offset of field: GBTBT::d__cov"][::std::mem::offset_of!(GBTBT, d__cov) - 144usize];
    ["Offset of field: GBTBT::d__b"][::std::mem::offset_of!(GBTBT, d__b) - 152usize];
    ["Offset of field: GBTBT::d__c"][::std::mem::offset_of!(GBTBT, d__c) - 160usize];
    ["Offset of field: GBTBT::d__alpha"][::std::mem::offset_of!(GBTBT, d__alpha) - 168usize];
    ["Offset of field: GBTBT::d__beta"][::std::mem::offset_of!(GBTBT, d__beta) - 176usize];
    ["Offset of field: GBTBT::n_full"][::std::mem::offset_of!(GBTBT, n_full) - 184usize];
    ["Offset of field: GBTBT::n_comp"][::std::mem::offset_of!(GBTBT, n_comp) - 188usize];
    ["Offset of field: GBTBT::b_full"][::std::mem::offset_of!(GBTBT, b_full) - 192usize];
    ["Offset of field: GBTBT::b_comp"][::std::mem::offset_of!(GBTBT, b_comp) - 196usize];
    ["Offset of field: GBTBT::cov_eval_et"][::std::mem::offset_of!(GBTBT, cov_eval_et) - 200usize];
    ["Offset of field: GBTBT::d__mu"][::std::mem::offset_of!(GBTBT, d__mu) - 208usize];
    ["Offset of field: GBTBT::d__xi"][::std::mem::offset_of!(GBTBT, d__xi) - 216usize];
    ["Offset of field: GBTBT::raster_plan"][::std::mem::offset_of!(GBTBT, raster_plan) - 224usize];
    ["Offset of field: GBTBT::MVM_input_plan"]
        [::std::mem::offset_of!(GBTBT, MVM_input_plan) - 228usize];
    ["Offset of field: GBTBT::MVM_output_plan"]
        [::std::mem::offset_of!(GBTBT, MVM_output_plan) - 232usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN5GBTBT5setupEi"]
    pub fn GBTBT_setup(this: *mut GBTBT, n_x: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN5GBTBT5setupEiiiPKf"]
    pub fn GBTBT_setup1(
        this: *mut GBTBT,
        M_: ::std::os::raw::c_int,
        N_: ::std::os::raw::c_int,
        NT_: ::std::os::raw::c_int,
        d__cov_: *const f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5GBTBT5setupEiiiiPKf"]
    pub fn GBTBT_setup2(
        this: *mut GBTBT,
        M_: ::std::os::raw::c_int,
        N_: ::std::os::raw::c_int,
        MT_: ::std::os::raw::c_int,
        NT_: ::std::os::raw::c_int,
        d__cov_: *const f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5GBTBT5setupEiiPiiPKf"]
    pub fn GBTBT_setup3(
        this: *mut GBTBT,
        M_: ::std::os::raw::c_int,
        N_: ::std::os::raw::c_int,
        MT_: *mut ::std::os::raw::c_int,
        NT_: ::std::os::raw::c_int,
        d__cov_: *const f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5GBTBT7cleanupEv"]
    pub fn GBTBT_cleanup(this: *mut GBTBT);
}
extern "C" {
    #[link_name = "\u{1}_ZN5GBTBT4infoEv"]
    pub fn GBTBT_info(this: *mut GBTBT);
}
extern "C" {
    #[link_name = "\u{1}_ZN5GBTBT3MVMEPfS0_"]
    pub fn GBTBT_MVM(this: *mut GBTBT, y: *mut f32, x: *mut f32);
}
impl GBTBT {
    #[inline]
    pub unsafe fn setup(&mut self, n_x: ::std::os::raw::c_int) {
        GBTBT_setup(self, n_x)
    }
    #[inline]
    pub unsafe fn setup1(
        &mut self,
        M_: ::std::os::raw::c_int,
        N_: ::std::os::raw::c_int,
        NT_: ::std::os::raw::c_int,
        d__cov_: *const f32,
    ) {
        GBTBT_setup1(self, M_, N_, NT_, d__cov_)
    }
    #[inline]
    pub unsafe fn setup2(
        &mut self,
        M_: ::std::os::raw::c_int,
        N_: ::std::os::raw::c_int,
        MT_: ::std::os::raw::c_int,
        NT_: ::std::os::raw::c_int,
        d__cov_: *const f32,
    ) {
        GBTBT_setup2(self, M_, N_, MT_, NT_, d__cov_)
    }
    #[inline]
    pub unsafe fn setup3(
        &mut self,
        M_: ::std::os::raw::c_int,
        N_: ::std::os::raw::c_int,
        MT_: *mut ::std::os::raw::c_int,
        NT_: ::std::os::raw::c_int,
        d__cov_: *const f32,
    ) {
        GBTBT_setup3(self, M_, N_, MT_, NT_, d__cov_)
    }
    #[inline]
    pub unsafe fn cleanup(&mut self) {
        GBTBT_cleanup(self)
    }
    #[inline]
    pub unsafe fn info(&mut self) {
        GBTBT_info(self)
    }
    #[inline]
    pub unsafe fn MVM(&mut self, y: *mut f32, x: *mut f32) {
        GBTBT_MVM(self, y, x)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iterativeSolvers {
    pub d__vectors: *mut f32,
    pub q: *mut f32,
    pub x: *mut f32,
    pub r: *mut f32,
    pub p: *mut f32,
    pub z: *mut f32,
    pub nu_i: *mut f32,
    pub nu_im1: *mut f32,
    pub nu_ip1: *mut f32,
    pub w_i: *mut f32,
    pub w_im1: *mut f32,
    pub w_im2: *mut f32,
    pub rnorm: f32,
    pub rel_rnorm: f32,
    pub mean_time_per_iteration: f32,
    pub RTOL: f32,
    pub ATOL: f32,
    pub N: ::std::os::raw::c_int,
    pub N_ITERATION: ::std::os::raw::c_int,
    pub cvgce_iteration: ::std::os::raw::c_int,
    pub tid: stopwatch,
    pub handle: cublasHandle_t,
    pub status: cublasStatus_t,
    pub VERBOSE: ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of iterativeSolvers"][::std::mem::size_of::<iterativeSolvers>() - 168usize];
    ["Alignment of iterativeSolvers"][::std::mem::align_of::<iterativeSolvers>() - 8usize];
    ["Offset of field: iterativeSolvers::d__vectors"]
        [::std::mem::offset_of!(iterativeSolvers, d__vectors) - 0usize];
    ["Offset of field: iterativeSolvers::q"][::std::mem::offset_of!(iterativeSolvers, q) - 8usize];
    ["Offset of field: iterativeSolvers::x"][::std::mem::offset_of!(iterativeSolvers, x) - 16usize];
    ["Offset of field: iterativeSolvers::r"][::std::mem::offset_of!(iterativeSolvers, r) - 24usize];
    ["Offset of field: iterativeSolvers::p"][::std::mem::offset_of!(iterativeSolvers, p) - 32usize];
    ["Offset of field: iterativeSolvers::z"][::std::mem::offset_of!(iterativeSolvers, z) - 40usize];
    ["Offset of field: iterativeSolvers::nu_i"]
        [::std::mem::offset_of!(iterativeSolvers, nu_i) - 48usize];
    ["Offset of field: iterativeSolvers::nu_im1"]
        [::std::mem::offset_of!(iterativeSolvers, nu_im1) - 56usize];
    ["Offset of field: iterativeSolvers::nu_ip1"]
        [::std::mem::offset_of!(iterativeSolvers, nu_ip1) - 64usize];
    ["Offset of field: iterativeSolvers::w_i"]
        [::std::mem::offset_of!(iterativeSolvers, w_i) - 72usize];
    ["Offset of field: iterativeSolvers::w_im1"]
        [::std::mem::offset_of!(iterativeSolvers, w_im1) - 80usize];
    ["Offset of field: iterativeSolvers::w_im2"]
        [::std::mem::offset_of!(iterativeSolvers, w_im2) - 88usize];
    ["Offset of field: iterativeSolvers::rnorm"]
        [::std::mem::offset_of!(iterativeSolvers, rnorm) - 96usize];
    ["Offset of field: iterativeSolvers::rel_rnorm"]
        [::std::mem::offset_of!(iterativeSolvers, rel_rnorm) - 100usize];
    ["Offset of field: iterativeSolvers::mean_time_per_iteration"]
        [::std::mem::offset_of!(iterativeSolvers, mean_time_per_iteration) - 104usize];
    ["Offset of field: iterativeSolvers::RTOL"]
        [::std::mem::offset_of!(iterativeSolvers, RTOL) - 108usize];
    ["Offset of field: iterativeSolvers::ATOL"]
        [::std::mem::offset_of!(iterativeSolvers, ATOL) - 112usize];
    ["Offset of field: iterativeSolvers::N"]
        [::std::mem::offset_of!(iterativeSolvers, N) - 116usize];
    ["Offset of field: iterativeSolvers::N_ITERATION"]
        [::std::mem::offset_of!(iterativeSolvers, N_ITERATION) - 120usize];
    ["Offset of field: iterativeSolvers::cvgce_iteration"]
        [::std::mem::offset_of!(iterativeSolvers, cvgce_iteration) - 124usize];
    ["Offset of field: iterativeSolvers::tid"]
        [::std::mem::offset_of!(iterativeSolvers, tid) - 128usize];
    ["Offset of field: iterativeSolvers::handle"]
        [::std::mem::offset_of!(iterativeSolvers, handle) - 152usize];
    ["Offset of field: iterativeSolvers::status"]
        [::std::mem::offset_of!(iterativeSolvers, status) - 160usize];
    ["Offset of field: iterativeSolvers::VERBOSE"]
        [::std::mem::offset_of!(iterativeSolvers, VERBOSE) - 164usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN16iterativeSolvers8cg_setupEi"]
    pub fn iterativeSolvers_cg_setup(this: *mut iterativeSolvers, n_vector: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN16iterativeSolvers9pcg_setupEi"]
    pub fn iterativeSolvers_pcg_setup(this: *mut iterativeSolvers, n_vector: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN16iterativeSolvers12minres_setupEi"]
    pub fn iterativeSolvers_minres_setup(
        this: *mut iterativeSolvers,
        n_vector: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16iterativeSolvers7cleanupEv"]
    pub fn iterativeSolvers_cleanup(this: *mut iterativeSolvers);
}
extern "C" {
    #[link_name = "\u{1}_ZN16iterativeSolvers2cgEPfP4BTBTS0_iS0_"]
    pub fn iterativeSolvers_cg(
        this: *mut iterativeSolvers,
        x: *mut f32,
        A: *mut BTBT,
        b: *mut f32,
        max_it: ::std::os::raw::c_int,
        x0: *mut f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16iterativeSolvers3pcgEPfP4BTBTS0_iS0_f"]
    pub fn iterativeSolvers_pcg(
        this: *mut iterativeSolvers,
        x: *mut f32,
        A: *mut BTBT,
        b: *mut f32,
        max_it: ::std::os::raw::c_int,
        x0: *mut f32,
        ip: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16iterativeSolvers9sym_orthoEPfS0_S0_S0_S0_"]
    pub fn iterativeSolvers_sym_ortho(
        this: *mut iterativeSolvers,
        c: *mut f32,
        s: *mut f32,
        r: *mut f32,
        a: *mut f32,
        b: *mut f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16iterativeSolvers12lanczos_stepEPfS0_S0_P4BTBTS0_S0_f"]
    pub fn iterativeSolvers_lanczos_step(
        this: *mut iterativeSolvers,
        alpha: *mut f32,
        beta: *mut f32,
        nu_kp1: *mut f32,
        A: *mut BTBT,
        nu_k: *mut f32,
        nu_km1: *mut f32,
        sigma: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16iterativeSolvers12minres_vorstEPfP4BTBTS0_S0_"]
    pub fn iterativeSolvers_minres_vorst(
        this: *mut iterativeSolvers,
        x: *mut f32,
        A: *mut BTBT,
        b: *mut f32,
        x0: *mut f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16iterativeSolvers12minres_vorstEPfP4BTBTS0_iS0_"]
    pub fn iterativeSolvers_minres_vorst1(
        this: *mut iterativeSolvers,
        x: *mut f32,
        A: *mut BTBT,
        b: *mut f32,
        max_it: ::std::os::raw::c_int,
        x0: *mut f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16iterativeSolvers12minres_vorstEPfP4BTBTS0_fS0_"]
    pub fn iterativeSolvers_minres_vorst2(
        this: *mut iterativeSolvers,
        x: *mut f32,
        A: *mut BTBT,
        b: *mut f32,
        rtol: f32,
        x0: *mut f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16iterativeSolvers13pminres_vorstEPfP4BTBTS0_iS0_f"]
    pub fn iterativeSolvers_pminres_vorst(
        this: *mut iterativeSolvers,
        x: *mut f32,
        A: *mut BTBT,
        b: *mut f32,
        max_it: ::std::os::raw::c_int,
        x0: *mut f32,
        ip: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16iterativeSolvers12minres_vorstEPfS0_P4BTBTS0_iS0_"]
    pub fn iterativeSolvers_minres_vorst3(
        this: *mut iterativeSolvers,
        x: *mut f32,
        res: *mut f32,
        A: *mut BTBT,
        b: *mut f32,
        max_it: ::std::os::raw::c_int,
        x0: *mut f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN16iterativeSolvers11minres_choiEPfP4BTBTS0_iS0_"]
    pub fn iterativeSolvers_minres_choi(
        this: *mut iterativeSolvers,
        x: *mut f32,
        A: *mut BTBT,
        b: *mut f32,
        max_it: ::std::os::raw::c_int,
        x0: *mut f32,
    );
}
impl iterativeSolvers {
    #[inline]
    pub unsafe fn cg_setup(&mut self, n_vector: ::std::os::raw::c_int) {
        iterativeSolvers_cg_setup(self, n_vector)
    }
    #[inline]
    pub unsafe fn pcg_setup(&mut self, n_vector: ::std::os::raw::c_int) {
        iterativeSolvers_pcg_setup(self, n_vector)
    }
    #[inline]
    pub unsafe fn minres_setup(&mut self, n_vector: ::std::os::raw::c_int) {
        iterativeSolvers_minres_setup(self, n_vector)
    }
    #[inline]
    pub unsafe fn cleanup(&mut self) {
        iterativeSolvers_cleanup(self)
    }
    #[inline]
    pub unsafe fn cg(
        &mut self,
        x: *mut f32,
        A: *mut BTBT,
        b: *mut f32,
        max_it: ::std::os::raw::c_int,
        x0: *mut f32,
    ) {
        iterativeSolvers_cg(self, x, A, b, max_it, x0)
    }
    #[inline]
    pub unsafe fn pcg(
        &mut self,
        x: *mut f32,
        A: *mut BTBT,
        b: *mut f32,
        max_it: ::std::os::raw::c_int,
        x0: *mut f32,
        ip: f32,
    ) {
        iterativeSolvers_pcg(self, x, A, b, max_it, x0, ip)
    }
    #[inline]
    pub unsafe fn sym_ortho(
        &mut self,
        c: *mut f32,
        s: *mut f32,
        r: *mut f32,
        a: *mut f32,
        b: *mut f32,
    ) {
        iterativeSolvers_sym_ortho(self, c, s, r, a, b)
    }
    #[inline]
    pub unsafe fn lanczos_step(
        &mut self,
        alpha: *mut f32,
        beta: *mut f32,
        nu_kp1: *mut f32,
        A: *mut BTBT,
        nu_k: *mut f32,
        nu_km1: *mut f32,
        sigma: f32,
    ) {
        iterativeSolvers_lanczos_step(self, alpha, beta, nu_kp1, A, nu_k, nu_km1, sigma)
    }
    #[inline]
    pub unsafe fn minres_vorst(&mut self, x: *mut f32, A: *mut BTBT, b: *mut f32, x0: *mut f32) {
        iterativeSolvers_minres_vorst(self, x, A, b, x0)
    }
    #[inline]
    pub unsafe fn minres_vorst1(
        &mut self,
        x: *mut f32,
        A: *mut BTBT,
        b: *mut f32,
        max_it: ::std::os::raw::c_int,
        x0: *mut f32,
    ) {
        iterativeSolvers_minres_vorst1(self, x, A, b, max_it, x0)
    }
    #[inline]
    pub unsafe fn minres_vorst2(
        &mut self,
        x: *mut f32,
        A: *mut BTBT,
        b: *mut f32,
        rtol: f32,
        x0: *mut f32,
    ) {
        iterativeSolvers_minres_vorst2(self, x, A, b, rtol, x0)
    }
    #[inline]
    pub unsafe fn pminres_vorst(
        &mut self,
        x: *mut f32,
        A: *mut BTBT,
        b: *mut f32,
        max_it: ::std::os::raw::c_int,
        x0: *mut f32,
        ip: f32,
    ) {
        iterativeSolvers_pminres_vorst(self, x, A, b, max_it, x0, ip)
    }
    #[inline]
    pub unsafe fn minres_vorst3(
        &mut self,
        x: *mut f32,
        res: *mut f32,
        A: *mut BTBT,
        b: *mut f32,
        max_it: ::std::os::raw::c_int,
        x0: *mut f32,
    ) {
        iterativeSolvers_minres_vorst3(self, x, res, A, b, max_it, x0)
    }
    #[inline]
    pub unsafe fn minres_choi(
        &mut self,
        x: *mut f32,
        A: *mut BTBT,
        b: *mut f32,
        max_it: ::std::os::raw::c_int,
        x0: *mut f32,
    ) {
        iterativeSolvers_minres_choi(self, x, A, b, max_it, x0)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LMMSE {
    pub d__idx: *mut ::std::os::raw::c_int,
    pub PS_E_N_PX: ::std::os::raw::c_int,
    pub N_guide_star: ::std::os::raw::c_int,
    pub N_mmse_star: ::std::os::raw::c_int,
    pub offset: ::std::os::raw::c_int,
    pub N_SIDE_LENSLET_: ::std::os::raw::c_int,
    pub NP: ::std::os::raw::c_int,
    pub NS: ::std::os::raw::c_int,
    pub osf: ::std::os::raw::c_int,
    pub d__ce: *mut f32,
    pub d__phase_est: *mut f32,
    pub d__phase_est_c: *mut f32,
    pub d__phase_est_i: *mut f32,
    pub d__x: *mut f32,
    pub d__zp_x: *mut f32,
    pub aa: aaStats,
    pub aaCov: BTBT,
    pub pa: paStats,
    pub paCov: GBTBT,
    pub iSolve: iterativeSolvers,
    pub tid: stopwatch,
    pub nnz: ::std::os::raw::c_int,
    pub NI: ::std::os::raw::c_int,
    pub csrValH: *mut f32,
    pub csrColIndH: *mut ::std::os::raw::c_int,
    pub csrRowPtrH: *mut ::std::os::raw::c_int,
    pub alpha: f32,
    pub beta: f32,
    pub elapsed_time: f32,
    pub cudaStat: cudaError_t,
    pub status: cusparseStatus_t,
    pub handle: cusparseHandle_t,
    pub descr: cusparseMatDescr_t,
    pub start: cudaEvent_t,
    pub stop: cudaEvent_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of LMMSE"][::std::mem::size_of::<LMMSE>() - 1008usize];
    ["Alignment of LMMSE"][::std::mem::align_of::<LMMSE>() - 8usize];
    ["Offset of field: LMMSE::d__idx"][::std::mem::offset_of!(LMMSE, d__idx) - 0usize];
    ["Offset of field: LMMSE::PS_E_N_PX"][::std::mem::offset_of!(LMMSE, PS_E_N_PX) - 8usize];
    ["Offset of field: LMMSE::N_guide_star"][::std::mem::offset_of!(LMMSE, N_guide_star) - 12usize];
    ["Offset of field: LMMSE::N_mmse_star"][::std::mem::offset_of!(LMMSE, N_mmse_star) - 16usize];
    ["Offset of field: LMMSE::offset"][::std::mem::offset_of!(LMMSE, offset) - 20usize];
    ["Offset of field: LMMSE::N_SIDE_LENSLET_"]
        [::std::mem::offset_of!(LMMSE, N_SIDE_LENSLET_) - 24usize];
    ["Offset of field: LMMSE::NP"][::std::mem::offset_of!(LMMSE, NP) - 28usize];
    ["Offset of field: LMMSE::NS"][::std::mem::offset_of!(LMMSE, NS) - 32usize];
    ["Offset of field: LMMSE::osf"][::std::mem::offset_of!(LMMSE, osf) - 36usize];
    ["Offset of field: LMMSE::d__ce"][::std::mem::offset_of!(LMMSE, d__ce) - 40usize];
    ["Offset of field: LMMSE::d__phase_est"][::std::mem::offset_of!(LMMSE, d__phase_est) - 48usize];
    ["Offset of field: LMMSE::d__phase_est_c"]
        [::std::mem::offset_of!(LMMSE, d__phase_est_c) - 56usize];
    ["Offset of field: LMMSE::d__phase_est_i"]
        [::std::mem::offset_of!(LMMSE, d__phase_est_i) - 64usize];
    ["Offset of field: LMMSE::d__x"][::std::mem::offset_of!(LMMSE, d__x) - 72usize];
    ["Offset of field: LMMSE::d__zp_x"][::std::mem::offset_of!(LMMSE, d__zp_x) - 80usize];
    ["Offset of field: LMMSE::aa"][::std::mem::offset_of!(LMMSE, aa) - 88usize];
    ["Offset of field: LMMSE::aaCov"][::std::mem::offset_of!(LMMSE, aaCov) - 192usize];
    ["Offset of field: LMMSE::pa"][::std::mem::offset_of!(LMMSE, pa) - 360usize];
    ["Offset of field: LMMSE::paCov"][::std::mem::offset_of!(LMMSE, paCov) - 488usize];
    ["Offset of field: LMMSE::iSolve"][::std::mem::offset_of!(LMMSE, iSolve) - 728usize];
    ["Offset of field: LMMSE::tid"][::std::mem::offset_of!(LMMSE, tid) - 896usize];
    ["Offset of field: LMMSE::nnz"][::std::mem::offset_of!(LMMSE, nnz) - 920usize];
    ["Offset of field: LMMSE::NI"][::std::mem::offset_of!(LMMSE, NI) - 924usize];
    ["Offset of field: LMMSE::csrValH"][::std::mem::offset_of!(LMMSE, csrValH) - 928usize];
    ["Offset of field: LMMSE::csrColIndH"][::std::mem::offset_of!(LMMSE, csrColIndH) - 936usize];
    ["Offset of field: LMMSE::csrRowPtrH"][::std::mem::offset_of!(LMMSE, csrRowPtrH) - 944usize];
    ["Offset of field: LMMSE::alpha"][::std::mem::offset_of!(LMMSE, alpha) - 952usize];
    ["Offset of field: LMMSE::beta"][::std::mem::offset_of!(LMMSE, beta) - 956usize];
    ["Offset of field: LMMSE::elapsed_time"]
        [::std::mem::offset_of!(LMMSE, elapsed_time) - 960usize];
    ["Offset of field: LMMSE::cudaStat"][::std::mem::offset_of!(LMMSE, cudaStat) - 964usize];
    ["Offset of field: LMMSE::status"][::std::mem::offset_of!(LMMSE, status) - 968usize];
    ["Offset of field: LMMSE::handle"][::std::mem::offset_of!(LMMSE, handle) - 976usize];
    ["Offset of field: LMMSE::descr"][::std::mem::offset_of!(LMMSE, descr) - 984usize];
    ["Offset of field: LMMSE::start"][::std::mem::offset_of!(LMMSE, start) - 992usize];
    ["Offset of field: LMMSE::stop"][::std::mem::offset_of!(LMMSE, stop) - 1000usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN5LMMSE5setupEP10atmosphereP6sourceS3_fiPc"]
    pub fn LMMSE_setup(
        this: *mut LMMSE,
        atm: *mut atmosphere,
        guide_star: *mut source,
        mmse_star: *mut source,
        sampling: f32,
        N: ::std::os::raw::c_int,
        solver_id: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5LMMSE5setupEP10atmosphereP6sourceS3_fiP4maskPc"]
    pub fn LMMSE_setup1(
        this: *mut LMMSE,
        atm: *mut atmosphere,
        guide_star: *mut source,
        mmse_star: *mut source,
        sampling: f32,
        N: ::std::os::raw::c_int,
        pupil: *mut mask,
        solver_id: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5LMMSE5setupEP10atmosphereP6sourceS3_fiP4maskPci"]
    pub fn LMMSE_setup2(
        this: *mut LMMSE,
        atm: *mut atmosphere,
        guide_star: *mut source,
        mmse_star: *mut source,
        sampling: f32,
        N: ::std::os::raw::c_int,
        pupil: *mut mask,
        solver_id: *mut ::std::os::raw::c_char,
        wavefront_osf: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5LMMSE5setupEP10atmosphereP6sourcefiP4maskPcif"]
    pub fn LMMSE_setup3(
        this: *mut LMMSE,
        atm: *mut atmosphere,
        guide_star: *mut source,
        sampling: f32,
        _N_SIDE_LENSLET_: ::std::os::raw::c_int,
        pupil: *mut mask,
        solver_id: *mut ::std::os::raw::c_char,
        wavefront_osf: ::std::os::raw::c_int,
        z_radius: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5LMMSE5setupEP10atmosphereP6sourceS3_P13shackHartmannPc"]
    pub fn LMMSE_setup4(
        this: *mut LMMSE,
        atm: *mut atmosphere,
        guide_star: *mut source,
        mmse_star: *mut source,
        wfs: *mut shackHartmann,
        solver_id: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5LMMSE5setupEP10atmosphereP6sourceS3_P13shackHartmannPciP4mask"]
    pub fn LMMSE_setup5(
        this: *mut LMMSE,
        atm: *mut atmosphere,
        guide_star: *mut source,
        mmse_star: *mut source,
        wfs: *mut shackHartmann,
        solver_id: *mut ::std::os::raw::c_char,
        osf_: ::std::os::raw::c_int,
        pupil_: *mut mask,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5LMMSE7cleanupEv"]
    pub fn LMMSE_cleanup(this: *mut LMMSE);
}
extern "C" {
    #[link_name = "\u{1}_ZN5LMMSE14estimation_oldEPfiS0_"]
    pub fn LMMSE_estimation_old(
        this: *mut LMMSE,
        d__c: *mut f32,
        nMaxIteration: ::std::os::raw::c_int,
        d__x0: *mut f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5LMMSE14estimation_oldEPfi"]
    pub fn LMMSE_estimation_old1(
        this: *mut LMMSE,
        d__c: *mut f32,
        nMaxIteration: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5LMMSE10estimationEPK11centroiding"]
    pub fn LMMSE_estimation(this: *mut LMMSE, cog: *const centroiding);
}
extern "C" {
    #[link_name = "\u{1}_ZN5LMMSE10estimationEP13shackHartmann"]
    pub fn LMMSE_estimation1(this: *mut LMMSE, wfs: *mut shackHartmann);
}
extern "C" {
    #[link_name = "\u{1}_ZN5LMMSE5resetEv"]
    pub fn LMMSE_reset(this: *mut LMMSE);
}
extern "C" {
    #[link_name = "\u{1}_ZN5LMMSE17set_phase_est_ptrEPf"]
    pub fn LMMSE_set_phase_est_ptr(this: *mut LMMSE, data_ptr: *mut f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN5LMMSE6toFileEPKc"]
    pub fn LMMSE_toFile(this: *mut LMMSE, filename: *const ::std::os::raw::c_char);
}
impl LMMSE {
    #[inline]
    pub unsafe fn setup(
        &mut self,
        atm: *mut atmosphere,
        guide_star: *mut source,
        mmse_star: *mut source,
        sampling: f32,
        N: ::std::os::raw::c_int,
        solver_id: *mut ::std::os::raw::c_char,
    ) {
        LMMSE_setup(self, atm, guide_star, mmse_star, sampling, N, solver_id)
    }
    #[inline]
    pub unsafe fn setup1(
        &mut self,
        atm: *mut atmosphere,
        guide_star: *mut source,
        mmse_star: *mut source,
        sampling: f32,
        N: ::std::os::raw::c_int,
        pupil: *mut mask,
        solver_id: *mut ::std::os::raw::c_char,
    ) {
        LMMSE_setup1(
            self, atm, guide_star, mmse_star, sampling, N, pupil, solver_id,
        )
    }
    #[inline]
    pub unsafe fn setup2(
        &mut self,
        atm: *mut atmosphere,
        guide_star: *mut source,
        mmse_star: *mut source,
        sampling: f32,
        N: ::std::os::raw::c_int,
        pupil: *mut mask,
        solver_id: *mut ::std::os::raw::c_char,
        wavefront_osf: ::std::os::raw::c_int,
    ) {
        LMMSE_setup2(
            self,
            atm,
            guide_star,
            mmse_star,
            sampling,
            N,
            pupil,
            solver_id,
            wavefront_osf,
        )
    }
    #[inline]
    pub unsafe fn setup3(
        &mut self,
        atm: *mut atmosphere,
        guide_star: *mut source,
        sampling: f32,
        _N_SIDE_LENSLET_: ::std::os::raw::c_int,
        pupil: *mut mask,
        solver_id: *mut ::std::os::raw::c_char,
        wavefront_osf: ::std::os::raw::c_int,
        z_radius: f32,
    ) {
        LMMSE_setup3(
            self,
            atm,
            guide_star,
            sampling,
            _N_SIDE_LENSLET_,
            pupil,
            solver_id,
            wavefront_osf,
            z_radius,
        )
    }
    #[inline]
    pub unsafe fn setup4(
        &mut self,
        atm: *mut atmosphere,
        guide_star: *mut source,
        mmse_star: *mut source,
        wfs: *mut shackHartmann,
        solver_id: *mut ::std::os::raw::c_char,
    ) {
        LMMSE_setup4(self, atm, guide_star, mmse_star, wfs, solver_id)
    }
    #[inline]
    pub unsafe fn setup5(
        &mut self,
        atm: *mut atmosphere,
        guide_star: *mut source,
        mmse_star: *mut source,
        wfs: *mut shackHartmann,
        solver_id: *mut ::std::os::raw::c_char,
        osf_: ::std::os::raw::c_int,
        pupil_: *mut mask,
    ) {
        LMMSE_setup5(
            self, atm, guide_star, mmse_star, wfs, solver_id, osf_, pupil_,
        )
    }
    #[inline]
    pub unsafe fn cleanup(&mut self) {
        LMMSE_cleanup(self)
    }
    #[inline]
    pub unsafe fn estimation_old(
        &mut self,
        d__c: *mut f32,
        nMaxIteration: ::std::os::raw::c_int,
        d__x0: *mut f32,
    ) {
        LMMSE_estimation_old(self, d__c, nMaxIteration, d__x0)
    }
    #[inline]
    pub unsafe fn estimation_old1(&mut self, d__c: *mut f32, nMaxIteration: ::std::os::raw::c_int) {
        LMMSE_estimation_old1(self, d__c, nMaxIteration)
    }
    #[inline]
    pub unsafe fn estimation(&mut self, cog: *const centroiding) {
        LMMSE_estimation(self, cog)
    }
    #[inline]
    pub unsafe fn estimation1(&mut self, wfs: *mut shackHartmann) {
        LMMSE_estimation1(self, wfs)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        LMMSE_reset(self)
    }
    #[inline]
    pub unsafe fn set_phase_est_ptr(&mut self, data_ptr: *mut f32) {
        LMMSE_set_phase_est_ptr(self, data_ptr)
    }
    #[inline]
    pub unsafe fn toFile(&mut self, filename: *const ::std::os::raw::c_char) {
        LMMSE_toFile(self, filename)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pyramid {
    pub N_PX_LENSLET: ::std::os::raw::c_int,
    pub N_SIDE_LENSLET: ::std::os::raw::c_int,
    pub modulation: f32,
    pub modulation_sampling: ::std::os::raw::c_int,
    pub camera: imaging,
    pub alpha: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pyramid"][::std::mem::size_of::<pyramid>() - 168usize];
    ["Alignment of pyramid"][::std::mem::align_of::<pyramid>() - 8usize];
    ["Offset of field: pyramid::N_PX_LENSLET"]
        [::std::mem::offset_of!(pyramid, N_PX_LENSLET) - 0usize];
    ["Offset of field: pyramid::N_SIDE_LENSLET"]
        [::std::mem::offset_of!(pyramid, N_SIDE_LENSLET) - 4usize];
    ["Offset of field: pyramid::modulation"][::std::mem::offset_of!(pyramid, modulation) - 8usize];
    ["Offset of field: pyramid::modulation_sampling"]
        [::std::mem::offset_of!(pyramid, modulation_sampling) - 12usize];
    ["Offset of field: pyramid::camera"][::std::mem::offset_of!(pyramid, camera) - 16usize];
    ["Offset of field: pyramid::alpha"][::std::mem::offset_of!(pyramid, alpha) - 160usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN7pyramid5setupEiififi"]
    pub fn pyramid_setup(
        this: *mut pyramid,
        N_PX_PUPIL: ::std::os::raw::c_int,
        _N_PUPIL_SAMPLING_: ::std::os::raw::c_int,
        _modulation_: f32,
        _modulation_sampling_: ::std::os::raw::c_int,
        _alpha_: f32,
        N_GS: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7pyramid7cleanupEv"]
    pub fn pyramid_cleanup(this: *mut pyramid);
}
impl pyramid {
    #[inline]
    pub unsafe fn setup(
        &mut self,
        N_PX_PUPIL: ::std::os::raw::c_int,
        _N_PUPIL_SAMPLING_: ::std::os::raw::c_int,
        _modulation_: f32,
        _modulation_sampling_: ::std::os::raw::c_int,
        _alpha_: f32,
        N_GS: ::std::os::raw::c_int,
    ) {
        pyramid_setup(
            self,
            N_PX_PUPIL,
            _N_PUPIL_SAMPLING_,
            _modulation_,
            _modulation_sampling_,
            _alpha_,
            N_GS,
        )
    }
    #[inline]
    pub unsafe fn cleanup(&mut self) {
        pyramid_cleanup(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct segmentPistonSensor {
    pub ri: f32,
    pub ro: f32,
    pub lenslet_height: f32,
    pub lenslet_size: f32,
    pub lenslet: complex_amplitude,
    pub lenslet_mask: mask,
    pub lenslet_src: source,
    pub dispersion: f32,
    pub N_LAMBDA: ::std::os::raw::c_int,
    pub N_GS: ::std::os::raw::c_int,
    pub pixel_scale: f32,
    pub field_of_view: f32,
    pub camera: imaging,
    pub camera_array: *mut imaging,
    pub nyquist_factor: f32,
    pub BIN_IMAGE: ::std::os::raw::c_int,
    pub N_PX_LENSLET: ::std::os::raw::c_int,
    pub N_PX_LENSLET2: ::std::os::raw::c_int,
    pub N_PX: ::std::os::raw::c_int,
    pub N_PX2: ::std::os::raw::c_int,
    pub N_PX_IMAGE: ::std::os::raw::c_int,
    pub N_LENSLET: ::std::os::raw::c_int,
    pub N_LENSLET2: ::std::os::raw::c_int,
    pub FFT: imaging,
    pub fft_src: source,
    pub fft_phase: *mut f32,
    pub fft_mask: mask,
    pub D_px: ::std::os::raw::c_int,
    pub D_px2: ::std::os::raw::c_int,
    pub m2px: f32,
    pub R: f32,
    pub lambda0: f32,
    pub spectral_bandwidth: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of segmentPistonSensor"][::std::mem::size_of::<segmentPistonSensor>() - 1384usize];
    ["Alignment of segmentPistonSensor"][::std::mem::align_of::<segmentPistonSensor>() - 8usize];
    ["Offset of field: segmentPistonSensor::ri"]
        [::std::mem::offset_of!(segmentPistonSensor, ri) - 0usize];
    ["Offset of field: segmentPistonSensor::ro"]
        [::std::mem::offset_of!(segmentPistonSensor, ro) - 4usize];
    ["Offset of field: segmentPistonSensor::lenslet_height"]
        [::std::mem::offset_of!(segmentPistonSensor, lenslet_height) - 8usize];
    ["Offset of field: segmentPistonSensor::lenslet_size"]
        [::std::mem::offset_of!(segmentPistonSensor, lenslet_size) - 12usize];
    ["Offset of field: segmentPistonSensor::lenslet"]
        [::std::mem::offset_of!(segmentPistonSensor, lenslet) - 16usize];
    ["Offset of field: segmentPistonSensor::lenslet_mask"]
        [::std::mem::offset_of!(segmentPistonSensor, lenslet_mask) - 64usize];
    ["Offset of field: segmentPistonSensor::lenslet_src"]
        [::std::mem::offset_of!(segmentPistonSensor, lenslet_src) - 144usize];
    ["Offset of field: segmentPistonSensor::dispersion"]
        [::std::mem::offset_of!(segmentPistonSensor, dispersion) - 528usize];
    ["Offset of field: segmentPistonSensor::N_LAMBDA"]
        [::std::mem::offset_of!(segmentPistonSensor, N_LAMBDA) - 532usize];
    ["Offset of field: segmentPistonSensor::N_GS"]
        [::std::mem::offset_of!(segmentPistonSensor, N_GS) - 536usize];
    ["Offset of field: segmentPistonSensor::pixel_scale"]
        [::std::mem::offset_of!(segmentPistonSensor, pixel_scale) - 540usize];
    ["Offset of field: segmentPistonSensor::field_of_view"]
        [::std::mem::offset_of!(segmentPistonSensor, field_of_view) - 544usize];
    ["Offset of field: segmentPistonSensor::camera"]
        [::std::mem::offset_of!(segmentPistonSensor, camera) - 552usize];
    ["Offset of field: segmentPistonSensor::camera_array"]
        [::std::mem::offset_of!(segmentPistonSensor, camera_array) - 696usize];
    ["Offset of field: segmentPistonSensor::nyquist_factor"]
        [::std::mem::offset_of!(segmentPistonSensor, nyquist_factor) - 704usize];
    ["Offset of field: segmentPistonSensor::BIN_IMAGE"]
        [::std::mem::offset_of!(segmentPistonSensor, BIN_IMAGE) - 708usize];
    ["Offset of field: segmentPistonSensor::N_PX_LENSLET"]
        [::std::mem::offset_of!(segmentPistonSensor, N_PX_LENSLET) - 712usize];
    ["Offset of field: segmentPistonSensor::N_PX_LENSLET2"]
        [::std::mem::offset_of!(segmentPistonSensor, N_PX_LENSLET2) - 716usize];
    ["Offset of field: segmentPistonSensor::N_PX"]
        [::std::mem::offset_of!(segmentPistonSensor, N_PX) - 720usize];
    ["Offset of field: segmentPistonSensor::N_PX2"]
        [::std::mem::offset_of!(segmentPistonSensor, N_PX2) - 724usize];
    ["Offset of field: segmentPistonSensor::N_PX_IMAGE"]
        [::std::mem::offset_of!(segmentPistonSensor, N_PX_IMAGE) - 728usize];
    ["Offset of field: segmentPistonSensor::N_LENSLET"]
        [::std::mem::offset_of!(segmentPistonSensor, N_LENSLET) - 732usize];
    ["Offset of field: segmentPistonSensor::N_LENSLET2"]
        [::std::mem::offset_of!(segmentPistonSensor, N_LENSLET2) - 736usize];
    ["Offset of field: segmentPistonSensor::FFT"]
        [::std::mem::offset_of!(segmentPistonSensor, FFT) - 744usize];
    ["Offset of field: segmentPistonSensor::fft_src"]
        [::std::mem::offset_of!(segmentPistonSensor, fft_src) - 888usize];
    ["Offset of field: segmentPistonSensor::fft_phase"]
        [::std::mem::offset_of!(segmentPistonSensor, fft_phase) - 1272usize];
    ["Offset of field: segmentPistonSensor::fft_mask"]
        [::std::mem::offset_of!(segmentPistonSensor, fft_mask) - 1280usize];
    ["Offset of field: segmentPistonSensor::D_px"]
        [::std::mem::offset_of!(segmentPistonSensor, D_px) - 1360usize];
    ["Offset of field: segmentPistonSensor::D_px2"]
        [::std::mem::offset_of!(segmentPistonSensor, D_px2) - 1364usize];
    ["Offset of field: segmentPistonSensor::m2px"]
        [::std::mem::offset_of!(segmentPistonSensor, m2px) - 1368usize];
    ["Offset of field: segmentPistonSensor::R"]
        [::std::mem::offset_of!(segmentPistonSensor, R) - 1372usize];
    ["Offset of field: segmentPistonSensor::lambda0"]
        [::std::mem::offset_of!(segmentPistonSensor, lambda0) - 1376usize];
    ["Offset of field: segmentPistonSensor::spectral_bandwidth"]
        [::std::mem::offset_of!(segmentPistonSensor, spectral_bandwidth) - 1380usize];
};
extern "C" {
    #[link_name = "\u{1}_ZN19segmentPistonSensor5setupEP6gmt_m1P6sourcefff"]
    pub fn segmentPistonSensor_setup(
        this: *mut segmentPistonSensor,
        M1: *mut gmt_m1,
        src: *mut source,
        dispersion: f32,
        field_of_view: f32,
        _nyquist_factor_: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN19segmentPistonSensor5setupEP6gmt_m1P6sourcefffi"]
    pub fn segmentPistonSensor_setup1(
        this: *mut segmentPistonSensor,
        M1: *mut gmt_m1,
        src: *mut source,
        dispersion: f32,
        field_of_view: f32,
        _nyquist_factor_: f32,
        _BIN_IMAGE_: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN19segmentPistonSensor5setupEP6gmt_m1P6sourceffff"]
    pub fn segmentPistonSensor_setup2(
        this: *mut segmentPistonSensor,
        M1: *mut gmt_m1,
        src: *mut source,
        _lenslet_size_: f32,
        dispersion: f32,
        field_of_view: f32,
        _nyquist_factor_: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN19segmentPistonSensor5setupEP6gmt_m1P6sourceffffi"]
    pub fn segmentPistonSensor_setup3(
        this: *mut segmentPistonSensor,
        M1: *mut gmt_m1,
        src: *mut source,
        _lenslet_size_: f32,
        dispersion: f32,
        field_of_view: f32,
        _nyquist_factor_: f32,
        _BIN_IMAGE_: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN19segmentPistonSensor9setup_altEP6gmt_m1P6sourcefffi"]
    pub fn segmentPistonSensor_setup_alt(
        this: *mut segmentPistonSensor,
        M1: *mut gmt_m1,
        src: *mut source,
        dispersion: f32,
        field_of_view: f32,
        _nyquist_factor_: f32,
        _BIN_IMAGE_: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN19segmentPistonSensor7cleanupEv"]
    pub fn segmentPistonSensor_cleanup(this: *mut segmentPistonSensor);
}
extern "C" {
    #[link_name = "\u{1}_ZN19segmentPistonSensor11cleanup_altEv"]
    pub fn segmentPistonSensor_cleanup_alt(this: *mut segmentPistonSensor);
}
extern "C" {
    #[link_name = "\u{1}_ZN19segmentPistonSensor9propagateEP6source"]
    pub fn segmentPistonSensor_propagate(this: *mut segmentPistonSensor, src: *mut source);
}
extern "C" {
    #[link_name = "\u{1}_ZN19segmentPistonSensor9propagateEP6sourcef"]
    pub fn segmentPistonSensor_propagate1(
        this: *mut segmentPistonSensor,
        src: *mut source,
        middle_mask_width: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN19segmentPistonSensor13propagate_altEP6source"]
    pub fn segmentPistonSensor_propagate_alt(this: *mut segmentPistonSensor, src: *mut source);
}
extern "C" {
    #[link_name = "\u{1}_ZN19segmentPistonSensor7readoutEfff"]
    pub fn segmentPistonSensor_readout(
        this: *mut segmentPistonSensor,
        exposureTime: f32,
        readoutNoiseRms: f32,
        nBackgroundPhoton: f32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN19segmentPistonSensor3fftEv"]
    pub fn segmentPistonSensor_fft(this: *mut segmentPistonSensor);
}
extern "C" {
    #[link_name = "\u{1}_ZN19segmentPistonSensor4infoEv"]
    pub fn segmentPistonSensor_info(this: *mut segmentPistonSensor);
}
impl segmentPistonSensor {
    #[inline]
    pub unsafe fn setup(
        &mut self,
        M1: *mut gmt_m1,
        src: *mut source,
        dispersion: f32,
        field_of_view: f32,
        _nyquist_factor_: f32,
    ) {
        segmentPistonSensor_setup(self, M1, src, dispersion, field_of_view, _nyquist_factor_)
    }
    #[inline]
    pub unsafe fn setup1(
        &mut self,
        M1: *mut gmt_m1,
        src: *mut source,
        dispersion: f32,
        field_of_view: f32,
        _nyquist_factor_: f32,
        _BIN_IMAGE_: ::std::os::raw::c_int,
    ) {
        segmentPistonSensor_setup1(
            self,
            M1,
            src,
            dispersion,
            field_of_view,
            _nyquist_factor_,
            _BIN_IMAGE_,
        )
    }
    #[inline]
    pub unsafe fn setup2(
        &mut self,
        M1: *mut gmt_m1,
        src: *mut source,
        _lenslet_size_: f32,
        dispersion: f32,
        field_of_view: f32,
        _nyquist_factor_: f32,
    ) {
        segmentPistonSensor_setup2(
            self,
            M1,
            src,
            _lenslet_size_,
            dispersion,
            field_of_view,
            _nyquist_factor_,
        )
    }
    #[inline]
    pub unsafe fn setup3(
        &mut self,
        M1: *mut gmt_m1,
        src: *mut source,
        _lenslet_size_: f32,
        dispersion: f32,
        field_of_view: f32,
        _nyquist_factor_: f32,
        _BIN_IMAGE_: ::std::os::raw::c_int,
    ) {
        segmentPistonSensor_setup3(
            self,
            M1,
            src,
            _lenslet_size_,
            dispersion,
            field_of_view,
            _nyquist_factor_,
            _BIN_IMAGE_,
        )
    }
    #[inline]
    pub unsafe fn setup_alt(
        &mut self,
        M1: *mut gmt_m1,
        src: *mut source,
        dispersion: f32,
        field_of_view: f32,
        _nyquist_factor_: f32,
        _BIN_IMAGE_: ::std::os::raw::c_int,
    ) {
        segmentPistonSensor_setup_alt(
            self,
            M1,
            src,
            dispersion,
            field_of_view,
            _nyquist_factor_,
            _BIN_IMAGE_,
        )
    }
    #[inline]
    pub unsafe fn cleanup(&mut self) {
        segmentPistonSensor_cleanup(self)
    }
    #[inline]
    pub unsafe fn cleanup_alt(&mut self) {
        segmentPistonSensor_cleanup_alt(self)
    }
    #[inline]
    pub unsafe fn propagate(&mut self, src: *mut source) {
        segmentPistonSensor_propagate(self, src)
    }
    #[inline]
    pub unsafe fn propagate1(&mut self, src: *mut source, middle_mask_width: f32) {
        segmentPistonSensor_propagate1(self, src, middle_mask_width)
    }
    #[inline]
    pub unsafe fn propagate_alt(&mut self, src: *mut source) {
        segmentPistonSensor_propagate_alt(self, src)
    }
    #[inline]
    pub unsafe fn readout(
        &mut self,
        exposureTime: f32,
        readoutNoiseRms: f32,
        nBackgroundPhoton: f32,
    ) {
        segmentPistonSensor_readout(self, exposureTime, readoutNoiseRms, nBackgroundPhoton)
    }
    #[inline]
    pub unsafe fn fft(&mut self) {
        segmentPistonSensor_fft(self)
    }
    #[inline]
    pub unsafe fn info(&mut self) {
        segmentPistonSensor_info(self)
    }
}
